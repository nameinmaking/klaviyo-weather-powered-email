{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst assert = require(\"assert\");\n\nconst rbtree = require(\"functional-red-black-tree\");\n\nconst backoff_1 = require(\"./backoff\");\n\nconst document_1 = require(\"./document\");\n\nconst document_change_1 = require(\"./document-change\");\n\nconst logger_1 = require(\"./logger\");\n\nconst path_1 = require(\"./path\");\n\nconst timestamp_1 = require(\"./timestamp\");\n\nconst types_1 = require(\"./types\");\n\nconst util_1 = require(\"./util\");\n/*!\n * Target ID used by watch. Watch uses a fixed target id since we only support\n * one target per stream.\n * @type {number}\n */\n\n\nconst WATCH_TARGET_ID = 0x1;\n/*!\n * Sentinel value for a document remove.\n */\n\nconst REMOVED = {};\n/*!\n * The change type for document change events.\n */\n// tslint:disable-next-line:variable-name\n\nconst ChangeType = {\n  added: 'added',\n  modified: 'modified',\n  removed: 'removed'\n};\n/*!\n * List of GRPC Error Codes.\n *\n * This corresponds to\n * {@link https://github.com/grpc/grpc/blob/master/doc/statuscodes.md}.\n */\n\nconst GRPC_STATUS_CODE = {\n  // Not an error; returned on success.\n  OK: 0,\n  // The operation was cancelled (typically by the caller).\n  CANCELLED: 1,\n  // Unknown error. An example of where this error may be returned is if a\n  // Status value received from another address space belongs to an error-space\n  // that is not known in this address space. Also errors raised by APIs that\n  // do not return enough error information may be converted to this error.\n  UNKNOWN: 2,\n  // Client specified an invalid argument. Note that this differs from\n  // FAILED_PRECONDITION. INVALID_ARGUMENT indicates arguments that are\n  // problematic regardless of the state of the system (e.g., a malformed file\n  // name).\n  INVALID_ARGUMENT: 3,\n  // Deadline expired before operation could complete. For operations that\n  // change the state of the system, this error may be returned even if the\n  // operation has completed successfully. For example, a successful response\n  // from a server could have been delayed long enough for the deadline to\n  // expire.\n  DEADLINE_EXCEEDED: 4,\n  // Some requested entity (e.g., file or directory) was not found.\n  NOT_FOUND: 5,\n  // Some entity that we attempted to create (e.g., file or directory) already\n  // exists.\n  ALREADY_EXISTS: 6,\n  // The caller does not have permission to execute the specified operation.\n  // PERMISSION_DENIED must not be used for rejections caused by exhausting\n  // some resource (use RESOURCE_EXHAUSTED instead for those errors).\n  // PERMISSION_DENIED must not be used if the caller can not be identified\n  // (use UNAUTHENTICATED instead for those errors).\n  PERMISSION_DENIED: 7,\n  // The request does not have valid authentication credentials for the\n  // operation.\n  UNAUTHENTICATED: 16,\n  // Some resource has been exhausted, perhaps a per-user quota, or perhaps the\n  // entire file system is out of space.\n  RESOURCE_EXHAUSTED: 8,\n  // Operation was rejected because the system is not in a state required for\n  // the operation's execution. For example, directory to be deleted may be\n  // non-empty, an rmdir operation is applied to a non-directory, etc.\n  //\n  // A litmus test that may help a service implementor in deciding\n  // between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:\n  //  (a) Use UNAVAILABLE if the client can retry just the failing call.\n  //  (b) Use ABORTED if the client should retry at a higher-level\n  //      (e.g., restarting a read-modify-write sequence).\n  //  (c) Use FAILED_PRECONDITION if the client should not retry until\n  //      the system state has been explicitly fixed. E.g., if an \"rmdir\"\n  //      fails because the directory is non-empty, FAILED_PRECONDITION\n  //      should be returned since the client should not retry unless\n  //      they have first fixed up the directory by deleting files from it.\n  //  (d) Use FAILED_PRECONDITION if the client performs conditional\n  //      REST Get/Update/Delete on a resource and the resource on the\n  //      server does not match the condition. E.g., conflicting\n  //      read-modify-write on the same resource.\n  FAILED_PRECONDITION: 9,\n  // The operation was aborted, typically due to a concurrency issue like\n  // sequencer check failures, transaction aborts, etc.\n  //\n  // See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,\n  // and UNAVAILABLE.\n  ABORTED: 10,\n  // Operation was attempted past the valid range. E.g., seeking or reading\n  // past end of file.\n  //\n  // Unlike INVALID_ARGUMENT, this error indicates a problem that may be fixed\n  // if the system state changes. For example, a 32-bit file system will\n  // generate INVALID_ARGUMENT if asked to read at an offset that is not in the\n  // range [0,2^32-1], but it will generate OUT_OF_RANGE if asked to read from\n  // an offset past the current file size.\n  //\n  // There is a fair bit of overlap between FAILED_PRECONDITION and\n  // OUT_OF_RANGE. We recommend using OUT_OF_RANGE (the more specific error)\n  // when it applies so that callers who are iterating through a space can\n  // easily look for an OUT_OF_RANGE error to detect when they are done.\n  OUT_OF_RANGE: 11,\n  // Operation is not implemented or not supported/enabled in this service.\n  UNIMPLEMENTED: 12,\n  // Internal errors. Means some invariants expected by underlying System has\n  // been broken. If you see one of these errors, Something is very broken.\n  INTERNAL: 13,\n  // The service is currently unavailable. This is a most likely a transient\n  // condition and may be corrected by retrying with a backoff.\n  //\n  // See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,\n  // and UNAVAILABLE.\n  UNAVAILABLE: 14,\n  // Unrecoverable data loss or corruption.\n  DATA_LOSS: 15,\n  // Force users to include a default branch:\n  DO_NOT_USE: -1\n};\n/*!\n * The comparator used for document watches (which should always get called with\n * the same document).\n */\n\nconst DOCUMENT_WATCH_COMPARATOR = (doc1, doc2) => {\n  assert(doc1 === doc2, 'Document watches only support one document.');\n  return 0;\n};\n\nconst EMPTY_FUNCTION = () => {};\n/**\n * Watch provides listen functionality and exposes the 'onSnapshot' observer. It\n * can be used with a valid Firestore Listen target.\n *\n * @class\n * @private\n */\n\n\nclass Watch {\n  /**\n   * @private\n   * @hideconstructor\n   *\n   * @param firestore The Firestore Database client.\n   */\n  constructor(firestore) {\n    /**\n     * Indicates whether we are interested in data from the stream. Set to false in the\n     * 'unsubscribe()' callback.\n     * @private\n     */\n    this.isActive = true;\n    /**\n     * The current stream to the backend.\n     * @private\n     */\n\n    this.currentStream = null;\n    /**\n     * The server assigns and updates the resume token.\n     * @private\n     */\n\n    this.resumeToken = undefined;\n    /**\n     * A map of document names to QueryDocumentSnapshots for the last sent snapshot.\n     * @private\n     */\n\n    this.docMap = new Map();\n    /**\n     * The accumulated map of document changes (keyed by document name) for the\n     * current snapshot.\n     * @private\n     */\n\n    this.changeMap = new Map();\n    /**\n     * The current state of the query results. *\n     * @private\n     */\n\n    this.current = false;\n    /**\n     * We need this to track whether we've pushed an initial set of changes,\n     * since we should push those even when there are no changes, if there\n     * aren't docs.\n     * @private\n     */\n\n    this.hasPushed = false;\n    this.firestore = firestore;\n    this.backoff = new backoff_1.ExponentialBackoff();\n    this.requestTag = util_1.requestTag();\n    this.onNext = EMPTY_FUNCTION;\n    this.onError = EMPTY_FUNCTION;\n  }\n  /**\n   * Starts a watch and attaches a listener for document change events.\n   *\n   * @private\n   * @param onNext A callback to be called every time a new snapshot is\n   * available.\n   * @param onError A callback to be called if the listen fails or is cancelled.\n   * No further callbacks will occur.\n   *\n   * @returns An unsubscribe function that can be called to cancel the snapshot\n   * listener.\n   */\n\n\n  onSnapshot(onNext, onError) {\n    assert(this.onNext === EMPTY_FUNCTION, 'onNext should not already be defined.');\n    assert(this.onError === EMPTY_FUNCTION, 'onError should not already be defined.');\n    assert(this.docTree === undefined, 'docTree should not already be defined.');\n    this.onNext = onNext;\n    this.onError = onError;\n    this.docTree = rbtree(this.getComparator());\n    this.initStream();\n    return () => {\n      logger_1.logger('Watch.onSnapshot', this.requestTag, 'Ending stream'); // Prevent further callbacks.\n\n      this.isActive = false;\n\n      this.onNext = () => {};\n\n      this.onError = () => {};\n\n      if (this.currentStream) {\n        this.currentStream.end();\n      }\n    };\n  }\n  /**\n   * Returns the current count of all documents, including the changes from\n   * the current changeMap.\n   * @private\n   */\n\n\n  currentSize() {\n    const changes = this.extractCurrentChanges(timestamp_1.Timestamp.now());\n    return this.docMap.size + changes.adds.length - changes.deletes.length;\n  }\n  /**\n   * Splits up document changes into removals, additions, and updates.\n   * @private\n   */\n\n\n  extractCurrentChanges(readTime) {\n    const deletes = [];\n    const adds = [];\n    const updates = [];\n    this.changeMap.forEach((value, name) => {\n      if (value === REMOVED) {\n        if (this.docMap.has(name)) {\n          deletes.push(name);\n        }\n      } else if (this.docMap.has(name)) {\n        value.readTime = readTime;\n        updates.push(value.build());\n      } else {\n        value.readTime = readTime;\n        adds.push(value.build());\n      }\n    });\n    return {\n      deletes,\n      adds,\n      updates\n    };\n  }\n  /**\n   * Helper to clear the docs on RESET or filter mismatch.\n   * @private\n   */\n\n\n  resetDocs() {\n    logger_1.logger('Watch.resetDocs', this.requestTag, 'Resetting documents');\n    this.changeMap.clear();\n    this.resumeToken = undefined;\n    this.docTree.forEach(snapshot => {\n      // Mark each document as deleted. If documents are not deleted, they\n      // will be send again by the server.\n      this.changeMap.set(snapshot.ref.path, REMOVED);\n    });\n    this.current = false;\n  }\n  /**\n   * Closes the stream and calls onError() if the stream is still active.\n   * @private\n   */\n\n\n  closeStream(err) {\n    if (this.currentStream) {\n      this.currentStream.end();\n      this.currentStream = null;\n    }\n\n    if (this.isActive) {\n      this.isActive = false;\n      logger_1.logger('Watch.closeStream', this.requestTag, 'Invoking onError: ', err);\n      this.onError(err);\n    }\n  }\n  /**\n   * Re-opens the stream unless the specified error is considered permanent.\n   * Clears the change map.\n   * @private\n   */\n\n\n  maybeReopenStream(err) {\n    if (this.isActive && !this.isPermanentError(err)) {\n      logger_1.logger('Watch.maybeReopenStream', this.requestTag, 'Stream ended, re-opening after retryable error: ', err);\n      this.changeMap.clear();\n\n      if (this.isResourceExhaustedError(err)) {\n        this.backoff.resetToMax();\n      }\n\n      this.initStream();\n    } else {\n      this.closeStream(err);\n    }\n  }\n  /**\n   * Helper to restart the outgoing stream to the backend.\n   * @private\n   */\n\n\n  resetStream() {\n    logger_1.logger('Watch.resetStream', this.requestTag, 'Restarting stream');\n\n    if (this.currentStream) {\n      this.currentStream.end();\n      this.currentStream = null;\n    }\n\n    this.initStream();\n  }\n  /**\n   * Initializes a new stream to the backend with backoff.\n   * @private\n   */\n\n\n  initStream() {\n    this.backoff.backoffAndWait().then(async () => {\n      if (!this.isActive) {\n        logger_1.logger('Watch.initStream', this.requestTag, 'Not initializing inactive stream');\n        return;\n      }\n\n      await this.firestore.initializeIfNeeded(this.requestTag);\n      const request = {};\n      request.database = this.firestore.formattedName;\n      request.addTarget = this.getTarget(this.resumeToken); // Note that we need to call the internal _listen API to pass additional\n      // header values in readWriteStream.\n\n      return this.firestore.readWriteStream('listen', request, this.requestTag, true).then(backendStream => {\n        if (!this.isActive) {\n          logger_1.logger('Watch.initStream', this.requestTag, 'Closing inactive stream');\n          backendStream.end();\n          return;\n        }\n\n        logger_1.logger('Watch.initStream', this.requestTag, 'Opened new stream');\n        this.currentStream = backendStream;\n        this.currentStream.on('data', proto => {\n          this.onData(proto);\n        }).on('error', err => {\n          if (this.currentStream === backendStream) {\n            this.currentStream = null;\n            this.maybeReopenStream(err);\n          }\n        }).on('end', () => {\n          if (this.currentStream === backendStream) {\n            this.currentStream = null;\n            const err = new types_1.GrpcError('Stream ended unexpectedly');\n            err.code = GRPC_STATUS_CODE.UNKNOWN;\n            this.maybeReopenStream(err);\n          }\n        });\n        this.currentStream.resume();\n      });\n    }).catch(err => {\n      this.closeStream(err);\n    });\n  }\n  /**\n   * Handles 'data' events and closes the stream if the response type is\n   * invalid.\n   * @private\n   */\n\n\n  onData(proto) {\n    if (proto.targetChange) {\n      logger_1.logger('Watch.onData', this.requestTag, 'Processing target change');\n      const change = proto.targetChange;\n      const noTargetIds = !change.targetIds || change.targetIds.length === 0;\n\n      if (change.targetChangeType === 'NO_CHANGE') {\n        if (noTargetIds && change.readTime && this.current) {\n          // This means everything is up-to-date, so emit the current\n          // set of docs as a snapshot, if there were changes.\n          this.pushSnapshot(timestamp_1.Timestamp.fromProto(change.readTime), change.resumeToken);\n        }\n      } else if (change.targetChangeType === 'ADD') {\n        if (WATCH_TARGET_ID !== change.targetIds[0]) {\n          this.closeStream(Error('Unexpected target ID sent by server'));\n        }\n      } else if (change.targetChangeType === 'REMOVE') {\n        let code = 13;\n        let message = 'internal error';\n\n        if (change.cause) {\n          code = change.cause.code;\n          message = change.cause.message;\n        } // @todo: Surface a .code property on the exception.\n\n\n        this.closeStream(new Error('Error ' + code + ': ' + message));\n      } else if (change.targetChangeType === 'RESET') {\n        // Whatever changes have happened so far no longer matter.\n        this.resetDocs();\n      } else if (change.targetChangeType === 'CURRENT') {\n        this.current = true;\n      } else {\n        this.closeStream(new Error('Unknown target change type: ' + JSON.stringify(change)));\n      }\n\n      if (change.resumeToken && this.affectsTarget(change.targetIds, WATCH_TARGET_ID)) {\n        this.backoff.reset();\n      }\n    } else if (proto.documentChange) {\n      logger_1.logger('Watch.onData', this.requestTag, 'Processing change event'); // No other targetIds can show up here, but we still need to see\n      // if the targetId was in the added list or removed list.\n\n      const targetIds = proto.documentChange.targetIds || [];\n      const removedTargetIds = proto.documentChange.removedTargetIds || [];\n      let changed = false;\n      let removed = false;\n\n      for (let i = 0; i < targetIds.length; i++) {\n        if (targetIds[i] === WATCH_TARGET_ID) {\n          changed = true;\n        }\n      }\n\n      for (let i = 0; i < removedTargetIds.length; i++) {\n        if (removedTargetIds[i] === WATCH_TARGET_ID) {\n          removed = true;\n        }\n      }\n\n      const document = proto.documentChange.document;\n      const name = document.name;\n      const relativeName = path_1.QualifiedResourcePath.fromSlashSeparatedString(name).relativeName;\n\n      if (changed) {\n        logger_1.logger('Watch.onData', this.requestTag, 'Received document change');\n        const snapshot = new document_1.DocumentSnapshotBuilder();\n        snapshot.ref = this.firestore.doc(relativeName);\n        snapshot.fieldsProto = document.fields || {};\n        snapshot.createTime = timestamp_1.Timestamp.fromProto(document.createTime);\n        snapshot.updateTime = timestamp_1.Timestamp.fromProto(document.updateTime);\n        this.changeMap.set(relativeName, snapshot);\n      } else if (removed) {\n        logger_1.logger('Watch.onData', this.requestTag, 'Received document remove');\n        this.changeMap.set(relativeName, REMOVED);\n      }\n    } else if (proto.documentDelete || proto.documentRemove) {\n      logger_1.logger('Watch.onData', this.requestTag, 'Processing remove event');\n      const name = (proto.documentDelete || proto.documentRemove).document;\n      const relativeName = path_1.QualifiedResourcePath.fromSlashSeparatedString(name).relativeName;\n      this.changeMap.set(relativeName, REMOVED);\n    } else if (proto.filter) {\n      logger_1.logger('Watch.onData', this.requestTag, 'Processing filter update');\n\n      if (proto.filter.count !== this.currentSize()) {\n        // We need to remove all the current results.\n        this.resetDocs(); // The filter didn't match, so re-issue the query.\n\n        this.resetStream();\n      }\n    } else {\n      this.closeStream(new Error('Unknown listen response type: ' + JSON.stringify(proto)));\n    }\n  }\n  /**\n   * Checks if the current target id is included in the list of target ids.\n   * If no targetIds are provided, returns true.\n   * @private\n   */\n\n\n  affectsTarget(targetIds, currentId) {\n    if (targetIds === undefined || targetIds.length === 0) {\n      return true;\n    }\n\n    for (const targetId of targetIds) {\n      if (targetId === currentId) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Assembles a new snapshot from the current set of changes and invokes the\n   * user's callback. Clears the current changes on completion.\n   * @private\n   */\n\n\n  pushSnapshot(readTime, nextResumeToken) {\n    const appliedChanges = this.computeSnapshot(readTime);\n\n    if (!this.hasPushed || appliedChanges.length > 0) {\n      logger_1.logger('Watch.pushSnapshot', this.requestTag, 'Sending snapshot with %d changes and %d documents', String(appliedChanges.length), this.docTree.length); // We pass the current set of changes, even if `docTree` is modified later.\n\n      const currentTree = this.docTree;\n      this.onNext(readTime, currentTree.length, () => currentTree.keys, () => appliedChanges);\n      this.hasPushed = true;\n    }\n\n    this.changeMap.clear();\n    this.resumeToken = nextResumeToken;\n  }\n  /**\n   * Applies a document delete to the document tree and the document map.\n   * Returns the corresponding DocumentChange event.\n   * @private\n   */\n\n\n  deleteDoc(name) {\n    assert(this.docMap.has(name), 'Document to delete does not exist');\n    const oldDocument = this.docMap.get(name);\n    const existing = this.docTree.find(oldDocument);\n    const oldIndex = existing.index;\n    this.docTree = existing.remove();\n    this.docMap.delete(name);\n    return new document_change_1.DocumentChange(ChangeType.removed, oldDocument, oldIndex, -1);\n  }\n  /**\n   * Applies a document add to the document tree and the document map. Returns\n   * the corresponding DocumentChange event.\n   * @private\n   */\n\n\n  addDoc(newDocument) {\n    const name = newDocument.ref.path;\n    assert(!this.docMap.has(name), 'Document to add already exists');\n    this.docTree = this.docTree.insert(newDocument, null);\n    const newIndex = this.docTree.find(newDocument).index;\n    this.docMap.set(name, newDocument);\n    return new document_change_1.DocumentChange(ChangeType.added, newDocument, -1, newIndex);\n  }\n  /**\n   * Applies a document modification to the document tree and the document map.\n   * Returns the DocumentChange event for successful modifications.\n   * @private\n   */\n\n\n  modifyDoc(newDocument) {\n    const name = newDocument.ref.path;\n    assert(this.docMap.has(name), 'Document to modify does not exist');\n    const oldDocument = this.docMap.get(name);\n\n    if (!oldDocument.updateTime.isEqual(newDocument.updateTime)) {\n      const removeChange = this.deleteDoc(name);\n      const addChange = this.addDoc(newDocument);\n      return new document_change_1.DocumentChange(ChangeType.modified, newDocument, removeChange.oldIndex, addChange.newIndex);\n    }\n\n    return null;\n  }\n  /**\n   * Applies the mutations in changeMap to both the document tree and the\n   * document lookup map. Modified docMap in-place and returns the updated\n   * state.\n   * @private\n   */\n\n\n  computeSnapshot(readTime) {\n    const changeSet = this.extractCurrentChanges(readTime);\n    const appliedChanges = []; // Process the sorted changes in the order that is expected by our clients\n    // (removals, additions, and then modifications). We also need to sort the\n    // individual changes to assure that oldIndex/newIndex keep incrementing.\n\n    changeSet.deletes.sort((name1, name2) => {\n      // Deletes are sorted based on the order of the existing document.\n      return this.getComparator()(this.docMap.get(name1), this.docMap.get(name2));\n    });\n    changeSet.deletes.forEach(name => {\n      const change = this.deleteDoc(name);\n      appliedChanges.push(change);\n    });\n    changeSet.adds.sort(this.getComparator());\n    changeSet.adds.forEach(snapshot => {\n      const change = this.addDoc(snapshot);\n      appliedChanges.push(change);\n    });\n    changeSet.updates.sort(this.getComparator());\n    changeSet.updates.forEach(snapshot => {\n      const change = this.modifyDoc(snapshot);\n\n      if (change) {\n        appliedChanges.push(change);\n      }\n    });\n    assert(this.docTree.length === this.docMap.size, 'The update document ' + 'tree and document map should have the same number of entries.');\n    return appliedChanges;\n  }\n  /**\n   * Determines whether an error is considered permanent and should not be\n   * retried. Errors that don't provide a GRPC error code are always considered\n   * transient in this context.\n   *\n   * @private\n   * @param error An error object.\n   * @return Whether the error is permanent.\n   */\n\n\n  isPermanentError(error) {\n    if (error.code === undefined) {\n      logger_1.logger('Watch.isPermanentError', this.requestTag, 'Unable to determine error code: ', error);\n      return false;\n    }\n\n    switch (error.code) {\n      case GRPC_STATUS_CODE.ABORTED:\n      case GRPC_STATUS_CODE.CANCELLED:\n      case GRPC_STATUS_CODE.UNKNOWN:\n      case GRPC_STATUS_CODE.DEADLINE_EXCEEDED:\n      case GRPC_STATUS_CODE.RESOURCE_EXHAUSTED:\n      case GRPC_STATUS_CODE.INTERNAL:\n      case GRPC_STATUS_CODE.UNAVAILABLE:\n      case GRPC_STATUS_CODE.UNAUTHENTICATED:\n        return false;\n\n      default:\n        return true;\n    }\n  }\n  /**\n   * Determines whether we need to initiate a longer backoff due to system\n   * overload.\n   *\n   * @private\n   * @param error A GRPC Error object that exposes an error code.\n   * @return Whether we need to back off our retries.\n   */\n\n\n  isResourceExhaustedError(error) {\n    return error.code === GRPC_STATUS_CODE.RESOURCE_EXHAUSTED;\n  }\n\n}\n/**\n * Creates a new Watch instance to listen on DocumentReferences.\n *\n * @private\n */\n\n\nclass DocumentWatch extends Watch {\n  constructor(firestore, ref) {\n    super(firestore);\n    this.ref = ref;\n  }\n\n  getComparator() {\n    return DOCUMENT_WATCH_COMPARATOR;\n  }\n\n  getTarget(resumeToken) {\n    const formattedName = this.ref.formattedName;\n    return {\n      documents: {\n        documents: [formattedName]\n      },\n      targetId: WATCH_TARGET_ID,\n      resumeToken\n    };\n  }\n\n}\n\nexports.DocumentWatch = DocumentWatch;\n/**\n * Creates a new Watch instance to listen on Queries.\n *\n * @private\n */\n\nclass QueryWatch extends Watch {\n  constructor(firestore, query) {\n    super(firestore);\n    this.query = query;\n    this.comparator = query.comparator();\n  }\n\n  getComparator() {\n    return this.query.comparator();\n  }\n\n  getTarget(resumeToken) {\n    const query = this.query.toProto();\n    return {\n      query,\n      targetId: WATCH_TARGET_ID,\n      resumeToken\n    };\n  }\n\n}\n\nexports.QueryWatch = QueryWatch;","map":{"version":3,"sources":["/home/strider/Desktop/github/klaviyo-weather-powered-email/frontend/node_modules/@google-cloud/firestore/build/src/watch.js"],"names":["Object","defineProperty","exports","value","assert","require","rbtree","backoff_1","document_1","document_change_1","logger_1","path_1","timestamp_1","types_1","util_1","WATCH_TARGET_ID","REMOVED","ChangeType","added","modified","removed","GRPC_STATUS_CODE","OK","CANCELLED","UNKNOWN","INVALID_ARGUMENT","DEADLINE_EXCEEDED","NOT_FOUND","ALREADY_EXISTS","PERMISSION_DENIED","UNAUTHENTICATED","RESOURCE_EXHAUSTED","FAILED_PRECONDITION","ABORTED","OUT_OF_RANGE","UNIMPLEMENTED","INTERNAL","UNAVAILABLE","DATA_LOSS","DO_NOT_USE","DOCUMENT_WATCH_COMPARATOR","doc1","doc2","EMPTY_FUNCTION","Watch","constructor","firestore","isActive","currentStream","resumeToken","undefined","docMap","Map","changeMap","current","hasPushed","backoff","ExponentialBackoff","requestTag","onNext","onError","onSnapshot","docTree","getComparator","initStream","logger","end","currentSize","changes","extractCurrentChanges","Timestamp","now","size","adds","length","deletes","readTime","updates","forEach","name","has","push","build","resetDocs","clear","snapshot","set","ref","path","closeStream","err","maybeReopenStream","isPermanentError","isResourceExhaustedError","resetToMax","resetStream","backoffAndWait","then","initializeIfNeeded","request","database","formattedName","addTarget","getTarget","readWriteStream","backendStream","on","proto","onData","GrpcError","code","resume","catch","targetChange","change","noTargetIds","targetIds","targetChangeType","pushSnapshot","fromProto","Error","message","cause","JSON","stringify","affectsTarget","reset","documentChange","removedTargetIds","changed","i","document","relativeName","QualifiedResourcePath","fromSlashSeparatedString","DocumentSnapshotBuilder","doc","fieldsProto","fields","createTime","updateTime","documentDelete","documentRemove","filter","count","currentId","targetId","nextResumeToken","appliedChanges","computeSnapshot","String","currentTree","keys","deleteDoc","oldDocument","get","existing","find","oldIndex","index","remove","delete","DocumentChange","addDoc","newDocument","insert","newIndex","modifyDoc","isEqual","removeChange","addChange","changeSet","sort","name1","name2","error","DocumentWatch","documents","QueryWatch","query","comparator","toProto"],"mappings":"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","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert = require(\"assert\");\nconst rbtree = require(\"functional-red-black-tree\");\nconst backoff_1 = require(\"./backoff\");\nconst document_1 = require(\"./document\");\nconst document_change_1 = require(\"./document-change\");\nconst logger_1 = require(\"./logger\");\nconst path_1 = require(\"./path\");\nconst timestamp_1 = require(\"./timestamp\");\nconst types_1 = require(\"./types\");\nconst util_1 = require(\"./util\");\n/*!\n * Target ID used by watch. Watch uses a fixed target id since we only support\n * one target per stream.\n * @type {number}\n */\nconst WATCH_TARGET_ID = 0x1;\n/*!\n * Sentinel value for a document remove.\n */\nconst REMOVED = {};\n/*!\n * The change type for document change events.\n */\n// tslint:disable-next-line:variable-name\nconst ChangeType = {\n    added: 'added',\n    modified: 'modified',\n    removed: 'removed',\n};\n/*!\n * List of GRPC Error Codes.\n *\n * This corresponds to\n * {@link https://github.com/grpc/grpc/blob/master/doc/statuscodes.md}.\n */\nconst GRPC_STATUS_CODE = {\n    // Not an error; returned on success.\n    OK: 0,\n    // The operation was cancelled (typically by the caller).\n    CANCELLED: 1,\n    // Unknown error. An example of where this error may be returned is if a\n    // Status value received from another address space belongs to an error-space\n    // that is not known in this address space. Also errors raised by APIs that\n    // do not return enough error information may be converted to this error.\n    UNKNOWN: 2,\n    // Client specified an invalid argument. Note that this differs from\n    // FAILED_PRECONDITION. INVALID_ARGUMENT indicates arguments that are\n    // problematic regardless of the state of the system (e.g., a malformed file\n    // name).\n    INVALID_ARGUMENT: 3,\n    // Deadline expired before operation could complete. For operations that\n    // change the state of the system, this error may be returned even if the\n    // operation has completed successfully. For example, a successful response\n    // from a server could have been delayed long enough for the deadline to\n    // expire.\n    DEADLINE_EXCEEDED: 4,\n    // Some requested entity (e.g., file or directory) was not found.\n    NOT_FOUND: 5,\n    // Some entity that we attempted to create (e.g., file or directory) already\n    // exists.\n    ALREADY_EXISTS: 6,\n    // The caller does not have permission to execute the specified operation.\n    // PERMISSION_DENIED must not be used for rejections caused by exhausting\n    // some resource (use RESOURCE_EXHAUSTED instead for those errors).\n    // PERMISSION_DENIED must not be used if the caller can not be identified\n    // (use UNAUTHENTICATED instead for those errors).\n    PERMISSION_DENIED: 7,\n    // The request does not have valid authentication credentials for the\n    // operation.\n    UNAUTHENTICATED: 16,\n    // Some resource has been exhausted, perhaps a per-user quota, or perhaps the\n    // entire file system is out of space.\n    RESOURCE_EXHAUSTED: 8,\n    // Operation was rejected because the system is not in a state required for\n    // the operation's execution. For example, directory to be deleted may be\n    // non-empty, an rmdir operation is applied to a non-directory, etc.\n    //\n    // A litmus test that may help a service implementor in deciding\n    // between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:\n    //  (a) Use UNAVAILABLE if the client can retry just the failing call.\n    //  (b) Use ABORTED if the client should retry at a higher-level\n    //      (e.g., restarting a read-modify-write sequence).\n    //  (c) Use FAILED_PRECONDITION if the client should not retry until\n    //      the system state has been explicitly fixed. E.g., if an \"rmdir\"\n    //      fails because the directory is non-empty, FAILED_PRECONDITION\n    //      should be returned since the client should not retry unless\n    //      they have first fixed up the directory by deleting files from it.\n    //  (d) Use FAILED_PRECONDITION if the client performs conditional\n    //      REST Get/Update/Delete on a resource and the resource on the\n    //      server does not match the condition. E.g., conflicting\n    //      read-modify-write on the same resource.\n    FAILED_PRECONDITION: 9,\n    // The operation was aborted, typically due to a concurrency issue like\n    // sequencer check failures, transaction aborts, etc.\n    //\n    // See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,\n    // and UNAVAILABLE.\n    ABORTED: 10,\n    // Operation was attempted past the valid range. E.g., seeking or reading\n    // past end of file.\n    //\n    // Unlike INVALID_ARGUMENT, this error indicates a problem that may be fixed\n    // if the system state changes. For example, a 32-bit file system will\n    // generate INVALID_ARGUMENT if asked to read at an offset that is not in the\n    // range [0,2^32-1], but it will generate OUT_OF_RANGE if asked to read from\n    // an offset past the current file size.\n    //\n    // There is a fair bit of overlap between FAILED_PRECONDITION and\n    // OUT_OF_RANGE. We recommend using OUT_OF_RANGE (the more specific error)\n    // when it applies so that callers who are iterating through a space can\n    // easily look for an OUT_OF_RANGE error to detect when they are done.\n    OUT_OF_RANGE: 11,\n    // Operation is not implemented or not supported/enabled in this service.\n    UNIMPLEMENTED: 12,\n    // Internal errors. Means some invariants expected by underlying System has\n    // been broken. If you see one of these errors, Something is very broken.\n    INTERNAL: 13,\n    // The service is currently unavailable. This is a most likely a transient\n    // condition and may be corrected by retrying with a backoff.\n    //\n    // See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,\n    // and UNAVAILABLE.\n    UNAVAILABLE: 14,\n    // Unrecoverable data loss or corruption.\n    DATA_LOSS: 15,\n    // Force users to include a default branch:\n    DO_NOT_USE: -1,\n};\n/*!\n * The comparator used for document watches (which should always get called with\n * the same document).\n */\nconst DOCUMENT_WATCH_COMPARATOR = (doc1, doc2) => {\n    assert(doc1 === doc2, 'Document watches only support one document.');\n    return 0;\n};\nconst EMPTY_FUNCTION = () => { };\n/**\n * Watch provides listen functionality and exposes the 'onSnapshot' observer. It\n * can be used with a valid Firestore Listen target.\n *\n * @class\n * @private\n */\nclass Watch {\n    /**\n     * @private\n     * @hideconstructor\n     *\n     * @param firestore The Firestore Database client.\n     */\n    constructor(firestore) {\n        /**\n         * Indicates whether we are interested in data from the stream. Set to false in the\n         * 'unsubscribe()' callback.\n         * @private\n         */\n        this.isActive = true;\n        /**\n         * The current stream to the backend.\n         * @private\n         */\n        this.currentStream = null;\n        /**\n         * The server assigns and updates the resume token.\n         * @private\n         */\n        this.resumeToken = undefined;\n        /**\n         * A map of document names to QueryDocumentSnapshots for the last sent snapshot.\n         * @private\n         */\n        this.docMap = new Map();\n        /**\n         * The accumulated map of document changes (keyed by document name) for the\n         * current snapshot.\n         * @private\n         */\n        this.changeMap = new Map();\n        /**\n         * The current state of the query results. *\n         * @private\n         */\n        this.current = false;\n        /**\n         * We need this to track whether we've pushed an initial set of changes,\n         * since we should push those even when there are no changes, if there\n         * aren't docs.\n         * @private\n         */\n        this.hasPushed = false;\n        this.firestore = firestore;\n        this.backoff = new backoff_1.ExponentialBackoff();\n        this.requestTag = util_1.requestTag();\n        this.onNext = EMPTY_FUNCTION;\n        this.onError = EMPTY_FUNCTION;\n    }\n    /**\n     * Starts a watch and attaches a listener for document change events.\n     *\n     * @private\n     * @param onNext A callback to be called every time a new snapshot is\n     * available.\n     * @param onError A callback to be called if the listen fails or is cancelled.\n     * No further callbacks will occur.\n     *\n     * @returns An unsubscribe function that can be called to cancel the snapshot\n     * listener.\n     */\n    onSnapshot(onNext, onError) {\n        assert(this.onNext === EMPTY_FUNCTION, 'onNext should not already be defined.');\n        assert(this.onError === EMPTY_FUNCTION, 'onError should not already be defined.');\n        assert(this.docTree === undefined, 'docTree should not already be defined.');\n        this.onNext = onNext;\n        this.onError = onError;\n        this.docTree = rbtree(this.getComparator());\n        this.initStream();\n        return () => {\n            logger_1.logger('Watch.onSnapshot', this.requestTag, 'Ending stream');\n            // Prevent further callbacks.\n            this.isActive = false;\n            this.onNext = () => { };\n            this.onError = () => { };\n            if (this.currentStream) {\n                this.currentStream.end();\n            }\n        };\n    }\n    /**\n     * Returns the current count of all documents, including the changes from\n     * the current changeMap.\n     * @private\n     */\n    currentSize() {\n        const changes = this.extractCurrentChanges(timestamp_1.Timestamp.now());\n        return this.docMap.size + changes.adds.length - changes.deletes.length;\n    }\n    /**\n     * Splits up document changes into removals, additions, and updates.\n     * @private\n     */\n    extractCurrentChanges(readTime) {\n        const deletes = [];\n        const adds = [];\n        const updates = [];\n        this.changeMap.forEach((value, name) => {\n            if (value === REMOVED) {\n                if (this.docMap.has(name)) {\n                    deletes.push(name);\n                }\n            }\n            else if (this.docMap.has(name)) {\n                value.readTime = readTime;\n                updates.push(value.build());\n            }\n            else {\n                value.readTime = readTime;\n                adds.push(value.build());\n            }\n        });\n        return { deletes, adds, updates };\n    }\n    /**\n     * Helper to clear the docs on RESET or filter mismatch.\n     * @private\n     */\n    resetDocs() {\n        logger_1.logger('Watch.resetDocs', this.requestTag, 'Resetting documents');\n        this.changeMap.clear();\n        this.resumeToken = undefined;\n        this.docTree.forEach((snapshot) => {\n            // Mark each document as deleted. If documents are not deleted, they\n            // will be send again by the server.\n            this.changeMap.set(snapshot.ref.path, REMOVED);\n        });\n        this.current = false;\n    }\n    /**\n     * Closes the stream and calls onError() if the stream is still active.\n     * @private\n     */\n    closeStream(err) {\n        if (this.currentStream) {\n            this.currentStream.end();\n            this.currentStream = null;\n        }\n        if (this.isActive) {\n            this.isActive = false;\n            logger_1.logger('Watch.closeStream', this.requestTag, 'Invoking onError: ', err);\n            this.onError(err);\n        }\n    }\n    /**\n     * Re-opens the stream unless the specified error is considered permanent.\n     * Clears the change map.\n     * @private\n     */\n    maybeReopenStream(err) {\n        if (this.isActive && !this.isPermanentError(err)) {\n            logger_1.logger('Watch.maybeReopenStream', this.requestTag, 'Stream ended, re-opening after retryable error: ', err);\n            this.changeMap.clear();\n            if (this.isResourceExhaustedError(err)) {\n                this.backoff.resetToMax();\n            }\n            this.initStream();\n        }\n        else {\n            this.closeStream(err);\n        }\n    }\n    /**\n     * Helper to restart the outgoing stream to the backend.\n     * @private\n     */\n    resetStream() {\n        logger_1.logger('Watch.resetStream', this.requestTag, 'Restarting stream');\n        if (this.currentStream) {\n            this.currentStream.end();\n            this.currentStream = null;\n        }\n        this.initStream();\n    }\n    /**\n     * Initializes a new stream to the backend with backoff.\n     * @private\n     */\n    initStream() {\n        this.backoff\n            .backoffAndWait()\n            .then(async () => {\n            if (!this.isActive) {\n                logger_1.logger('Watch.initStream', this.requestTag, 'Not initializing inactive stream');\n                return;\n            }\n            await this.firestore.initializeIfNeeded(this.requestTag);\n            const request = {};\n            request.database = this.firestore.formattedName;\n            request.addTarget = this.getTarget(this.resumeToken);\n            // Note that we need to call the internal _listen API to pass additional\n            // header values in readWriteStream.\n            return this.firestore\n                .readWriteStream('listen', request, this.requestTag, true)\n                .then(backendStream => {\n                if (!this.isActive) {\n                    logger_1.logger('Watch.initStream', this.requestTag, 'Closing inactive stream');\n                    backendStream.end();\n                    return;\n                }\n                logger_1.logger('Watch.initStream', this.requestTag, 'Opened new stream');\n                this.currentStream = backendStream;\n                this.currentStream.on('data', (proto) => {\n                    this.onData(proto);\n                })\n                    .on('error', err => {\n                    if (this.currentStream === backendStream) {\n                        this.currentStream = null;\n                        this.maybeReopenStream(err);\n                    }\n                })\n                    .on('end', () => {\n                    if (this.currentStream === backendStream) {\n                        this.currentStream = null;\n                        const err = new types_1.GrpcError('Stream ended unexpectedly');\n                        err.code = GRPC_STATUS_CODE.UNKNOWN;\n                        this.maybeReopenStream(err);\n                    }\n                });\n                this.currentStream.resume();\n            });\n        })\n            .catch(err => {\n            this.closeStream(err);\n        });\n    }\n    /**\n     * Handles 'data' events and closes the stream if the response type is\n     * invalid.\n     * @private\n     */\n    onData(proto) {\n        if (proto.targetChange) {\n            logger_1.logger('Watch.onData', this.requestTag, 'Processing target change');\n            const change = proto.targetChange;\n            const noTargetIds = !change.targetIds || change.targetIds.length === 0;\n            if (change.targetChangeType === 'NO_CHANGE') {\n                if (noTargetIds && change.readTime && this.current) {\n                    // This means everything is up-to-date, so emit the current\n                    // set of docs as a snapshot, if there were changes.\n                    this.pushSnapshot(timestamp_1.Timestamp.fromProto(change.readTime), change.resumeToken);\n                }\n            }\n            else if (change.targetChangeType === 'ADD') {\n                if (WATCH_TARGET_ID !== change.targetIds[0]) {\n                    this.closeStream(Error('Unexpected target ID sent by server'));\n                }\n            }\n            else if (change.targetChangeType === 'REMOVE') {\n                let code = 13;\n                let message = 'internal error';\n                if (change.cause) {\n                    code = change.cause.code;\n                    message = change.cause.message;\n                }\n                // @todo: Surface a .code property on the exception.\n                this.closeStream(new Error('Error ' + code + ': ' + message));\n            }\n            else if (change.targetChangeType === 'RESET') {\n                // Whatever changes have happened so far no longer matter.\n                this.resetDocs();\n            }\n            else if (change.targetChangeType === 'CURRENT') {\n                this.current = true;\n            }\n            else {\n                this.closeStream(new Error('Unknown target change type: ' + JSON.stringify(change)));\n            }\n            if (change.resumeToken &&\n                this.affectsTarget(change.targetIds, WATCH_TARGET_ID)) {\n                this.backoff.reset();\n            }\n        }\n        else if (proto.documentChange) {\n            logger_1.logger('Watch.onData', this.requestTag, 'Processing change event');\n            // No other targetIds can show up here, but we still need to see\n            // if the targetId was in the added list or removed list.\n            const targetIds = proto.documentChange.targetIds || [];\n            const removedTargetIds = proto.documentChange.removedTargetIds || [];\n            let changed = false;\n            let removed = false;\n            for (let i = 0; i < targetIds.length; i++) {\n                if (targetIds[i] === WATCH_TARGET_ID) {\n                    changed = true;\n                }\n            }\n            for (let i = 0; i < removedTargetIds.length; i++) {\n                if (removedTargetIds[i] === WATCH_TARGET_ID) {\n                    removed = true;\n                }\n            }\n            const document = proto.documentChange.document;\n            const name = document.name;\n            const relativeName = path_1.QualifiedResourcePath.fromSlashSeparatedString(name)\n                .relativeName;\n            if (changed) {\n                logger_1.logger('Watch.onData', this.requestTag, 'Received document change');\n                const snapshot = new document_1.DocumentSnapshotBuilder();\n                snapshot.ref = this.firestore.doc(relativeName);\n                snapshot.fieldsProto = document.fields || {};\n                snapshot.createTime = timestamp_1.Timestamp.fromProto(document.createTime);\n                snapshot.updateTime = timestamp_1.Timestamp.fromProto(document.updateTime);\n                this.changeMap.set(relativeName, snapshot);\n            }\n            else if (removed) {\n                logger_1.logger('Watch.onData', this.requestTag, 'Received document remove');\n                this.changeMap.set(relativeName, REMOVED);\n            }\n        }\n        else if (proto.documentDelete || proto.documentRemove) {\n            logger_1.logger('Watch.onData', this.requestTag, 'Processing remove event');\n            const name = (proto.documentDelete || proto.documentRemove).document;\n            const relativeName = path_1.QualifiedResourcePath.fromSlashSeparatedString(name)\n                .relativeName;\n            this.changeMap.set(relativeName, REMOVED);\n        }\n        else if (proto.filter) {\n            logger_1.logger('Watch.onData', this.requestTag, 'Processing filter update');\n            if (proto.filter.count !== this.currentSize()) {\n                // We need to remove all the current results.\n                this.resetDocs();\n                // The filter didn't match, so re-issue the query.\n                this.resetStream();\n            }\n        }\n        else {\n            this.closeStream(new Error('Unknown listen response type: ' + JSON.stringify(proto)));\n        }\n    }\n    /**\n     * Checks if the current target id is included in the list of target ids.\n     * If no targetIds are provided, returns true.\n     * @private\n     */\n    affectsTarget(targetIds, currentId) {\n        if (targetIds === undefined || targetIds.length === 0) {\n            return true;\n        }\n        for (const targetId of targetIds) {\n            if (targetId === currentId) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Assembles a new snapshot from the current set of changes and invokes the\n     * user's callback. Clears the current changes on completion.\n     * @private\n     */\n    pushSnapshot(readTime, nextResumeToken) {\n        const appliedChanges = this.computeSnapshot(readTime);\n        if (!this.hasPushed || appliedChanges.length > 0) {\n            logger_1.logger('Watch.pushSnapshot', this.requestTag, 'Sending snapshot with %d changes and %d documents', String(appliedChanges.length), this.docTree.length);\n            // We pass the current set of changes, even if `docTree` is modified later.\n            const currentTree = this.docTree;\n            this.onNext(readTime, currentTree.length, () => currentTree.keys, () => appliedChanges);\n            this.hasPushed = true;\n        }\n        this.changeMap.clear();\n        this.resumeToken = nextResumeToken;\n    }\n    /**\n     * Applies a document delete to the document tree and the document map.\n     * Returns the corresponding DocumentChange event.\n     * @private\n     */\n    deleteDoc(name) {\n        assert(this.docMap.has(name), 'Document to delete does not exist');\n        const oldDocument = this.docMap.get(name);\n        const existing = this.docTree.find(oldDocument);\n        const oldIndex = existing.index;\n        this.docTree = existing.remove();\n        this.docMap.delete(name);\n        return new document_change_1.DocumentChange(ChangeType.removed, oldDocument, oldIndex, -1);\n    }\n    /**\n     * Applies a document add to the document tree and the document map. Returns\n     * the corresponding DocumentChange event.\n     * @private\n     */\n    addDoc(newDocument) {\n        const name = newDocument.ref.path;\n        assert(!this.docMap.has(name), 'Document to add already exists');\n        this.docTree = this.docTree.insert(newDocument, null);\n        const newIndex = this.docTree.find(newDocument).index;\n        this.docMap.set(name, newDocument);\n        return new document_change_1.DocumentChange(ChangeType.added, newDocument, -1, newIndex);\n    }\n    /**\n     * Applies a document modification to the document tree and the document map.\n     * Returns the DocumentChange event for successful modifications.\n     * @private\n     */\n    modifyDoc(newDocument) {\n        const name = newDocument.ref.path;\n        assert(this.docMap.has(name), 'Document to modify does not exist');\n        const oldDocument = this.docMap.get(name);\n        if (!oldDocument.updateTime.isEqual(newDocument.updateTime)) {\n            const removeChange = this.deleteDoc(name);\n            const addChange = this.addDoc(newDocument);\n            return new document_change_1.DocumentChange(ChangeType.modified, newDocument, removeChange.oldIndex, addChange.newIndex);\n        }\n        return null;\n    }\n    /**\n     * Applies the mutations in changeMap to both the document tree and the\n     * document lookup map. Modified docMap in-place and returns the updated\n     * state.\n     * @private\n     */\n    computeSnapshot(readTime) {\n        const changeSet = this.extractCurrentChanges(readTime);\n        const appliedChanges = [];\n        // Process the sorted changes in the order that is expected by our clients\n        // (removals, additions, and then modifications). We also need to sort the\n        // individual changes to assure that oldIndex/newIndex keep incrementing.\n        changeSet.deletes.sort((name1, name2) => {\n            // Deletes are sorted based on the order of the existing document.\n            return this.getComparator()(this.docMap.get(name1), this.docMap.get(name2));\n        });\n        changeSet.deletes.forEach(name => {\n            const change = this.deleteDoc(name);\n            appliedChanges.push(change);\n        });\n        changeSet.adds.sort(this.getComparator());\n        changeSet.adds.forEach(snapshot => {\n            const change = this.addDoc(snapshot);\n            appliedChanges.push(change);\n        });\n        changeSet.updates.sort(this.getComparator());\n        changeSet.updates.forEach(snapshot => {\n            const change = this.modifyDoc(snapshot);\n            if (change) {\n                appliedChanges.push(change);\n            }\n        });\n        assert(this.docTree.length === this.docMap.size, 'The update document ' +\n            'tree and document map should have the same number of entries.');\n        return appliedChanges;\n    }\n    /**\n     * Determines whether an error is considered permanent and should not be\n     * retried. Errors that don't provide a GRPC error code are always considered\n     * transient in this context.\n     *\n     * @private\n     * @param error An error object.\n     * @return Whether the error is permanent.\n     */\n    isPermanentError(error) {\n        if (error.code === undefined) {\n            logger_1.logger('Watch.isPermanentError', this.requestTag, 'Unable to determine error code: ', error);\n            return false;\n        }\n        switch (error.code) {\n            case GRPC_STATUS_CODE.ABORTED:\n            case GRPC_STATUS_CODE.CANCELLED:\n            case GRPC_STATUS_CODE.UNKNOWN:\n            case GRPC_STATUS_CODE.DEADLINE_EXCEEDED:\n            case GRPC_STATUS_CODE.RESOURCE_EXHAUSTED:\n            case GRPC_STATUS_CODE.INTERNAL:\n            case GRPC_STATUS_CODE.UNAVAILABLE:\n            case GRPC_STATUS_CODE.UNAUTHENTICATED:\n                return false;\n            default:\n                return true;\n        }\n    }\n    /**\n     * Determines whether we need to initiate a longer backoff due to system\n     * overload.\n     *\n     * @private\n     * @param error A GRPC Error object that exposes an error code.\n     * @return Whether we need to back off our retries.\n     */\n    isResourceExhaustedError(error) {\n        return error.code === GRPC_STATUS_CODE.RESOURCE_EXHAUSTED;\n    }\n}\n/**\n * Creates a new Watch instance to listen on DocumentReferences.\n *\n * @private\n */\nclass DocumentWatch extends Watch {\n    constructor(firestore, ref) {\n        super(firestore);\n        this.ref = ref;\n    }\n    getComparator() {\n        return DOCUMENT_WATCH_COMPARATOR;\n    }\n    getTarget(resumeToken) {\n        const formattedName = this.ref.formattedName;\n        return {\n            documents: {\n                documents: [formattedName],\n            },\n            targetId: WATCH_TARGET_ID,\n            resumeToken,\n        };\n    }\n}\nexports.DocumentWatch = DocumentWatch;\n/**\n * Creates a new Watch instance to listen on Queries.\n *\n * @private\n */\nclass QueryWatch extends Watch {\n    constructor(firestore, query) {\n        super(firestore);\n        this.query = query;\n        this.comparator = query.comparator();\n    }\n    getComparator() {\n        return this.query.comparator();\n    }\n    getTarget(resumeToken) {\n        const query = this.query.toProto();\n        return { query, targetId: WATCH_TARGET_ID, resumeToken };\n    }\n}\nexports.QueryWatch = QueryWatch;\n//# sourceMappingURL=watch.js.map"]},"metadata":{},"sourceType":"script"}