{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst assert = require(\"assert\");\n\nconst logger_1 = require(\"./logger\");\n/**\n * An auto-resizing pool that distributes concurrent operations over multiple\n * clients of type `T`.\n *\n * ClientPool is used within Firestore to manage a pool of GAPIC clients and\n * automatically initializes multiple clients if we issue more than 100\n * concurrent operations.\n *\n * @private\n */\n\n\nclass ClientPool {\n  /**\n   * @param concurrentOperationLimit The number of operations that each client\n   * can handle.\n   * @param clientFactory A factory function called as needed when new clients\n   * are required.\n   */\n  constructor(concurrentOperationLimit, clientFactory) {\n    this.concurrentOperationLimit = concurrentOperationLimit;\n    this.clientFactory = clientFactory;\n    /**\n     * Stores each active clients and how many operations it has outstanding.\n     * @private\n     */\n\n    this.activeClients = new Map();\n  }\n  /**\n   * Returns an already existing client if it has less than the maximum number\n   * of concurrent operations or initializes and returns a new client.\n   *\n   * @private\n   */\n\n\n  acquire(requestTag) {\n    let selectedClient = null;\n    let selectedRequestCount = 0;\n    this.activeClients.forEach((requestCount, client) => {\n      if (!selectedClient && requestCount < this.concurrentOperationLimit) {\n        logger_1.logger('ClientPool.acquire', requestTag, 'Re-using existing client with %s remaining operations', this.concurrentOperationLimit - requestCount);\n        selectedClient = client;\n        selectedRequestCount = requestCount;\n      }\n    });\n\n    if (!selectedClient) {\n      logger_1.logger('ClientPool.acquire', requestTag, 'Creating a new client');\n      selectedClient = this.clientFactory();\n      assert(!this.activeClients.has(selectedClient), 'The provided client factory returned an existing instance');\n    }\n\n    this.activeClients.set(selectedClient, selectedRequestCount + 1);\n    return selectedClient;\n  }\n  /**\n   * Reduces the number of operations for the provided client, potentially\n   * removing it from the pool of active clients.\n   * @private\n   */\n\n\n  release(requestTag, client) {\n    let requestCount = this.activeClients.get(client) || 0;\n    assert(requestCount > 0, 'No active request');\n    requestCount = requestCount - 1;\n    this.activeClients.set(client, requestCount);\n\n    if (requestCount === 0) {\n      const deletedCount = this.garbageCollect();\n\n      if (deletedCount) {\n        logger_1.logger('ClientPool.release', requestTag, 'Garbage collected %s clients', deletedCount);\n      }\n    }\n  }\n  /**\n   * The number of currently registered clients.\n   *\n   * @return Number of currently registered clients.\n   * @private\n   */\n  // Visible for testing.\n\n\n  get size() {\n    return this.activeClients.size;\n  }\n  /**\n   * The number of currently active operations.\n   *\n   * @return Number of currently active operations.\n   * @private\n   */\n  // Visible for testing.\n\n\n  get opCount() {\n    let activeOperationCount = 0;\n    this.activeClients.forEach(count => activeOperationCount += count);\n    return activeOperationCount;\n  }\n  /**\n   * Runs the provided operation in this pool. This function may create an\n   * additional client if all existing clients already operate at the concurrent\n   * operation limit.\n   *\n   * @param requestTag A unique client-assigned identifier for this operation.\n   * @param op A callback function that returns a Promise. The client T will\n   * be returned to the pool when callback finishes.\n   * @return A Promise that resolves with the result of `op`.\n   * @private\n   */\n\n\n  run(requestTag, op) {\n    const client = this.acquire(requestTag);\n    return op(client).catch(err => {\n      this.release(requestTag, client);\n      return Promise.reject(err);\n    }).then(res => {\n      this.release(requestTag, client);\n      return res;\n    });\n  }\n  /**\n   * Deletes clients that are no longer executing operations. Keeps up to one\n   * idle client to reduce future initialization costs.\n   *\n   * @return Number of clients deleted.\n   * @private\n   */\n\n\n  garbageCollect() {\n    let idleClients = 0;\n    this.activeClients.forEach((requestCount, client) => {\n      if (requestCount === 0) {\n        ++idleClients;\n\n        if (idleClients > 1) {\n          this.activeClients.delete(client);\n        }\n      }\n    });\n    return idleClients - 1;\n  }\n\n}\n\nexports.ClientPool = ClientPool;","map":{"version":3,"sources":["/home/strider/Desktop/github/klaviyo-weather-powered-email/frontend/node_modules/@google-cloud/firestore/build/src/pool.js"],"names":["Object","defineProperty","exports","value","assert","require","logger_1","ClientPool","constructor","concurrentOperationLimit","clientFactory","activeClients","Map","acquire","requestTag","selectedClient","selectedRequestCount","forEach","requestCount","client","logger","has","set","release","get","deletedCount","garbageCollect","size","opCount","activeOperationCount","count","run","op","catch","err","Promise","reject","then","res","idleClients","delete"],"mappings":"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","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert = require(\"assert\");\nconst logger_1 = require(\"./logger\");\n/**\n * An auto-resizing pool that distributes concurrent operations over multiple\n * clients of type `T`.\n *\n * ClientPool is used within Firestore to manage a pool of GAPIC clients and\n * automatically initializes multiple clients if we issue more than 100\n * concurrent operations.\n *\n * @private\n */\nclass ClientPool {\n    /**\n     * @param concurrentOperationLimit The number of operations that each client\n     * can handle.\n     * @param clientFactory A factory function called as needed when new clients\n     * are required.\n     */\n    constructor(concurrentOperationLimit, clientFactory) {\n        this.concurrentOperationLimit = concurrentOperationLimit;\n        this.clientFactory = clientFactory;\n        /**\n         * Stores each active clients and how many operations it has outstanding.\n         * @private\n         */\n        this.activeClients = new Map();\n    }\n    /**\n     * Returns an already existing client if it has less than the maximum number\n     * of concurrent operations or initializes and returns a new client.\n     *\n     * @private\n     */\n    acquire(requestTag) {\n        let selectedClient = null;\n        let selectedRequestCount = 0;\n        this.activeClients.forEach((requestCount, client) => {\n            if (!selectedClient && requestCount < this.concurrentOperationLimit) {\n                logger_1.logger('ClientPool.acquire', requestTag, 'Re-using existing client with %s remaining operations', this.concurrentOperationLimit - requestCount);\n                selectedClient = client;\n                selectedRequestCount = requestCount;\n            }\n        });\n        if (!selectedClient) {\n            logger_1.logger('ClientPool.acquire', requestTag, 'Creating a new client');\n            selectedClient = this.clientFactory();\n            assert(!this.activeClients.has(selectedClient), 'The provided client factory returned an existing instance');\n        }\n        this.activeClients.set(selectedClient, selectedRequestCount + 1);\n        return selectedClient;\n    }\n    /**\n     * Reduces the number of operations for the provided client, potentially\n     * removing it from the pool of active clients.\n     * @private\n     */\n    release(requestTag, client) {\n        let requestCount = this.activeClients.get(client) || 0;\n        assert(requestCount > 0, 'No active request');\n        requestCount = requestCount - 1;\n        this.activeClients.set(client, requestCount);\n        if (requestCount === 0) {\n            const deletedCount = this.garbageCollect();\n            if (deletedCount) {\n                logger_1.logger('ClientPool.release', requestTag, 'Garbage collected %s clients', deletedCount);\n            }\n        }\n    }\n    /**\n     * The number of currently registered clients.\n     *\n     * @return Number of currently registered clients.\n     * @private\n     */\n    // Visible for testing.\n    get size() {\n        return this.activeClients.size;\n    }\n    /**\n     * The number of currently active operations.\n     *\n     * @return Number of currently active operations.\n     * @private\n     */\n    // Visible for testing.\n    get opCount() {\n        let activeOperationCount = 0;\n        this.activeClients.forEach(count => (activeOperationCount += count));\n        return activeOperationCount;\n    }\n    /**\n     * Runs the provided operation in this pool. This function may create an\n     * additional client if all existing clients already operate at the concurrent\n     * operation limit.\n     *\n     * @param requestTag A unique client-assigned identifier for this operation.\n     * @param op A callback function that returns a Promise. The client T will\n     * be returned to the pool when callback finishes.\n     * @return A Promise that resolves with the result of `op`.\n     * @private\n     */\n    run(requestTag, op) {\n        const client = this.acquire(requestTag);\n        return op(client)\n            .catch(err => {\n            this.release(requestTag, client);\n            return Promise.reject(err);\n        })\n            .then(res => {\n            this.release(requestTag, client);\n            return res;\n        });\n    }\n    /**\n     * Deletes clients that are no longer executing operations. Keeps up to one\n     * idle client to reduce future initialization costs.\n     *\n     * @return Number of clients deleted.\n     * @private\n     */\n    garbageCollect() {\n        let idleClients = 0;\n        this.activeClients.forEach((requestCount, client) => {\n            if (requestCount === 0) {\n                ++idleClients;\n                if (idleClients > 1) {\n                    this.activeClients.delete(client);\n                }\n            }\n        });\n        return idleClients - 1;\n    }\n}\nexports.ClientPool = ClientPool;\n//# sourceMappingURL=pool.js.map"]},"metadata":{},"sourceType":"script"}