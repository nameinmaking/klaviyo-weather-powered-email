{"ast":null,"code":"/*! firebase-admin v8.8.0 */\n\"use strict\";\n/*!\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar validator = require(\"../utils/validator\");\n\nvar deep_copy_1 = require(\"../utils/deep-copy\");\n\nvar error_1 = require(\"../utils/error\");\n\nvar api_request_1 = require(\"../utils/api-request\");\n\nvar user_import_builder_1 = require(\"./user-import-builder\");\n\nvar utils = require(\"../utils/index\");\n\nvar action_code_settings_builder_1 = require(\"./action-code-settings-builder\");\n\nvar auth_config_1 = require(\"./auth-config\");\n\nvar tenant_1 = require(\"./tenant\");\n/** Firebase Auth request header. */\n\n\nvar FIREBASE_AUTH_HEADER = {\n  'X-Client-Version': 'Node/Admin/8.8.0'\n};\n/** Firebase Auth request timeout duration in milliseconds. */\n\nvar FIREBASE_AUTH_TIMEOUT = 25000;\n/** List of reserved claims which cannot be provided when creating a custom token. */\n\nexports.RESERVED_CLAIMS = ['acr', 'amr', 'at_hash', 'aud', 'auth_time', 'azp', 'cnf', 'c_hash', 'exp', 'iat', 'iss', 'jti', 'nbf', 'nonce', 'sub', 'firebase'];\n/** List of supported email action request types. */\n\nexports.EMAIL_ACTION_REQUEST_TYPES = ['PASSWORD_RESET', 'VERIFY_EMAIL', 'EMAIL_SIGNIN'];\n/** Maximum allowed number of characters in the custom claims payload. */\n\nvar MAX_CLAIMS_PAYLOAD_SIZE = 1000;\n/** Maximum allowed number of users to batch download at one time. */\n\nvar MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE = 1000;\n/** Maximum allowed number of users to batch upload at one time. */\n\nvar MAX_UPLOAD_ACCOUNT_BATCH_SIZE = 1000;\n/** Minimum allowed session cookie duration in seconds (5 minutes). */\n\nvar MIN_SESSION_COOKIE_DURATION_SECS = 5 * 60;\n/** Maximum allowed session cookie duration in seconds (2 weeks). */\n\nvar MAX_SESSION_COOKIE_DURATION_SECS = 14 * 24 * 60 * 60;\n/** Maximum allowed number of provider configurations to batch download at one time. */\n\nvar MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE = 100;\n/** The Firebase Auth backend base URL format. */\n\nvar FIREBASE_AUTH_BASE_URL_FORMAT = 'https://identitytoolkit.googleapis.com/{version}/projects/{projectId}{api}';\n/** The Firebase Auth backend multi-tenancy base URL format. */\n\nvar FIREBASE_AUTH_TENANT_URL_FORMAT = FIREBASE_AUTH_BASE_URL_FORMAT.replace('projects/{projectId}', 'projects/{projectId}/tenants/{tenantId}');\n/** Maximum allowed number of tenants to download at one time. */\n\nvar MAX_LIST_TENANT_PAGE_SIZE = 1000;\n/** Defines a base utility to help with resource URL construction. */\n\nvar AuthResourceUrlBuilder =\n/** @class */\nfunction () {\n  /**\n   * The resource URL builder constructor.\n   *\n   * @param {string} projectId The resource project ID.\n   * @param {string} version The endpoint API version.\n   * @constructor\n   */\n  function AuthResourceUrlBuilder(projectId, version) {\n    if (version === void 0) {\n      version = 'v1';\n    }\n\n    this.projectId = projectId;\n    this.version = version;\n    this.urlFormat = FIREBASE_AUTH_BASE_URL_FORMAT;\n  }\n  /**\n   * Returns the resource URL corresponding to the provided parameters.\n   *\n   * @param {string=} api The backend API name.\n   * @param {object=} params The optional additional parameters to substitute in the\n   *     URL path.\n   * @return {string} The corresponding resource URL.\n   */\n\n\n  AuthResourceUrlBuilder.prototype.getUrl = function (api, params) {\n    var baseParams = {\n      version: this.version,\n      projectId: this.projectId,\n      api: api || ''\n    };\n    var baseUrl = utils.formatString(this.urlFormat, baseParams); // Substitute additional api related parameters.\n\n    return utils.formatString(baseUrl, params || {});\n  };\n\n  return AuthResourceUrlBuilder;\n}();\n/** Tenant aware resource builder utility. */\n\n\nvar TenantAwareAuthResourceUrlBuilder =\n/** @class */\nfunction (_super) {\n  __extends(TenantAwareAuthResourceUrlBuilder, _super);\n  /**\n   * The tenant aware resource URL builder constructor.\n   *\n   * @param {string} projectId The resource project ID.\n   * @param {string} version The endpoint API version.\n   * @param {string} tenantId The tenant ID.\n   * @constructor\n   */\n\n\n  function TenantAwareAuthResourceUrlBuilder(projectId, version, tenantId) {\n    var _this = _super.call(this, projectId, version) || this;\n\n    _this.projectId = projectId;\n    _this.version = version;\n    _this.tenantId = tenantId;\n    _this.urlFormat = FIREBASE_AUTH_TENANT_URL_FORMAT;\n    return _this;\n  }\n  /**\n   * Returns the resource URL corresponding to the provided parameters.\n   *\n   * @param {string=} api The backend API name.\n   * @param {object=} params The optional additional parameters to substitute in the\n   *     URL path.\n   * @return {string} The corresponding resource URL.\n   */\n\n\n  TenantAwareAuthResourceUrlBuilder.prototype.getUrl = function (api, params) {\n    return utils.formatString(_super.prototype.getUrl.call(this, api, params), {\n      tenantId: this.tenantId\n    });\n  };\n\n  return TenantAwareAuthResourceUrlBuilder;\n}(AuthResourceUrlBuilder);\n/**\n * Validates a providerUserInfo object. All unsupported parameters\n * are removed from the original request. If an invalid field is passed\n * an error is thrown.\n *\n * @param {any} request The providerUserInfo request object.\n */\n\n\nfunction validateProviderUserInfo(request) {\n  var validKeys = {\n    rawId: true,\n    providerId: true,\n    email: true,\n    displayName: true,\n    photoUrl: true\n  }; // Remove invalid keys from original request.\n\n  for (var key in request) {\n    if (!(key in validKeys)) {\n      delete request[key];\n    }\n  }\n\n  if (!validator.isNonEmptyString(request.providerId)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID);\n  }\n\n  if (typeof request.displayName !== 'undefined' && typeof request.displayName !== 'string') {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISPLAY_NAME, \"The provider \\\"displayName\\\" for \\\"\" + request.providerId + \"\\\" must be a valid string.\");\n  }\n\n  if (!validator.isNonEmptyString(request.rawId)) {\n    // This is called localId on the backend but the developer specifies this as\n    // uid externally. So the error message should use the client facing name.\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID, \"The provider \\\"uid\\\" for \\\"\" + request.providerId + \"\\\" must be a valid non-empty string.\");\n  } // email should be a string and a valid email.\n\n\n  if (typeof request.email !== 'undefined' && !validator.isEmail(request.email)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL, \"The provider \\\"email\\\" for \\\"\" + request.providerId + \"\\\" must be a valid email string.\");\n  } // photoUrl should be a URL.\n\n\n  if (typeof request.photoUrl !== 'undefined' && !validator.isURL(request.photoUrl)) {\n    // This is called photoUrl on the backend but the developer specifies this as\n    // photoURL externally. So the error message should use the client facing name.\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHOTO_URL, \"The provider \\\"photoURL\\\" for \\\"\" + request.providerId + \"\\\" must be a valid URL string.\");\n  }\n}\n/**\n * Validates a create/edit request object. All unsupported parameters\n * are removed from the original request. If an invalid field is passed\n * an error is thrown.\n *\n * @param {any} request The create/edit request object.\n * @param {boolean=} uploadAccountRequest Whether to validate as an uploadAccount request.\n */\n\n\nfunction validateCreateEditRequest(request, uploadAccountRequest) {\n  if (uploadAccountRequest === void 0) {\n    uploadAccountRequest = false;\n  } // Hash set of whitelisted parameters.\n\n\n  var validKeys = {\n    displayName: true,\n    localId: true,\n    email: true,\n    password: true,\n    rawPassword: true,\n    emailVerified: true,\n    photoUrl: true,\n    disabled: true,\n    disableUser: true,\n    deleteAttribute: true,\n    deleteProvider: true,\n    sanityCheck: true,\n    phoneNumber: true,\n    customAttributes: true,\n    validSince: true,\n    // Pass tenantId only for uploadAccount requests.\n    tenantId: uploadAccountRequest,\n    passwordHash: uploadAccountRequest,\n    salt: uploadAccountRequest,\n    createdAt: uploadAccountRequest,\n    lastLoginAt: uploadAccountRequest,\n    providerUserInfo: uploadAccountRequest\n  }; // Remove invalid keys from original request.\n\n  for (var key in request) {\n    if (!(key in validKeys)) {\n      delete request[key];\n    }\n  }\n\n  if (typeof request.tenantId !== 'undefined' && !validator.isNonEmptyString(request.tenantId)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID);\n  } // For any invalid parameter, use the external key name in the error description.\n  // displayName should be a string.\n\n\n  if (typeof request.displayName !== 'undefined' && !validator.isString(request.displayName)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISPLAY_NAME);\n  }\n\n  if ((typeof request.localId !== 'undefined' || uploadAccountRequest) && !validator.isUid(request.localId)) {\n    // This is called localId on the backend but the developer specifies this as\n    // uid externally. So the error message should use the client facing name.\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID);\n  } // email should be a string and a valid email.\n\n\n  if (typeof request.email !== 'undefined' && !validator.isEmail(request.email)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL);\n  } // phoneNumber should be a string and a valid phone number.\n\n\n  if (typeof request.phoneNumber !== 'undefined' && !validator.isPhoneNumber(request.phoneNumber)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHONE_NUMBER);\n  } // password should be a string and a minimum of 6 chars.\n\n\n  if (typeof request.password !== 'undefined' && !validator.isPassword(request.password)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD);\n  } // rawPassword should be a string and a minimum of 6 chars.\n\n\n  if (typeof request.rawPassword !== 'undefined' && !validator.isPassword(request.rawPassword)) {\n    // This is called rawPassword on the backend but the developer specifies this as\n    // password externally. So the error message should use the client facing name.\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD);\n  } // emailVerified should be a boolean.\n\n\n  if (typeof request.emailVerified !== 'undefined' && typeof request.emailVerified !== 'boolean') {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL_VERIFIED);\n  } // photoUrl should be a URL.\n\n\n  if (typeof request.photoUrl !== 'undefined' && !validator.isURL(request.photoUrl)) {\n    // This is called photoUrl on the backend but the developer specifies this as\n    // photoURL externally. So the error message should use the client facing name.\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHOTO_URL);\n  } // disabled should be a boolean.\n\n\n  if (typeof request.disabled !== 'undefined' && typeof request.disabled !== 'boolean') {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISABLED_FIELD);\n  } // validSince should be a number.\n\n\n  if (typeof request.validSince !== 'undefined' && !validator.isNumber(request.validSince)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TOKENS_VALID_AFTER_TIME);\n  } // createdAt should be a number.\n\n\n  if (typeof request.createdAt !== 'undefined' && !validator.isNumber(request.createdAt)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CREATION_TIME);\n  } // lastSignInAt should be a number.\n\n\n  if (typeof request.lastLoginAt !== 'undefined' && !validator.isNumber(request.lastLoginAt)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_LAST_SIGN_IN_TIME);\n  } // disableUser should be a boolean.\n\n\n  if (typeof request.disableUser !== 'undefined' && typeof request.disableUser !== 'boolean') {\n    // This is called disableUser on the backend but the developer specifies this as\n    // disabled externally. So the error message should use the client facing name.\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISABLED_FIELD);\n  } // customAttributes should be stringified JSON with no blacklisted claims.\n  // The payload should not exceed 1KB.\n\n\n  if (typeof request.customAttributes !== 'undefined') {\n    var developerClaims_1;\n\n    try {\n      developerClaims_1 = JSON.parse(request.customAttributes);\n    } catch (error) {\n      // JSON parsing error. This should never happen as we stringify the claims internally.\n      // However, we still need to check since setAccountInfo via edit requests could pass\n      // this field.\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CLAIMS, error.message);\n    }\n\n    var invalidClaims_1 = []; // Check for any invalid claims.\n\n    exports.RESERVED_CLAIMS.forEach(function (blacklistedClaim) {\n      if (developerClaims_1.hasOwnProperty(blacklistedClaim)) {\n        invalidClaims_1.push(blacklistedClaim);\n      }\n    }); // Throw an error if an invalid claim is detected.\n\n    if (invalidClaims_1.length > 0) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.FORBIDDEN_CLAIM, invalidClaims_1.length > 1 ? \"Developer claims \\\"\" + invalidClaims_1.join('\", \"') + \"\\\" are reserved and cannot be specified.\" : \"Developer claim \\\"\" + invalidClaims_1[0] + \"\\\" is reserved and cannot be specified.\");\n    } // Check claims payload does not exceed maxmimum size.\n\n\n    if (request.customAttributes.length > MAX_CLAIMS_PAYLOAD_SIZE) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.CLAIMS_TOO_LARGE, \"Developer claims payload should not exceed \" + MAX_CLAIMS_PAYLOAD_SIZE + \" characters.\");\n    }\n  } // passwordHash has to be a base64 encoded string.\n\n\n  if (typeof request.passwordHash !== 'undefined' && !validator.isString(request.passwordHash)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_HASH);\n  } // salt has to be a base64 encoded string.\n\n\n  if (typeof request.salt !== 'undefined' && !validator.isString(request.salt)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_SALT);\n  } // providerUserInfo has to be an array of valid UserInfo requests.\n\n\n  if (typeof request.providerUserInfo !== 'undefined' && !validator.isArray(request.providerUserInfo)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_DATA);\n  } else if (validator.isArray(request.providerUserInfo)) {\n    request.providerUserInfo.forEach(function (providerUserInfoEntry) {\n      validateProviderUserInfo(providerUserInfoEntry);\n    });\n  }\n}\n/** Instantiates the createSessionCookie endpoint settings. */\n\n\nexports.FIREBASE_AUTH_CREATE_SESSION_COOKIE = new api_request_1.ApiSettings(':createSessionCookie', 'POST') // Set request validator.\n.setRequestValidator(function (request) {\n  // Validate the ID token is a non-empty string.\n  if (!validator.isNonEmptyString(request.idToken)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ID_TOKEN);\n  } // Validate the custom session cookie duration.\n\n\n  if (!validator.isNumber(request.validDuration) || request.validDuration < MIN_SESSION_COOKIE_DURATION_SECS || request.validDuration > MAX_SESSION_COOKIE_DURATION_SECS) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION);\n  }\n}) // Set response validator.\n.setResponseValidator(function (response) {\n  // Response should always contain the session cookie.\n  if (!validator.isNonEmptyString(response.sessionCookie)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR);\n  }\n});\n/** Instantiates the uploadAccount endpoint settings. */\n\nexports.FIREBASE_AUTH_UPLOAD_ACCOUNT = new api_request_1.ApiSettings('/accounts:batchCreate', 'POST');\n/** Instantiates the downloadAccount endpoint settings. */\n\nexports.FIREBASE_AUTH_DOWNLOAD_ACCOUNT = new api_request_1.ApiSettings('/accounts:batchGet', 'GET') // Set request validator.\n.setRequestValidator(function (request) {\n  // Validate next page token.\n  if (typeof request.nextPageToken !== 'undefined' && !validator.isNonEmptyString(request.nextPageToken)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);\n  } // Validate max results.\n\n\n  if (!validator.isNumber(request.maxResults) || request.maxResults <= 0 || request.maxResults > MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"Required \\\"maxResults\\\" must be a positive integer that does not exceed \" + (MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE + \".\"));\n  }\n});\n/** Instantiates the getAccountInfo endpoint settings. */\n\nexports.FIREBASE_AUTH_GET_ACCOUNT_INFO = new api_request_1.ApiSettings('/accounts:lookup', 'POST') // Set request validator.\n.setRequestValidator(function (request) {\n  if (!request.localId && !request.email && !request.phoneNumber) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifier');\n  }\n}) // Set response validator.\n.setResponseValidator(function (response) {\n  if (!response.users) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.USER_NOT_FOUND);\n  }\n});\n/** Instantiates the deleteAccount endpoint settings. */\n\nexports.FIREBASE_AUTH_DELETE_ACCOUNT = new api_request_1.ApiSettings('/accounts:delete', 'POST') // Set request validator.\n.setRequestValidator(function (request) {\n  if (!request.localId) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifier');\n  }\n});\n/** Instantiates the setAccountInfo endpoint settings for updating existing accounts. */\n\nexports.FIREBASE_AUTH_SET_ACCOUNT_INFO = new api_request_1.ApiSettings('/accounts:update', 'POST') // Set request validator.\n.setRequestValidator(function (request) {\n  // localId is a required parameter.\n  if (typeof request.localId === 'undefined') {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifier');\n  } // Throw error when tenantId is passed in POST body.\n\n\n  if (typeof request.tenantId !== 'undefined') {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"tenantId\" is an invalid \"UpdateRequest\" property.');\n  }\n\n  validateCreateEditRequest(request);\n}) // Set response validator.\n.setResponseValidator(function (response) {\n  // If the localId is not returned, then the request failed.\n  if (!response.localId) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.USER_NOT_FOUND);\n  }\n});\n/**\n * Instantiates the signupNewUser endpoint settings for creating a new user with or without\n * uid being specified. The backend will create a new one if not provided and return it.\n */\n\nexports.FIREBASE_AUTH_SIGN_UP_NEW_USER = new api_request_1.ApiSettings('/accounts', 'POST') // Set request validator.\n.setRequestValidator(function (request) {\n  // signupNewUser does not support customAttributes.\n  if (typeof request.customAttributes !== 'undefined') {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"\\\"customAttributes\\\" cannot be set when creating a new user.\");\n  } // signupNewUser does not support validSince.\n\n\n  if (typeof request.validSince !== 'undefined') {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"\\\"validSince\\\" cannot be set when creating a new user.\");\n  } // Throw error when tenantId is passed in POST body.\n\n\n  if (typeof request.tenantId !== 'undefined') {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"tenantId\" is an invalid \"CreateRequest\" property.');\n  }\n\n  validateCreateEditRequest(request);\n}) // Set response validator.\n.setResponseValidator(function (response) {\n  // If the localId is not returned, then the request failed.\n  if (!response.localId) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new user');\n  }\n});\nvar FIREBASE_AUTH_GET_OOB_CODE = new api_request_1.ApiSettings('/accounts:sendOobCode', 'POST') // Set request validator.\n.setRequestValidator(function (request) {\n  if (!validator.isEmail(request.email)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL);\n  }\n\n  if (exports.EMAIL_ACTION_REQUEST_TYPES.indexOf(request.requestType) === -1) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"\\\"\" + request.requestType + \"\\\" is not a supported email action request type.\");\n  }\n}) // Set response validator.\n.setResponseValidator(function (response) {\n  // If the oobLink is not returned, then the request failed.\n  if (!response.oobLink) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create the email action link');\n  }\n});\n/** Instantiates the retrieve OIDC configuration endpoint settings. */\n\nvar GET_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings('/oauthIdpConfigs/{providerId}', 'GET') // Set response validator.\n.setResponseValidator(function (response) {\n  // Response should always contain the OIDC provider resource name.\n  if (!validator.isNonEmptyString(response.name)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to get OIDC configuration');\n  }\n});\n/** Instantiates the delete OIDC configuration endpoint settings. */\n\nvar DELETE_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings('/oauthIdpConfigs/{providerId}', 'DELETE');\n/** Instantiates the create OIDC configuration endpoint settings. */\n\nvar CREATE_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings('/oauthIdpConfigs?oauthIdpConfigId={providerId}', 'POST') // Set response validator.\n.setResponseValidator(function (response) {\n  // Response should always contain the OIDC provider resource name.\n  if (!validator.isNonEmptyString(response.name)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new OIDC configuration');\n  }\n});\n/** Instantiates the update OIDC configuration endpoint settings. */\n\nvar UPDATE_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings('/oauthIdpConfigs/{providerId}?updateMask={updateMask}', 'PATCH') // Set response validator.\n.setResponseValidator(function (response) {\n  // Response should always contain the configuration resource name.\n  if (!validator.isNonEmptyString(response.name)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update OIDC configuration');\n  }\n});\n/** Instantiates the list OIDC configuration endpoint settings. */\n\nvar LIST_OAUTH_IDP_CONFIGS = new api_request_1.ApiSettings('/oauthIdpConfigs', 'GET') // Set request validator.\n.setRequestValidator(function (request) {\n  // Validate next page token.\n  if (typeof request.pageToken !== 'undefined' && !validator.isNonEmptyString(request.pageToken)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);\n  } // Validate max results.\n\n\n  if (!validator.isNumber(request.pageSize) || request.pageSize <= 0 || request.pageSize > MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"Required \\\"maxResults\\\" must be a positive integer that does not exceed \" + (MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE + \".\"));\n  }\n});\n/** Instantiates the retrieve SAML configuration endpoint settings. */\n\nvar GET_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings('/inboundSamlConfigs/{providerId}', 'GET') // Set response validator.\n.setResponseValidator(function (response) {\n  // Response should always contain the SAML provider resource name.\n  if (!validator.isNonEmptyString(response.name)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to get SAML configuration');\n  }\n});\n/** Instantiates the delete SAML configuration endpoint settings. */\n\nvar DELETE_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings('/inboundSamlConfigs/{providerId}', 'DELETE');\n/** Instantiates the create SAML configuration endpoint settings. */\n\nvar CREATE_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings('/inboundSamlConfigs?inboundSamlConfigId={providerId}', 'POST') // Set response validator.\n.setResponseValidator(function (response) {\n  // Response should always contain the SAML provider resource name.\n  if (!validator.isNonEmptyString(response.name)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new SAML configuration');\n  }\n});\n/** Instantiates the update SAML configuration endpoint settings. */\n\nvar UPDATE_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings('/inboundSamlConfigs/{providerId}?updateMask={updateMask}', 'PATCH') // Set response validator.\n.setResponseValidator(function (response) {\n  // Response should always contain the configuration resource name.\n  if (!validator.isNonEmptyString(response.name)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update SAML configuration');\n  }\n});\n/** Instantiates the list SAML configuration endpoint settings. */\n\nvar LIST_INBOUND_SAML_CONFIGS = new api_request_1.ApiSettings('/inboundSamlConfigs', 'GET') // Set request validator.\n.setRequestValidator(function (request) {\n  // Validate next page token.\n  if (typeof request.pageToken !== 'undefined' && !validator.isNonEmptyString(request.pageToken)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);\n  } // Validate max results.\n\n\n  if (!validator.isNumber(request.pageSize) || request.pageSize <= 0 || request.pageSize > MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"Required \\\"maxResults\\\" must be a positive integer that does not exceed \" + (MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE + \".\"));\n  }\n});\n/**\n * Class that provides the mechanism to send requests to the Firebase Auth backend endpoints.\n */\n\nvar AbstractAuthRequestHandler =\n/** @class */\nfunction () {\n  /**\n   * @param {FirebaseApp} app The app used to fetch access tokens to sign API requests.\n   * @constructor\n   */\n  function AbstractAuthRequestHandler(app) {\n    if (typeof app !== 'object' || app === null || !('options' in app)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'First argument passed to admin.auth() must be a valid Firebase app instance.');\n    }\n\n    this.projectId = utils.getProjectId(app);\n    this.httpClient = new api_request_1.AuthorizedHttpClient(app);\n  }\n  /**\n   * @param {any} response The response to check for errors.\n   * @return {string|null} The error code if present; null otherwise.\n   */\n\n\n  AbstractAuthRequestHandler.getErrorCode = function (response) {\n    return validator.isNonNullObject(response) && response.error && response.error.message || null;\n  };\n  /**\n   * Creates a new Firebase session cookie with the specified duration that can be used for\n   * session management (set as a server side session cookie with custom cookie policy).\n   * The session cookie JWT will have the same payload claims as the provided ID token.\n   *\n   * @param {string} idToken The Firebase ID token to exchange for a session cookie.\n   * @param {number} expiresIn The session cookie duration in milliseconds.\n   *\n   * @return {Promise<string>} A promise that resolves on success with the created session cookie.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.createSessionCookie = function (idToken, expiresIn) {\n    var request = {\n      idToken: idToken,\n      // Convert to seconds.\n      validDuration: expiresIn / 1000\n    };\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_CREATE_SESSION_COOKIE, request).then(function (response) {\n      return response.sessionCookie;\n    });\n  };\n  /**\n   * Looks up a user by uid.\n   *\n   * @param {string} uid The uid of the user to lookup.\n   * @return {Promise<object>} A promise that resolves with the user information.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.getAccountInfoByUid = function (uid) {\n    if (!validator.isUid(uid)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));\n    }\n\n    var request = {\n      localId: [uid]\n    };\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request);\n  };\n  /**\n   * Looks up a user by email.\n   *\n   * @param {string} email The email of the user to lookup.\n   * @return {Promise<object>} A promise that resolves with the user information.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.getAccountInfoByEmail = function (email) {\n    if (!validator.isEmail(email)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL));\n    }\n\n    var request = {\n      email: [email]\n    };\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request);\n  };\n  /**\n   * Looks up a user by phone number.\n   *\n   * @param {string} phoneNumber The phone number of the user to lookup.\n   * @return {Promise<object>} A promise that resolves with the user information.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.getAccountInfoByPhoneNumber = function (phoneNumber) {\n    if (!validator.isPhoneNumber(phoneNumber)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHONE_NUMBER));\n    }\n\n    var request = {\n      phoneNumber: [phoneNumber]\n    };\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request);\n  };\n  /**\n   * Exports the users (single batch only) with a size of maxResults and starting from\n   * the offset as specified by pageToken.\n   *\n   * @param {number=} maxResults The page size, 1000 if undefined. This is also the maximum\n   *     allowed limit.\n   * @param {string=} pageToken The next page token. If not specified, returns users starting\n   *     without any offset. Users are returned in the order they were created from oldest to\n   *     newest, relative to the page token offset.\n   * @return {Promise<object>} A promise that resolves with the current batch of downloaded\n   *     users and the next page token if available. For the last page, an empty list of users\n   *     and no page token are returned.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.downloadAccount = function (maxResults, pageToken) {\n    if (maxResults === void 0) {\n      maxResults = MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE;\n    } // Construct request.\n\n\n    var request = {\n      maxResults: maxResults,\n      nextPageToken: pageToken\n    }; // Remove next page token if not provided.\n\n    if (typeof request.nextPageToken === 'undefined') {\n      delete request.nextPageToken;\n    }\n\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_DOWNLOAD_ACCOUNT, request).then(function (response) {\n      // No more users available.\n      if (!response.users) {\n        response.users = [];\n      }\n\n      return response;\n    });\n  };\n  /**\n   * Imports the list of users provided to Firebase Auth. This is useful when\n   * migrating from an external authentication system without having to use the Firebase CLI SDK.\n   * At most, 1000 users are allowed to be imported one at a time.\n   * When importing a list of password users, UserImportOptions are required to be specified.\n   *\n   * @param {UserImportRecord[]} users The list of user records to import to Firebase Auth.\n   * @param {UserImportOptions=} options The user import options, required when the users provided\n   *     include password credentials.\n   * @return {Promise<UserImportResult>} A promise that resolves when the operation completes\n   *     with the result of the import. This includes the number of successful imports, the number\n   *     of failed uploads and their corresponding errors.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.uploadAccount = function (users, options) {\n    // This will throw if any error is detected in the hash options.\n    // For errors in the list of users, this will not throw and will report the errors and the\n    // corresponding user index in the user import generated response below.\n    // No need to validate raw request or raw response as this is done in UserImportBuilder.\n    var userImportBuilder = new user_import_builder_1.UserImportBuilder(users, options, function (userRequest) {\n      // Pass true to validate the uploadAccount specific fields.\n      validateCreateEditRequest(userRequest, true);\n    });\n    var request = userImportBuilder.buildRequest(); // Fail quickly if more users than allowed are to be imported.\n\n    if (validator.isArray(users) && users.length > MAX_UPLOAD_ACCOUNT_BATCH_SIZE) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_USER_COUNT_EXCEEDED, \"A maximum of \" + MAX_UPLOAD_ACCOUNT_BATCH_SIZE + \" users can be imported at once.\");\n    } // If no remaining user in request after client side processing, there is no need\n    // to send the request to the server.\n\n\n    if (request.users.length === 0) {\n      return Promise.resolve(userImportBuilder.buildResponse([]));\n    }\n\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_UPLOAD_ACCOUNT, request).then(function (response) {\n      // No error object is returned if no error encountered.\n      var failedUploads = response.error || []; // Rewrite response as UserImportResult and re-insert client previously detected errors.\n\n      return userImportBuilder.buildResponse(failedUploads);\n    });\n  };\n  /**\n   * Deletes an account identified by a uid.\n   *\n   * @param {string} uid The uid of the user to delete.\n   * @return {Promise<object>} A promise that resolves when the user is deleted.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.deleteAccount = function (uid) {\n    if (!validator.isUid(uid)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));\n    }\n\n    var request = {\n      localId: uid\n    };\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_DELETE_ACCOUNT, request);\n  };\n  /**\n   * Sets additional developer claims on an existing user identified by provided UID.\n   *\n   * @param {string} uid The user to edit.\n   * @param {object} customUserClaims The developer claims to set.\n   * @return {Promise<string>} A promise that resolves when the operation completes\n   *     with the user id that was edited.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.setCustomUserClaims = function (uid, customUserClaims) {\n    // Validate user UID.\n    if (!validator.isUid(uid)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));\n    } else if (!validator.isObject(customUserClaims)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'CustomUserClaims argument must be an object or null.'));\n    } // Delete operation. Replace null with an empty object.\n\n\n    if (customUserClaims === null) {\n      customUserClaims = {};\n    } // Construct custom user attribute editting request.\n\n\n    var request = {\n      localId: uid,\n      customAttributes: JSON.stringify(customUserClaims)\n    };\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SET_ACCOUNT_INFO, request).then(function (response) {\n      return response.localId;\n    });\n  };\n  /**\n   * Edits an existing user.\n   *\n   * @param {string} uid The user to edit.\n   * @param {object} properties The properties to set on the user.\n   * @return {Promise<string>} A promise that resolves when the operation completes\n   *     with the user id that was edited.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.updateExistingAccount = function (uid, properties) {\n    if (!validator.isUid(uid)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));\n    } else if (!validator.isNonNullObject(properties)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Properties argument must be a non-null object.'));\n    } // Build the setAccountInfo request.\n\n\n    var request = deep_copy_1.deepCopy(properties);\n    request.localId = uid; // For deleting displayName or photoURL, these values must be passed as null.\n    // They will be removed from the backend request and an additional parameter\n    // deleteAttribute: ['PHOTO_URL', 'DISPLAY_NAME']\n    // with an array of the parameter names to delete will be passed.\n    // Parameters that are deletable and their deleteAttribute names.\n    // Use client facing names, photoURL instead of photoUrl.\n\n    var deletableParams = {\n      displayName: 'DISPLAY_NAME',\n      photoURL: 'PHOTO_URL'\n    }; // Properties to delete if available.\n\n    request.deleteAttribute = [];\n\n    for (var key in deletableParams) {\n      if (request[key] === null) {\n        // Add property identifier to list of attributes to delete.\n        request.deleteAttribute.push(deletableParams[key]); // Remove property from request.\n\n        delete request[key];\n      }\n    }\n\n    if (request.deleteAttribute.length === 0) {\n      delete request.deleteAttribute;\n    } // For deleting phoneNumber, this value must be passed as null.\n    // It will be removed from the backend request and an additional parameter\n    // deleteProvider: ['phone'] with an array of providerIds (phone in this case),\n    // will be passed.\n    // Currently this applies to phone provider only.\n\n\n    if (request.phoneNumber === null) {\n      request.deleteProvider = ['phone'];\n      delete request.phoneNumber;\n    } else {\n      // Doesn't apply to other providers in admin SDK.\n      delete request.deleteProvider;\n    } // Rewrite photoURL to photoUrl.\n\n\n    if (typeof request.photoURL !== 'undefined') {\n      request.photoUrl = request.photoURL;\n      delete request.photoURL;\n    } // Rewrite disabled to disableUser.\n\n\n    if (typeof request.disabled !== 'undefined') {\n      request.disableUser = request.disabled;\n      delete request.disabled;\n    }\n\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SET_ACCOUNT_INFO, request).then(function (response) {\n      return response.localId;\n    });\n  };\n  /**\n   * Revokes all refresh tokens for the specified user identified by the uid provided.\n   * In addition to revoking all refresh tokens for a user, all ID tokens issued\n   * before revocation will also be revoked on the Auth backend. Any request with an\n   * ID token generated before revocation will be rejected with a token expired error.\n   * Note that due to the fact that the timestamp is stored in seconds, any tokens minted in\n   * the same second as the revocation will still be valid. If there is a chance that a token\n   * was minted in the last second, delay for 1 second before revoking.\n   *\n   * @param {string} uid The user whose tokens are to be revoked.\n   * @return {Promise<string>} A promise that resolves when the operation completes\n   *     successfully with the user id of the corresponding user.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.revokeRefreshTokens = function (uid) {\n    // Validate user UID.\n    if (!validator.isUid(uid)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));\n    }\n\n    var request = {\n      localId: uid,\n      // validSince is in UTC seconds.\n      validSince: Math.ceil(new Date().getTime() / 1000)\n    };\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SET_ACCOUNT_INFO, request).then(function (response) {\n      return response.localId;\n    });\n  };\n  /**\n   * Create a new user with the properties supplied.\n   *\n   * @param {object} properties The properties to set on the user.\n   * @return {Promise<string>} A promise that resolves when the operation completes\n   *     with the user id that was created.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.createNewAccount = function (properties) {\n    if (!validator.isNonNullObject(properties)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Properties argument must be a non-null object.'));\n    } // Build the signupNewUser request.\n\n\n    var request = deep_copy_1.deepCopy(properties); // Rewrite photoURL to photoUrl.\n\n    if (typeof request.photoURL !== 'undefined') {\n      request.photoUrl = request.photoURL;\n      delete request.photoURL;\n    } // Rewrite uid to localId if it exists.\n\n\n    if (typeof request.uid !== 'undefined') {\n      request.localId = request.uid;\n      delete request.uid;\n    }\n\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SIGN_UP_NEW_USER, request).then(function (response) {\n      // Return the user id.\n      return response.localId;\n    });\n  };\n  /**\n   * Generates the out of band email action link for the email specified using the action code settings provided.\n   * Returns a promise that resolves with the generated link.\n   *\n   * @param {string} requestType The request type. This could be either used for password reset,\n   *     email verification, email link sign-in.\n   * @param {string} email The email of the user the link is being sent to.\n   * @param {ActionCodeSettings=} actionCodeSettings The optional action code setings which defines whether\n   *     the link is to be handled by a mobile app and the additional state information to be passed in the\n   *     deep link, etc.\n   * @return {Promise<string>} A promise that resolves with the email action link.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.getEmailActionLink = function (requestType, email, actionCodeSettings) {\n    var request = {\n      requestType: requestType,\n      email: email,\n      returnOobLink: true\n    }; // ActionCodeSettings required for email link sign-in to determine the url where the sign-in will\n    // be completed.\n\n    if (typeof actionCodeSettings !== 'undefined' || requestType === 'EMAIL_SIGNIN') {\n      try {\n        var builder = new action_code_settings_builder_1.ActionCodeSettingsBuilder(actionCodeSettings);\n        request = deep_copy_1.deepExtend(request, builder.buildRequest());\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }\n\n    return this.invokeRequestHandler(this.getAuthUrlBuilder(), FIREBASE_AUTH_GET_OOB_CODE, request).then(function (response) {\n      // Return the link.\n      return response.oobLink;\n    });\n  };\n  /**\n   * Looks up an OIDC provider configuration by provider ID.\n   *\n   * @param {string} providerId The provider identifier of the configuration to lookup.\n   * @return {Promise<OIDCConfigServerResponse>} A promise that resolves with the provider configuration information.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.getOAuthIdpConfig = function (providerId) {\n    if (!auth_config_1.OIDCConfig.isProviderId(providerId)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n    }\n\n    return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), GET_OAUTH_IDP_CONFIG, {}, {\n      providerId: providerId\n    });\n  };\n  /**\n   * Lists the OIDC configurations (single batch only) with a size of maxResults and starting from\n   * the offset as specified by pageToken.\n   *\n   * @param {number=} maxResults The page size, 100 if undefined. This is also the maximum\n   *     allowed limit.\n   * @param {string=} pageToken The next page token. If not specified, returns OIDC configurations\n   *     without any offset. Configurations are returned in the order they were created from oldest to\n   *     newest, relative to the page token offset.\n   * @return {Promise<object>} A promise that resolves with the current batch of downloaded\n   *     OIDC configurations and the next page token if available. For the last page, an empty list of provider\n   *     configuration and no page token are returned.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.listOAuthIdpConfigs = function (maxResults, pageToken) {\n    if (maxResults === void 0) {\n      maxResults = MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE;\n    }\n\n    var request = {\n      pageSize: maxResults\n    }; // Add next page token if provided.\n\n    if (typeof pageToken !== 'undefined') {\n      request.pageToken = pageToken;\n    }\n\n    return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), LIST_OAUTH_IDP_CONFIGS, request).then(function (response) {\n      if (!response.oauthIdpConfigs) {\n        response.oauthIdpConfigs = [];\n        delete response.nextPageToken;\n      }\n\n      return response;\n    });\n  };\n  /**\n   * Deletes an OIDC configuration identified by a providerId.\n   *\n   * @param {string} providerId The identifier of the OIDC configuration to delete.\n   * @return {Promise<void>} A promise that resolves when the OIDC provider is deleted.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.deleteOAuthIdpConfig = function (providerId) {\n    if (!auth_config_1.OIDCConfig.isProviderId(providerId)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n    }\n\n    return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), DELETE_OAUTH_IDP_CONFIG, {}, {\n      providerId: providerId\n    }).then(function (response) {// Return nothing.\n    });\n  };\n  /**\n   * Creates a new OIDC provider configuration with the properties provided.\n   *\n   * @param {AuthProviderConfig} options The properties to set on the new OIDC provider configuration to be created.\n   * @return {Promise<OIDCConfigServerResponse>} A promise that resolves with the newly created OIDC\n   *     configuration.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.createOAuthIdpConfig = function (options) {\n    // Construct backend request.\n    var request;\n\n    try {\n      request = auth_config_1.OIDCConfig.buildServerRequest(options);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n\n    var providerId = options.providerId;\n    return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), CREATE_OAUTH_IDP_CONFIG, request, {\n      providerId: providerId\n    }).then(function (response) {\n      if (!auth_config_1.OIDCConfig.getProviderIdFromResourceName(response.name)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new OIDC provider configuration');\n      }\n\n      return response;\n    });\n  };\n  /**\n   * Updates an existing OIDC provider configuration with the properties provided.\n   *\n   * @param {string} providerId The provider identifier of the OIDC configuration to update.\n   * @param {OIDCUpdateAuthProviderRequest} options The properties to update on the existing configuration.\n   * @return {Promise<OIDCConfigServerResponse>} A promise that resolves with the modified provider\n   *     configuration.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.updateOAuthIdpConfig = function (providerId, options) {\n    if (!auth_config_1.OIDCConfig.isProviderId(providerId)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n    } // Construct backend request.\n\n\n    var request;\n\n    try {\n      request = auth_config_1.OIDCConfig.buildServerRequest(options, true) || {};\n    } catch (e) {\n      return Promise.reject(e);\n    }\n\n    var updateMask = utils.generateUpdateMask(request);\n    return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), UPDATE_OAUTH_IDP_CONFIG, request, {\n      providerId: providerId,\n      updateMask: updateMask.join(',')\n    }).then(function (response) {\n      if (!auth_config_1.OIDCConfig.getProviderIdFromResourceName(response.name)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update OIDC provider configuration');\n      }\n\n      return response;\n    });\n  };\n  /**\n   * Looks up an SAML provider configuration by provider ID.\n   *\n   * @param {string} providerId The provider identifier of the configuration to lookup.\n   * @return {Promise<SAMLConfigServerResponse>} A promise that resolves with the provider configuration information.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.getInboundSamlConfig = function (providerId) {\n    if (!auth_config_1.SAMLConfig.isProviderId(providerId)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n    }\n\n    return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), GET_INBOUND_SAML_CONFIG, {}, {\n      providerId: providerId\n    });\n  };\n  /**\n   * Lists the SAML configurations (single batch only) with a size of maxResults and starting from\n   * the offset as specified by pageToken.\n   *\n   * @param {number=} maxResults The page size, 100 if undefined. This is also the maximum\n   *     allowed limit.\n   * @param {string=} pageToken The next page token. If not specified, returns SAML configurations starting\n   *     without any offset. Configurations are returned in the order they were created from oldest to\n   *     newest, relative to the page token offset.\n   * @return {Promise<object>} A promise that resolves with the current batch of downloaded\n   *     SAML configurations and the next page token if available. For the last page, an empty list of provider\n   *     configuration and no page token are returned.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.listInboundSamlConfigs = function (maxResults, pageToken) {\n    if (maxResults === void 0) {\n      maxResults = MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE;\n    }\n\n    var request = {\n      pageSize: maxResults\n    }; // Add next page token if provided.\n\n    if (typeof pageToken !== 'undefined') {\n      request.pageToken = pageToken;\n    }\n\n    return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), LIST_INBOUND_SAML_CONFIGS, request).then(function (response) {\n      if (!response.inboundSamlConfigs) {\n        response.inboundSamlConfigs = [];\n        delete response.nextPageToken;\n      }\n\n      return response;\n    });\n  };\n  /**\n   * Deletes a SAML configuration identified by a providerId.\n   *\n   * @param {string} providerId The identifier of the SAML configuration to delete.\n   * @return {Promise<void>} A promise that resolves when the SAML provider is deleted.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.deleteInboundSamlConfig = function (providerId) {\n    if (!auth_config_1.SAMLConfig.isProviderId(providerId)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n    }\n\n    return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), DELETE_INBOUND_SAML_CONFIG, {}, {\n      providerId: providerId\n    }).then(function (response) {// Return nothing.\n    });\n  };\n  /**\n   * Creates a new SAML provider configuration with the properties provided.\n   *\n   * @param {AuthProviderConfig} options The properties to set on the new SAML provider configuration to be created.\n   * @return {Promise<SAMLConfigServerResponse>} A promise that resolves with the newly created SAML\n   *     configuration.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.createInboundSamlConfig = function (options) {\n    // Construct backend request.\n    var request;\n\n    try {\n      request = auth_config_1.SAMLConfig.buildServerRequest(options);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n\n    var providerId = options.providerId;\n    return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), CREATE_INBOUND_SAML_CONFIG, request, {\n      providerId: providerId\n    }).then(function (response) {\n      if (!auth_config_1.SAMLConfig.getProviderIdFromResourceName(response.name)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new SAML provider configuration');\n      }\n\n      return response;\n    });\n  };\n  /**\n   * Updates an existing SAML provider configuration with the properties provided.\n   *\n   * @param {string} providerId The provider identifier of the SAML configuration to update.\n   * @param {SAMLUpdateAuthProviderRequest} options The properties to update on the existing configuration.\n   * @return {Promise<SAMLConfigServerResponse>} A promise that resolves with the modified provider\n   *     configuration.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.updateInboundSamlConfig = function (providerId, options) {\n    if (!auth_config_1.SAMLConfig.isProviderId(providerId)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n    } // Construct backend request.\n\n\n    var request;\n\n    try {\n      request = auth_config_1.SAMLConfig.buildServerRequest(options, true);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n\n    var updateMask = utils.generateUpdateMask(request);\n    return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), UPDATE_INBOUND_SAML_CONFIG, request, {\n      providerId: providerId,\n      updateMask: updateMask.join(',')\n    }).then(function (response) {\n      if (!auth_config_1.SAMLConfig.getProviderIdFromResourceName(response.name)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update SAML provider configuration');\n      }\n\n      return response;\n    });\n  };\n  /**\n   * Invokes the request handler based on the API settings object passed.\n   *\n   * @param {AuthResourceUrlBuilder} urlBuilder The URL builder for Auth endpoints.\n   * @param {ApiSettings} apiSettings The API endpoint settings to apply to request and response.\n   * @param {object} requestData The request data.\n   * @param {object=} additionalResourceParams Additional resource related params if needed.\n   * @return {Promise<object>} A promise that resolves with the response.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.invokeRequestHandler = function (urlBuilder, apiSettings, requestData, additionalResourceParams) {\n    var _this = this;\n\n    return Promise.resolve().then(function () {\n      // Validate request.\n      var requestValidator = apiSettings.getRequestValidator();\n      requestValidator(requestData); // Process request.\n\n      var req = {\n        method: apiSettings.getHttpMethod(),\n        url: urlBuilder.getUrl(apiSettings.getEndpoint(), additionalResourceParams),\n        headers: FIREBASE_AUTH_HEADER,\n        data: requestData,\n        timeout: FIREBASE_AUTH_TIMEOUT\n      };\n      return _this.httpClient.send(req);\n    }).then(function (response) {\n      // Validate response.\n      var responseValidator = apiSettings.getResponseValidator();\n      responseValidator(response.data); // Return entire response.\n\n      return response.data;\n    }).catch(function (err) {\n      if (err instanceof api_request_1.HttpError) {\n        var error = err.response.data;\n        var errorCode = AbstractAuthRequestHandler.getErrorCode(error);\n        throw error_1.FirebaseAuthError.fromServerError(errorCode,\n        /* message */\n        undefined, error);\n      }\n\n      throw err;\n    });\n  };\n  /**\n   * @return {AuthResourceUrlBuilder} The current Auth user management resource URL builder.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.getAuthUrlBuilder = function () {\n    if (!this.authUrlBuilder) {\n      this.authUrlBuilder = this.newAuthUrlBuilder();\n    }\n\n    return this.authUrlBuilder;\n  };\n  /**\n   * @return {AuthResourceUrlBuilder} The current project config resource URL builder.\n   */\n\n\n  AbstractAuthRequestHandler.prototype.getProjectConfigUrlBuilder = function () {\n    if (!this.projectConfigUrlBuilder) {\n      this.projectConfigUrlBuilder = this.newProjectConfigUrlBuilder();\n    }\n\n    return this.projectConfigUrlBuilder;\n  };\n\n  return AbstractAuthRequestHandler;\n}();\n\nexports.AbstractAuthRequestHandler = AbstractAuthRequestHandler;\n/** Instantiates the getTenant endpoint settings. */\n\nvar GET_TENANT = new api_request_1.ApiSettings('/tenants/{tenantId}', 'GET') // Set response validator.\n.setResponseValidator(function (response) {\n  // Response should always contain at least the tenant name.\n  if (!validator.isNonEmptyString(response.name)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to get tenant');\n  }\n});\n/** Instantiates the deleteTenant endpoint settings. */\n\nvar DELETE_TENANT = new api_request_1.ApiSettings('/tenants/{tenantId}', 'DELETE');\n/** Instantiates the updateTenant endpoint settings. */\n\nvar UPDATE_TENANT = new api_request_1.ApiSettings('/tenants/{tenantId}?updateMask={updateMask}', 'PATCH') // Set response validator.\n.setResponseValidator(function (response) {\n  // Response should always contain at least the tenant name.\n  if (!validator.isNonEmptyString(response.name) || !tenant_1.Tenant.getTenantIdFromResourceName(response.name)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update tenant');\n  }\n});\n/** Instantiates the listTenants endpoint settings. */\n\nvar LIST_TENANTS = new api_request_1.ApiSettings('/tenants', 'GET') // Set request validator.\n.setRequestValidator(function (request) {\n  // Validate next page token.\n  if (typeof request.pageToken !== 'undefined' && !validator.isNonEmptyString(request.pageToken)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);\n  } // Validate max results.\n\n\n  if (!validator.isNumber(request.pageSize) || request.pageSize <= 0 || request.pageSize > MAX_LIST_TENANT_PAGE_SIZE) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"Required \\\"maxResults\\\" must be a positive non-zero number that does not exceed \" + (\"the allowed \" + MAX_LIST_TENANT_PAGE_SIZE + \".\"));\n  }\n});\n/** Instantiates the createTenant endpoint settings. */\n\nvar CREATE_TENANT = new api_request_1.ApiSettings('/tenants', 'POST') // Set response validator.\n.setResponseValidator(function (response) {\n  // Response should always contain at least the tenant name.\n  if (!validator.isNonEmptyString(response.name) || !tenant_1.Tenant.getTenantIdFromResourceName(response.name)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new tenant');\n  }\n});\n/**\n * Utility for sending requests to Auth server that are Auth instance related. This includes user and\n * tenant management related APIs. This extends the BaseFirebaseAuthRequestHandler class and defines\n * additional tenant management related APIs.\n */\n\nvar AuthRequestHandler =\n/** @class */\nfunction (_super) {\n  __extends(AuthRequestHandler, _super);\n  /**\n   * The FirebaseAuthRequestHandler constructor used to initialize an instance using a FirebaseApp.\n   *\n   * @param {FirebaseApp} app The app used to fetch access tokens to sign API requests.\n   * @constructor.\n   */\n\n\n  function AuthRequestHandler(app) {\n    var _this = _super.call(this, app) || this;\n\n    _this.tenantMgmtResourceBuilder = new AuthResourceUrlBuilder(utils.getProjectId(app), 'v2beta1');\n    return _this;\n  }\n  /**\n   * @return {AuthResourceUrlBuilder} A new Auth user management resource URL builder instance.\n   */\n\n\n  AuthRequestHandler.prototype.newAuthUrlBuilder = function () {\n    return new AuthResourceUrlBuilder(this.projectId, 'v1');\n  };\n  /**\n   * @return {AuthResourceUrlBuilder} A new project config resource URL builder instance.\n   */\n\n\n  AuthRequestHandler.prototype.newProjectConfigUrlBuilder = function () {\n    return new AuthResourceUrlBuilder(this.projectId, 'v2beta1');\n  };\n  /**\n   * Looks up a tenant by tenant ID.\n   *\n   * @param {string} tenantId The tenant identifier of the tenant to lookup.\n   * @return {Promise<TenantServerResponse>} A promise that resolves with the tenant information.\n   */\n\n\n  AuthRequestHandler.prototype.getTenant = function (tenantId) {\n    if (!validator.isNonEmptyString(tenantId)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID));\n    }\n\n    return this.invokeRequestHandler(this.tenantMgmtResourceBuilder, GET_TENANT, {}, {\n      tenantId: tenantId\n    }).then(function (response) {\n      return response;\n    });\n  };\n  /**\n   * Exports the tenants (single batch only) with a size of maxResults and starting from\n   * the offset as specified by pageToken.\n   *\n   * @param {number=} maxResults The page size, 1000 if undefined. This is also the maximum\n   *     allowed limit.\n   * @param {string=} pageToken The next page token. If not specified, returns tenants starting\n   *     without any offset. Tenants are returned in the order they were created from oldest to\n   *     newest, relative to the page token offset.\n   * @return {Promise<object>} A promise that resolves with the current batch of downloaded\n   *     tenants and the next page token if available. For the last page, an empty list of tenants\n   *     and no page token are returned.\n   */\n\n\n  AuthRequestHandler.prototype.listTenants = function (maxResults, pageToken) {\n    if (maxResults === void 0) {\n      maxResults = MAX_LIST_TENANT_PAGE_SIZE;\n    }\n\n    var request = {\n      pageSize: maxResults,\n      pageToken: pageToken\n    }; // Remove next page token if not provided.\n\n    if (typeof request.pageToken === 'undefined') {\n      delete request.pageToken;\n    }\n\n    return this.invokeRequestHandler(this.tenantMgmtResourceBuilder, LIST_TENANTS, request).then(function (response) {\n      if (!response.tenants) {\n        response.tenants = [];\n        delete response.nextPageToken;\n      }\n\n      return response;\n    });\n  };\n  /**\n   * Deletes a tenant identified by a tenantId.\n   *\n   * @param {string} tenantId The identifier of the tenant to delete.\n   * @return {Promise<void>} A promise that resolves when the tenant is deleted.\n   */\n\n\n  AuthRequestHandler.prototype.deleteTenant = function (tenantId) {\n    if (!validator.isNonEmptyString(tenantId)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID));\n    }\n\n    return this.invokeRequestHandler(this.tenantMgmtResourceBuilder, DELETE_TENANT, {}, {\n      tenantId: tenantId\n    }).then(function (response) {// Return nothing.\n    });\n  };\n  /**\n   * Creates a new tenant with the properties provided.\n   *\n   * @param {TenantOptions} tenantOptions The properties to set on the new tenant to be created.\n   * @return {Promise<TenantServerResponse>} A promise that resolves with the newly created tenant object.\n   */\n\n\n  AuthRequestHandler.prototype.createTenant = function (tenantOptions) {\n    try {\n      // Construct backend request.\n      var request = tenant_1.Tenant.buildServerRequest(tenantOptions, true);\n      return this.invokeRequestHandler(this.tenantMgmtResourceBuilder, CREATE_TENANT, request).then(function (response) {\n        return response;\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n  /**\n   * Updates an existing tenant with the properties provided.\n   *\n   * @param {string} tenantId The tenant identifier of the tenant to update.\n   * @param {TenantOptions} tenantOptions The properties to update on the existing tenant.\n   * @return {Promise<TenantServerResponse>} A promise that resolves with the modified tenant object.\n   */\n\n\n  AuthRequestHandler.prototype.updateTenant = function (tenantId, tenantOptions) {\n    if (!validator.isNonEmptyString(tenantId)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID));\n    }\n\n    try {\n      // Construct backend request.\n      var request = tenant_1.Tenant.buildServerRequest(tenantOptions, false);\n      var updateMask = utils.generateUpdateMask(request);\n      return this.invokeRequestHandler(this.tenantMgmtResourceBuilder, UPDATE_TENANT, request, {\n        tenantId: tenantId,\n        updateMask: updateMask.join(',')\n      }).then(function (response) {\n        return response;\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  return AuthRequestHandler;\n}(AbstractAuthRequestHandler);\n\nexports.AuthRequestHandler = AuthRequestHandler;\n/**\n * Utility for sending requests to Auth server that are tenant Auth instance related. This includes user\n * management related APIs for specified tenants.\n * This extends the BaseFirebaseAuthRequestHandler class.\n */\n\nvar TenantAwareAuthRequestHandler =\n/** @class */\nfunction (_super) {\n  __extends(TenantAwareAuthRequestHandler, _super);\n  /**\n   * The FirebaseTenantRequestHandler constructor used to initialize an instance using a\n   * FirebaseApp and a tenant ID.\n   *\n   * @param {FirebaseApp} app The app used to fetch access tokens to sign API requests.\n   * @param {string} tenantId The request handler's tenant ID.\n   * @constructor\n   */\n\n\n  function TenantAwareAuthRequestHandler(app, tenantId) {\n    var _this = _super.call(this, app) || this;\n\n    _this.tenantId = tenantId;\n    return _this;\n  }\n  /**\n   * @return {AuthResourceUrlBuilder} A new Auth user management resource URL builder instance.\n   */\n\n\n  TenantAwareAuthRequestHandler.prototype.newAuthUrlBuilder = function () {\n    return new TenantAwareAuthResourceUrlBuilder(this.projectId, 'v1', this.tenantId);\n  };\n  /**\n   * @return {AuthResourceUrlBuilder} A new project config resource URL builder instance.\n   */\n\n\n  TenantAwareAuthRequestHandler.prototype.newProjectConfigUrlBuilder = function () {\n    return new TenantAwareAuthResourceUrlBuilder(this.projectId, 'v2beta1', this.tenantId);\n  };\n  /**\n   * Imports the list of users provided to Firebase Auth. This is useful when\n   * migrating from an external authentication system without having to use the Firebase CLI SDK.\n   * At most, 1000 users are allowed to be imported one at a time.\n   * When importing a list of password users, UserImportOptions are required to be specified.\n   *\n   * Overrides the superclass methods by adding an additional check to match tenant IDs of\n   * imported user records if present.\n   *\n   * @param {UserImportRecord[]} users The list of user records to import to Firebase Auth.\n   * @param {UserImportOptions=} options The user import options, required when the users provided\n   *     include password credentials.\n   * @return {Promise<UserImportResult>} A promise that resolves when the operation completes\n   *     with the result of the import. This includes the number of successful imports, the number\n   *     of failed uploads and their corresponding errors.\n   */\n\n\n  TenantAwareAuthRequestHandler.prototype.uploadAccount = function (users, options) {\n    var _this = this; // Add additional check to match tenant ID of imported user records.\n\n\n    users.forEach(function (user, index) {\n      if (validator.isNonEmptyString(user.tenantId) && user.tenantId !== _this.tenantId) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISMATCHING_TENANT_ID, \"UserRecord of index \\\"\" + index + \"\\\" has mismatching tenant ID \\\"\" + user.tenantId + \"\\\"\");\n      }\n    });\n    return _super.prototype.uploadAccount.call(this, users, options);\n  };\n\n  return TenantAwareAuthRequestHandler;\n}(AbstractAuthRequestHandler);\n\nexports.TenantAwareAuthRequestHandler = TenantAwareAuthRequestHandler;","map":{"version":3,"sources":["/home/strider/Desktop/github/klaviyo-weather-powered-email/frontend/node_modules/firebase-admin/lib/auth/auth-api-request.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","defineProperty","exports","value","validator","require","deep_copy_1","error_1","api_request_1","user_import_builder_1","utils","action_code_settings_builder_1","auth_config_1","tenant_1","FIREBASE_AUTH_HEADER","FIREBASE_AUTH_TIMEOUT","RESERVED_CLAIMS","EMAIL_ACTION_REQUEST_TYPES","MAX_CLAIMS_PAYLOAD_SIZE","MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE","MAX_UPLOAD_ACCOUNT_BATCH_SIZE","MIN_SESSION_COOKIE_DURATION_SECS","MAX_SESSION_COOKIE_DURATION_SECS","MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE","FIREBASE_AUTH_BASE_URL_FORMAT","FIREBASE_AUTH_TENANT_URL_FORMAT","replace","MAX_LIST_TENANT_PAGE_SIZE","AuthResourceUrlBuilder","projectId","version","urlFormat","getUrl","api","params","baseParams","baseUrl","formatString","TenantAwareAuthResourceUrlBuilder","_super","tenantId","_this","call","validateProviderUserInfo","request","validKeys","rawId","providerId","email","displayName","photoUrl","key","isNonEmptyString","FirebaseAuthError","AuthClientErrorCode","INVALID_PROVIDER_ID","INVALID_DISPLAY_NAME","INVALID_UID","isEmail","INVALID_EMAIL","isURL","INVALID_PHOTO_URL","validateCreateEditRequest","uploadAccountRequest","localId","password","rawPassword","emailVerified","disabled","disableUser","deleteAttribute","deleteProvider","sanityCheck","phoneNumber","customAttributes","validSince","passwordHash","salt","createdAt","lastLoginAt","providerUserInfo","INVALID_TENANT_ID","isString","isUid","isPhoneNumber","INVALID_PHONE_NUMBER","isPassword","INVALID_PASSWORD","INVALID_EMAIL_VERIFIED","INVALID_DISABLED_FIELD","isNumber","INVALID_TOKENS_VALID_AFTER_TIME","INVALID_CREATION_TIME","INVALID_LAST_SIGN_IN_TIME","developerClaims_1","JSON","parse","error","INVALID_CLAIMS","message","invalidClaims_1","forEach","blacklistedClaim","push","length","FORBIDDEN_CLAIM","join","CLAIMS_TOO_LARGE","INVALID_PASSWORD_HASH","INVALID_PASSWORD_SALT","isArray","INVALID_PROVIDER_DATA","providerUserInfoEntry","FIREBASE_AUTH_CREATE_SESSION_COOKIE","ApiSettings","setRequestValidator","idToken","INVALID_ID_TOKEN","validDuration","INVALID_SESSION_COOKIE_DURATION","setResponseValidator","response","sessionCookie","INTERNAL_ERROR","FIREBASE_AUTH_UPLOAD_ACCOUNT","FIREBASE_AUTH_DOWNLOAD_ACCOUNT","nextPageToken","INVALID_PAGE_TOKEN","maxResults","INVALID_ARGUMENT","FIREBASE_AUTH_GET_ACCOUNT_INFO","users","USER_NOT_FOUND","FIREBASE_AUTH_DELETE_ACCOUNT","FIREBASE_AUTH_SET_ACCOUNT_INFO","FIREBASE_AUTH_SIGN_UP_NEW_USER","FIREBASE_AUTH_GET_OOB_CODE","indexOf","requestType","oobLink","GET_OAUTH_IDP_CONFIG","name","DELETE_OAUTH_IDP_CONFIG","CREATE_OAUTH_IDP_CONFIG","UPDATE_OAUTH_IDP_CONFIG","LIST_OAUTH_IDP_CONFIGS","pageToken","pageSize","GET_INBOUND_SAML_CONFIG","DELETE_INBOUND_SAML_CONFIG","CREATE_INBOUND_SAML_CONFIG","UPDATE_INBOUND_SAML_CONFIG","LIST_INBOUND_SAML_CONFIGS","AbstractAuthRequestHandler","app","getProjectId","httpClient","AuthorizedHttpClient","getErrorCode","isNonNullObject","createSessionCookie","expiresIn","invokeRequestHandler","getAuthUrlBuilder","then","getAccountInfoByUid","uid","Promise","reject","getAccountInfoByEmail","getAccountInfoByPhoneNumber","downloadAccount","uploadAccount","options","userImportBuilder","UserImportBuilder","userRequest","buildRequest","MAXIMUM_USER_COUNT_EXCEEDED","resolve","buildResponse","failedUploads","deleteAccount","setCustomUserClaims","customUserClaims","isObject","stringify","updateExistingAccount","properties","deepCopy","deletableParams","photoURL","revokeRefreshTokens","Math","ceil","Date","getTime","createNewAccount","getEmailActionLink","actionCodeSettings","returnOobLink","builder","ActionCodeSettingsBuilder","deepExtend","e","getOAuthIdpConfig","OIDCConfig","isProviderId","getProjectConfigUrlBuilder","listOAuthIdpConfigs","oauthIdpConfigs","deleteOAuthIdpConfig","createOAuthIdpConfig","buildServerRequest","getProviderIdFromResourceName","updateOAuthIdpConfig","updateMask","generateUpdateMask","getInboundSamlConfig","SAMLConfig","listInboundSamlConfigs","inboundSamlConfigs","deleteInboundSamlConfig","createInboundSamlConfig","updateInboundSamlConfig","urlBuilder","apiSettings","requestData","additionalResourceParams","requestValidator","getRequestValidator","req","method","getHttpMethod","url","getEndpoint","headers","data","timeout","send","responseValidator","getResponseValidator","catch","err","HttpError","errorCode","fromServerError","undefined","authUrlBuilder","newAuthUrlBuilder","projectConfigUrlBuilder","newProjectConfigUrlBuilder","GET_TENANT","DELETE_TENANT","UPDATE_TENANT","Tenant","getTenantIdFromResourceName","LIST_TENANTS","CREATE_TENANT","AuthRequestHandler","tenantMgmtResourceBuilder","getTenant","listTenants","tenants","deleteTenant","createTenant","tenantOptions","updateTenant","TenantAwareAuthRequestHandler","user","index","MISMATCHING_TENANT_ID"],"mappings":"AAAA;AACA;AACA;;;;;;;;;;;;;;;;AAeA,IAAIA,SAAS,GAAI,QAAQ,KAAKA,SAAd,IAA6B,YAAY;AACrD,MAAIC,aAAa,GAAG,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AAChCF,IAAAA,aAAa,GAAGG,MAAM,CAACC,cAAP,IACX;AAAEC,MAAAA,SAAS,EAAE;AAAb,iBAA6BC,KAA7B,IAAsC,UAAUL,CAAV,EAAaC,CAAb,EAAgB;AAAED,MAAAA,CAAC,CAACI,SAAF,GAAcH,CAAd;AAAkB,KAD/D,IAEZ,UAAUD,CAAV,EAAaC,CAAb,EAAgB;AAAE,WAAK,IAAIK,CAAT,IAAcL,CAAd,EAAiB,IAAIA,CAAC,CAACM,cAAF,CAAiBD,CAAjB,CAAJ,EAAyBN,CAAC,CAACM,CAAD,CAAD,GAAOL,CAAC,CAACK,CAAD,CAAR;AAAc,KAF9E;;AAGA,WAAOP,aAAa,CAACC,CAAD,EAAIC,CAAJ,CAApB;AACH,GALD;;AAMA,SAAO,UAAUD,CAAV,EAAaC,CAAb,EAAgB;AACnBF,IAAAA,aAAa,CAACC,CAAD,EAAIC,CAAJ,CAAb;;AACA,aAASO,EAAT,GAAc;AAAE,WAAKC,WAAL,GAAmBT,CAAnB;AAAuB;;AACvCA,IAAAA,CAAC,CAACU,SAAF,GAAcT,CAAC,KAAK,IAAN,GAAaC,MAAM,CAACS,MAAP,CAAcV,CAAd,CAAb,IAAiCO,EAAE,CAACE,SAAH,GAAeT,CAAC,CAACS,SAAjB,EAA4B,IAAIF,EAAJ,EAA7D,CAAd;AACH,GAJD;AAKH,CAZ2C,EAA5C;;AAaAN,MAAM,CAACU,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,IAAIC,SAAS,GAAGC,OAAO,CAAC,oBAAD,CAAvB;;AACA,IAAIC,WAAW,GAAGD,OAAO,CAAC,oBAAD,CAAzB;;AACA,IAAIE,OAAO,GAAGF,OAAO,CAAC,gBAAD,CAArB;;AACA,IAAIG,aAAa,GAAGH,OAAO,CAAC,sBAAD,CAA3B;;AACA,IAAII,qBAAqB,GAAGJ,OAAO,CAAC,uBAAD,CAAnC;;AACA,IAAIK,KAAK,GAAGL,OAAO,CAAC,gBAAD,CAAnB;;AACA,IAAIM,8BAA8B,GAAGN,OAAO,CAAC,gCAAD,CAA5C;;AACA,IAAIO,aAAa,GAAGP,OAAO,CAAC,eAAD,CAA3B;;AACA,IAAIQ,QAAQ,GAAGR,OAAO,CAAC,UAAD,CAAtB;AACA;;;AACA,IAAIS,oBAAoB,GAAG;AACvB,sBAAoB;AADG,CAA3B;AAGA;;AACA,IAAIC,qBAAqB,GAAG,KAA5B;AACA;;AACAb,OAAO,CAACc,eAAR,GAA0B,CACtB,KADsB,EACf,KADe,EACR,SADQ,EACG,KADH,EACU,WADV,EACuB,KADvB,EAC8B,KAD9B,EACqC,QADrC,EAC+C,KAD/C,EACsD,KADtD,EAEtB,KAFsB,EAEf,KAFe,EAER,KAFQ,EAED,OAFC,EAEQ,KAFR,EAEe,UAFf,CAA1B;AAIA;;AACAd,OAAO,CAACe,0BAAR,GAAqC,CACjC,gBADiC,EACf,cADe,EACC,cADD,CAArC;AAGA;;AACA,IAAIC,uBAAuB,GAAG,IAA9B;AACA;;AACA,IAAIC,8BAA8B,GAAG,IAArC;AACA;;AACA,IAAIC,6BAA6B,GAAG,IAApC;AACA;;AACA,IAAIC,gCAAgC,GAAG,IAAI,EAA3C;AACA;;AACA,IAAIC,gCAAgC,GAAG,KAAK,EAAL,GAAU,EAAV,GAAe,EAAtD;AACA;;AACA,IAAIC,yCAAyC,GAAG,GAAhD;AACA;;AACA,IAAIC,6BAA6B,GAAG,4EAApC;AACA;;AACA,IAAIC,+BAA+B,GAAGD,6BAA6B,CAACE,OAA9B,CAAsC,sBAAtC,EAA8D,yCAA9D,CAAtC;AACA;;AACA,IAAIC,yBAAyB,GAAG,IAAhC;AACA;;AACA,IAAIC,sBAAsB;AAAG;AAAe,YAAY;AACpD;;;;;;;AAOA,WAASA,sBAAT,CAAgCC,SAAhC,EAA2CC,OAA3C,EAAoD;AAChD,QAAIA,OAAO,KAAK,KAAK,CAArB,EAAwB;AAAEA,MAAAA,OAAO,GAAG,IAAV;AAAiB;;AAC3C,SAAKD,SAAL,GAAiBA,SAAjB;AACA,SAAKC,OAAL,GAAeA,OAAf;AACA,SAAKC,SAAL,GAAiBP,6BAAjB;AACH;AACD;;;;;;;;;;AAQAI,EAAAA,sBAAsB,CAAC7B,SAAvB,CAAiCiC,MAAjC,GAA0C,UAAUC,GAAV,EAAeC,MAAf,EAAuB;AAC7D,QAAIC,UAAU,GAAG;AACbL,MAAAA,OAAO,EAAE,KAAKA,OADD;AAEbD,MAAAA,SAAS,EAAE,KAAKA,SAFH;AAGbI,MAAAA,GAAG,EAAEA,GAAG,IAAI;AAHC,KAAjB;AAKA,QAAIG,OAAO,GAAG1B,KAAK,CAAC2B,YAAN,CAAmB,KAAKN,SAAxB,EAAmCI,UAAnC,CAAd,CAN6D,CAO7D;;AACA,WAAOzB,KAAK,CAAC2B,YAAN,CAAmBD,OAAnB,EAA4BF,MAAM,IAAI,EAAtC,CAAP;AACH,GATD;;AAUA,SAAON,sBAAP;AACH,CAjC2C,EAA5C;AAkCA;;;AACA,IAAIU,iCAAiC;AAAG;AAAe,UAAUC,MAAV,EAAkB;AACrEpD,EAAAA,SAAS,CAACmD,iCAAD,EAAoCC,MAApC,CAAT;AACA;;;;;;;;;;AAQA,WAASD,iCAAT,CAA2CT,SAA3C,EAAsDC,OAAtD,EAA+DU,QAA/D,EAAyE;AACrE,QAAIC,KAAK,GAAGF,MAAM,CAACG,IAAP,CAAY,IAAZ,EAAkBb,SAAlB,EAA6BC,OAA7B,KAAyC,IAArD;;AACAW,IAAAA,KAAK,CAACZ,SAAN,GAAkBA,SAAlB;AACAY,IAAAA,KAAK,CAACX,OAAN,GAAgBA,OAAhB;AACAW,IAAAA,KAAK,CAACD,QAAN,GAAiBA,QAAjB;AACAC,IAAAA,KAAK,CAACV,SAAN,GAAkBN,+BAAlB;AACA,WAAOgB,KAAP;AACH;AACD;;;;;;;;;;AAQAH,EAAAA,iCAAiC,CAACvC,SAAlC,CAA4CiC,MAA5C,GAAqD,UAAUC,GAAV,EAAeC,MAAf,EAAuB;AACxE,WAAOxB,KAAK,CAAC2B,YAAN,CAAmBE,MAAM,CAACxC,SAAP,CAAiBiC,MAAjB,CAAwBU,IAAxB,CAA6B,IAA7B,EAAmCT,GAAnC,EAAwCC,MAAxC,CAAnB,EAAoE;AAAEM,MAAAA,QAAQ,EAAE,KAAKA;AAAjB,KAApE,CAAP;AACH,GAFD;;AAGA,SAAOF,iCAAP;AACH,CA9BsD,CA8BrDV,sBA9BqD,CAAvD;AA+BA;;;;;;;;;AAOA,SAASe,wBAAT,CAAkCC,OAAlC,EAA2C;AACvC,MAAIC,SAAS,GAAG;AACZC,IAAAA,KAAK,EAAE,IADK;AAEZC,IAAAA,UAAU,EAAE,IAFA;AAGZC,IAAAA,KAAK,EAAE,IAHK;AAIZC,IAAAA,WAAW,EAAE,IAJD;AAKZC,IAAAA,QAAQ,EAAE;AALE,GAAhB,CADuC,CAQvC;;AACA,OAAK,IAAIC,GAAT,IAAgBP,OAAhB,EAAyB;AACrB,QAAI,EAAEO,GAAG,IAAIN,SAAT,CAAJ,EAAyB;AACrB,aAAOD,OAAO,CAACO,GAAD,CAAd;AACH;AACJ;;AACD,MAAI,CAAC/C,SAAS,CAACgD,gBAAV,CAA2BR,OAAO,CAACG,UAAnC,CAAL,EAAqD;AACjD,UAAM,IAAIxC,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BC,mBAA1D,CAAN;AACH;;AACD,MAAI,OAAOX,OAAO,CAACK,WAAf,KAA+B,WAA/B,IACA,OAAOL,OAAO,CAACK,WAAf,KAA+B,QADnC,EAC6C;AACzC,UAAM,IAAI1C,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BE,oBAA1D,EAAgF,wCAAwCZ,OAAO,CAACG,UAAhD,GAA6D,4BAA7I,CAAN;AACH;;AACD,MAAI,CAAC3C,SAAS,CAACgD,gBAAV,CAA2BR,OAAO,CAACE,KAAnC,CAAL,EAAgD;AAC5C;AACA;AACA,UAAM,IAAIvC,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BG,WAA1D,EAAuE,gCAAgCb,OAAO,CAACG,UAAxC,GAAqD,sCAA5H,CAAN;AACH,GAzBsC,CA0BvC;;;AACA,MAAI,OAAOH,OAAO,CAACI,KAAf,KAAyB,WAAzB,IAAwC,CAAC5C,SAAS,CAACsD,OAAV,CAAkBd,OAAO,CAACI,KAA1B,CAA7C,EAA+E;AAC3E,UAAM,IAAIzC,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BK,aAA1D,EAAyE,kCAAkCf,OAAO,CAACG,UAA1C,GAAuD,kCAAhI,CAAN;AACH,GA7BsC,CA8BvC;;;AACA,MAAI,OAAOH,OAAO,CAACM,QAAf,KAA4B,WAA5B,IACA,CAAC9C,SAAS,CAACwD,KAAV,CAAgBhB,OAAO,CAACM,QAAxB,CADL,EACwC;AACpC;AACA;AACA,UAAM,IAAI3C,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BO,iBAA1D,EAA6E,qCAAqCjB,OAAO,CAACG,UAA7C,GAA0D,gCAAvI,CAAN;AACH;AACJ;AACD;;;;;;;;;;AAQA,SAASe,yBAAT,CAAmClB,OAAnC,EAA4CmB,oBAA5C,EAAkE;AAC9D,MAAIA,oBAAoB,KAAK,KAAK,CAAlC,EAAqC;AAAEA,IAAAA,oBAAoB,GAAG,KAAvB;AAA+B,GADR,CAE9D;;;AACA,MAAIlB,SAAS,GAAG;AACZI,IAAAA,WAAW,EAAE,IADD;AAEZe,IAAAA,OAAO,EAAE,IAFG;AAGZhB,IAAAA,KAAK,EAAE,IAHK;AAIZiB,IAAAA,QAAQ,EAAE,IAJE;AAKZC,IAAAA,WAAW,EAAE,IALD;AAMZC,IAAAA,aAAa,EAAE,IANH;AAOZjB,IAAAA,QAAQ,EAAE,IAPE;AAQZkB,IAAAA,QAAQ,EAAE,IARE;AASZC,IAAAA,WAAW,EAAE,IATD;AAUZC,IAAAA,eAAe,EAAE,IAVL;AAWZC,IAAAA,cAAc,EAAE,IAXJ;AAYZC,IAAAA,WAAW,EAAE,IAZD;AAaZC,IAAAA,WAAW,EAAE,IAbD;AAcZC,IAAAA,gBAAgB,EAAE,IAdN;AAeZC,IAAAA,UAAU,EAAE,IAfA;AAgBZ;AACAnC,IAAAA,QAAQ,EAAEuB,oBAjBE;AAkBZa,IAAAA,YAAY,EAAEb,oBAlBF;AAmBZc,IAAAA,IAAI,EAAEd,oBAnBM;AAoBZe,IAAAA,SAAS,EAAEf,oBApBC;AAqBZgB,IAAAA,WAAW,EAAEhB,oBArBD;AAsBZiB,IAAAA,gBAAgB,EAAEjB;AAtBN,GAAhB,CAH8D,CA2B9D;;AACA,OAAK,IAAIZ,GAAT,IAAgBP,OAAhB,EAAyB;AACrB,QAAI,EAAEO,GAAG,IAAIN,SAAT,CAAJ,EAAyB;AACrB,aAAOD,OAAO,CAACO,GAAD,CAAd;AACH;AACJ;;AACD,MAAI,OAAOP,OAAO,CAACJ,QAAf,KAA4B,WAA5B,IACA,CAACpC,SAAS,CAACgD,gBAAV,CAA2BR,OAAO,CAACJ,QAAnC,CADL,EACmD;AAC/C,UAAM,IAAIjC,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4B2B,iBAA1D,CAAN;AACH,GApC6D,CAqC9D;AACA;;;AACA,MAAI,OAAOrC,OAAO,CAACK,WAAf,KAA+B,WAA/B,IACA,CAAC7C,SAAS,CAAC8E,QAAV,CAAmBtC,OAAO,CAACK,WAA3B,CADL,EAC8C;AAC1C,UAAM,IAAI1C,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BE,oBAA1D,CAAN;AACH;;AACD,MAAI,CAAC,OAAOZ,OAAO,CAACoB,OAAf,KAA2B,WAA3B,IAA0CD,oBAA3C,KACA,CAAC3D,SAAS,CAAC+E,KAAV,CAAgBvC,OAAO,CAACoB,OAAxB,CADL,EACuC;AACnC;AACA;AACA,UAAM,IAAIzD,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BG,WAA1D,CAAN;AACH,GAhD6D,CAiD9D;;;AACA,MAAI,OAAOb,OAAO,CAACI,KAAf,KAAyB,WAAzB,IAAwC,CAAC5C,SAAS,CAACsD,OAAV,CAAkBd,OAAO,CAACI,KAA1B,CAA7C,EAA+E;AAC3E,UAAM,IAAIzC,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BK,aAA1D,CAAN;AACH,GApD6D,CAqD9D;;;AACA,MAAI,OAAOf,OAAO,CAAC6B,WAAf,KAA+B,WAA/B,IACA,CAACrE,SAAS,CAACgF,aAAV,CAAwBxC,OAAO,CAAC6B,WAAhC,CADL,EACmD;AAC/C,UAAM,IAAIlE,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4B+B,oBAA1D,CAAN;AACH,GAzD6D,CA0D9D;;;AACA,MAAI,OAAOzC,OAAO,CAACqB,QAAf,KAA4B,WAA5B,IACA,CAAC7D,SAAS,CAACkF,UAAV,CAAqB1C,OAAO,CAACqB,QAA7B,CADL,EAC6C;AACzC,UAAM,IAAI1D,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BiC,gBAA1D,CAAN;AACH,GA9D6D,CA+D9D;;;AACA,MAAI,OAAO3C,OAAO,CAACsB,WAAf,KAA+B,WAA/B,IACA,CAAC9D,SAAS,CAACkF,UAAV,CAAqB1C,OAAO,CAACsB,WAA7B,CADL,EACgD;AAC5C;AACA;AACA,UAAM,IAAI3D,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BiC,gBAA1D,CAAN;AACH,GArE6D,CAsE9D;;;AACA,MAAI,OAAO3C,OAAO,CAACuB,aAAf,KAAiC,WAAjC,IACA,OAAOvB,OAAO,CAACuB,aAAf,KAAiC,SADrC,EACgD;AAC5C,UAAM,IAAI5D,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BkC,sBAA1D,CAAN;AACH,GA1E6D,CA2E9D;;;AACA,MAAI,OAAO5C,OAAO,CAACM,QAAf,KAA4B,WAA5B,IACA,CAAC9C,SAAS,CAACwD,KAAV,CAAgBhB,OAAO,CAACM,QAAxB,CADL,EACwC;AACpC;AACA;AACA,UAAM,IAAI3C,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BO,iBAA1D,CAAN;AACH,GAjF6D,CAkF9D;;;AACA,MAAI,OAAOjB,OAAO,CAACwB,QAAf,KAA4B,WAA5B,IACA,OAAOxB,OAAO,CAACwB,QAAf,KAA4B,SADhC,EAC2C;AACvC,UAAM,IAAI7D,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BmC,sBAA1D,CAAN;AACH,GAtF6D,CAuF9D;;;AACA,MAAI,OAAO7C,OAAO,CAAC+B,UAAf,KAA8B,WAA9B,IACA,CAACvE,SAAS,CAACsF,QAAV,CAAmB9C,OAAO,CAAC+B,UAA3B,CADL,EAC6C;AACzC,UAAM,IAAIpE,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BqC,+BAA1D,CAAN;AACH,GA3F6D,CA4F9D;;;AACA,MAAI,OAAO/C,OAAO,CAACkC,SAAf,KAA6B,WAA7B,IACA,CAAC1E,SAAS,CAACsF,QAAV,CAAmB9C,OAAO,CAACkC,SAA3B,CADL,EAC4C;AACxC,UAAM,IAAIvE,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BsC,qBAA1D,CAAN;AACH,GAhG6D,CAiG9D;;;AACA,MAAI,OAAOhD,OAAO,CAACmC,WAAf,KAA+B,WAA/B,IACA,CAAC3E,SAAS,CAACsF,QAAV,CAAmB9C,OAAO,CAACmC,WAA3B,CADL,EAC8C;AAC1C,UAAM,IAAIxE,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BuC,yBAA1D,CAAN;AACH,GArG6D,CAsG9D;;;AACA,MAAI,OAAOjD,OAAO,CAACyB,WAAf,KAA+B,WAA/B,IACA,OAAOzB,OAAO,CAACyB,WAAf,KAA+B,SADnC,EAC8C;AAC1C;AACA;AACA,UAAM,IAAI9D,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BmC,sBAA1D,CAAN;AACH,GA5G6D,CA6G9D;AACA;;;AACA,MAAI,OAAO7C,OAAO,CAAC8B,gBAAf,KAAoC,WAAxC,EAAqD;AACjD,QAAIoB,iBAAJ;;AACA,QAAI;AACAA,MAAAA,iBAAiB,GAAGC,IAAI,CAACC,KAAL,CAAWpD,OAAO,CAAC8B,gBAAnB,CAApB;AACH,KAFD,CAGA,OAAOuB,KAAP,EAAc;AACV;AACA;AACA;AACA,YAAM,IAAI1F,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4B4C,cAA1D,EAA0ED,KAAK,CAACE,OAAhF,CAAN;AACH;;AACD,QAAIC,eAAe,GAAG,EAAtB,CAXiD,CAYjD;;AACAlG,IAAAA,OAAO,CAACc,eAAR,CAAwBqF,OAAxB,CAAgC,UAAUC,gBAAV,EAA4B;AACxD,UAAIR,iBAAiB,CAAClG,cAAlB,CAAiC0G,gBAAjC,CAAJ,EAAwD;AACpDF,QAAAA,eAAe,CAACG,IAAhB,CAAqBD,gBAArB;AACH;AACJ,KAJD,EAbiD,CAkBjD;;AACA,QAAIF,eAAe,CAACI,MAAhB,GAAyB,CAA7B,EAAgC;AAC5B,YAAM,IAAIjG,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BmD,eAA1D,EAA2EL,eAAe,CAACI,MAAhB,GAAyB,CAAzB,GAC7E,wBAAwBJ,eAAe,CAACM,IAAhB,CAAqB,MAArB,CAAxB,GAAuD,0CADsB,GAE7E,uBAAuBN,eAAe,CAAC,CAAD,CAAtC,GAA4C,yCAF1C,CAAN;AAGH,KAvBgD,CAwBjD;;;AACA,QAAIxD,OAAO,CAAC8B,gBAAR,CAAyB8B,MAAzB,GAAkCtF,uBAAtC,EAA+D;AAC3D,YAAM,IAAIX,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BqD,gBAA1D,EAA4E,gDAAgDzF,uBAAhD,GAA0E,cAAtJ,CAAN;AACH;AACJ,GA3I6D,CA4I9D;;;AACA,MAAI,OAAO0B,OAAO,CAACgC,YAAf,KAAgC,WAAhC,IACA,CAACxE,SAAS,CAAC8E,QAAV,CAAmBtC,OAAO,CAACgC,YAA3B,CADL,EAC+C;AAC3C,UAAM,IAAIrE,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BsD,qBAA1D,CAAN;AACH,GAhJ6D,CAiJ9D;;;AACA,MAAI,OAAOhE,OAAO,CAACiC,IAAf,KAAwB,WAAxB,IACA,CAACzE,SAAS,CAAC8E,QAAV,CAAmBtC,OAAO,CAACiC,IAA3B,CADL,EACuC;AACnC,UAAM,IAAItE,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BuD,qBAA1D,CAAN;AACH,GArJ6D,CAsJ9D;;;AACA,MAAI,OAAOjE,OAAO,CAACoC,gBAAf,KAAoC,WAApC,IACA,CAAC5E,SAAS,CAAC0G,OAAV,CAAkBlE,OAAO,CAACoC,gBAA1B,CADL,EACkD;AAC9C,UAAM,IAAIzE,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4ByD,qBAA1D,CAAN;AACH,GAHD,MAIK,IAAI3G,SAAS,CAAC0G,OAAV,CAAkBlE,OAAO,CAACoC,gBAA1B,CAAJ,EAAiD;AAClDpC,IAAAA,OAAO,CAACoC,gBAAR,CAAyBqB,OAAzB,CAAiC,UAAUW,qBAAV,EAAiC;AAC9DrE,MAAAA,wBAAwB,CAACqE,qBAAD,CAAxB;AACH,KAFD;AAGH;AACJ;AACD;;;AACA9G,OAAO,CAAC+G,mCAAR,GAA8C,IAAIzG,aAAa,CAAC0G,WAAlB,CAA8B,sBAA9B,EAAsD,MAAtD,EAC1C;AAD0C,CAEzCC,mBAFyC,CAErB,UAAUvE,OAAV,EAAmB;AACxC;AACA,MAAI,CAACxC,SAAS,CAACgD,gBAAV,CAA2BR,OAAO,CAACwE,OAAnC,CAAL,EAAkD;AAC9C,UAAM,IAAI7G,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4B+D,gBAA1D,CAAN;AACH,GAJuC,CAKxC;;;AACA,MAAI,CAACjH,SAAS,CAACsF,QAAV,CAAmB9C,OAAO,CAAC0E,aAA3B,CAAD,IACA1E,OAAO,CAAC0E,aAAR,GAAwBjG,gCADxB,IAEAuB,OAAO,CAAC0E,aAAR,GAAwBhG,gCAF5B,EAE8D;AAC1D,UAAM,IAAIf,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BiE,+BAA1D,CAAN;AACH;AACJ,CAb6C,EAc1C;AAd0C,CAezCC,oBAfyC,CAepB,UAAUC,QAAV,EAAoB;AAC1C;AACA,MAAI,CAACrH,SAAS,CAACgD,gBAAV,CAA2BqE,QAAQ,CAACC,aAApC,CAAL,EAAyD;AACrD,UAAM,IAAInH,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BqE,cAA1D,CAAN;AACH;AACJ,CApB6C,CAA9C;AAqBA;;AACAzH,OAAO,CAAC0H,4BAAR,GAAuC,IAAIpH,aAAa,CAAC0G,WAAlB,CAA8B,uBAA9B,EAAuD,MAAvD,CAAvC;AACA;;AACAhH,OAAO,CAAC2H,8BAAR,GAAyC,IAAIrH,aAAa,CAAC0G,WAAlB,CAA8B,oBAA9B,EAAoD,KAApD,EACrC;AADqC,CAEpCC,mBAFoC,CAEhB,UAAUvE,OAAV,EAAmB;AACxC;AACA,MAAI,OAAOA,OAAO,CAACkF,aAAf,KAAiC,WAAjC,IACA,CAAC1H,SAAS,CAACgD,gBAAV,CAA2BR,OAAO,CAACkF,aAAnC,CADL,EACwD;AACpD,UAAM,IAAIvH,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4ByE,kBAA1D,CAAN;AACH,GALuC,CAMxC;;;AACA,MAAI,CAAC3H,SAAS,CAACsF,QAAV,CAAmB9C,OAAO,CAACoF,UAA3B,CAAD,IACApF,OAAO,CAACoF,UAAR,IAAsB,CADtB,IAEApF,OAAO,CAACoF,UAAR,GAAqB7G,8BAFzB,EAEyD;AACrD,UAAM,IAAIZ,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4B2E,gBAA1D,EAA4E,8EAC7E9G,8BAA8B,GAAG,GAD4C,CAA5E,CAAN;AAEH;AACJ,CAfwC,CAAzC;AAgBA;;AACAjB,OAAO,CAACgI,8BAAR,GAAyC,IAAI1H,aAAa,CAAC0G,WAAlB,CAA8B,kBAA9B,EAAkD,MAAlD,EACrC;AADqC,CAEpCC,mBAFoC,CAEhB,UAAUvE,OAAV,EAAmB;AACxC,MAAI,CAACA,OAAO,CAACoB,OAAT,IAAoB,CAACpB,OAAO,CAACI,KAA7B,IAAsC,CAACJ,OAAO,CAAC6B,WAAnD,EAAgE;AAC5D,UAAM,IAAIlE,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BqE,cAA1D,EAA0E,mEAA1E,CAAN;AACH;AACJ,CANwC,EAOrC;AAPqC,CAQpCH,oBARoC,CAQf,UAAUC,QAAV,EAAoB;AAC1C,MAAI,CAACA,QAAQ,CAACU,KAAd,EAAqB;AACjB,UAAM,IAAI5H,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4B8E,cAA1D,CAAN;AACH;AACJ,CAZwC,CAAzC;AAaA;;AACAlI,OAAO,CAACmI,4BAAR,GAAuC,IAAI7H,aAAa,CAAC0G,WAAlB,CAA8B,kBAA9B,EAAkD,MAAlD,EACnC;AADmC,CAElCC,mBAFkC,CAEd,UAAUvE,OAAV,EAAmB;AACxC,MAAI,CAACA,OAAO,CAACoB,OAAb,EAAsB;AAClB,UAAM,IAAIzD,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BqE,cAA1D,EAA0E,mEAA1E,CAAN;AACH;AACJ,CANsC,CAAvC;AAOA;;AACAzH,OAAO,CAACoI,8BAAR,GAAyC,IAAI9H,aAAa,CAAC0G,WAAlB,CAA8B,kBAA9B,EAAkD,MAAlD,EACrC;AADqC,CAEpCC,mBAFoC,CAEhB,UAAUvE,OAAV,EAAmB;AACxC;AACA,MAAI,OAAOA,OAAO,CAACoB,OAAf,KAA2B,WAA/B,EAA4C;AACxC,UAAM,IAAIzD,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BqE,cAA1D,EAA0E,mEAA1E,CAAN;AACH,GAJuC,CAKxC;;;AACA,MAAI,OAAO/E,OAAO,CAACJ,QAAf,KAA4B,WAAhC,EAA6C;AACzC,UAAM,IAAIjC,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4B2E,gBAA1D,EAA4E,oDAA5E,CAAN;AACH;;AACDnE,EAAAA,yBAAyB,CAAClB,OAAD,CAAzB;AACH,CAZwC,EAarC;AAbqC,CAcpC4E,oBAdoC,CAcf,UAAUC,QAAV,EAAoB;AAC1C;AACA,MAAI,CAACA,QAAQ,CAACzD,OAAd,EAAuB;AACnB,UAAM,IAAIzD,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4B8E,cAA1D,CAAN;AACH;AACJ,CAnBwC,CAAzC;AAoBA;;;;;AAIAlI,OAAO,CAACqI,8BAAR,GAAyC,IAAI/H,aAAa,CAAC0G,WAAlB,CAA8B,WAA9B,EAA2C,MAA3C,EACrC;AADqC,CAEpCC,mBAFoC,CAEhB,UAAUvE,OAAV,EAAmB;AACxC;AACA,MAAI,OAAOA,OAAO,CAAC8B,gBAAf,KAAoC,WAAxC,EAAqD;AACjD,UAAM,IAAInE,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4B2E,gBAA1D,EAA4E,8DAA5E,CAAN;AACH,GAJuC,CAKxC;;;AACA,MAAI,OAAOrF,OAAO,CAAC+B,UAAf,KAA8B,WAAlC,EAA+C;AAC3C,UAAM,IAAIpE,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4B2E,gBAA1D,EAA4E,wDAA5E,CAAN;AACH,GARuC,CASxC;;;AACA,MAAI,OAAOrF,OAAO,CAACJ,QAAf,KAA4B,WAAhC,EAA6C;AACzC,UAAM,IAAIjC,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4B2E,gBAA1D,EAA4E,oDAA5E,CAAN;AACH;;AACDnE,EAAAA,yBAAyB,CAAClB,OAAD,CAAzB;AACH,CAhBwC,EAiBrC;AAjBqC,CAkBpC4E,oBAlBoC,CAkBf,UAAUC,QAAV,EAAoB;AAC1C;AACA,MAAI,CAACA,QAAQ,CAACzD,OAAd,EAAuB;AACnB,UAAM,IAAIzD,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BqE,cAA1D,EAA0E,mDAA1E,CAAN;AACH;AACJ,CAvBwC,CAAzC;AAwBA,IAAIa,0BAA0B,GAAG,IAAIhI,aAAa,CAAC0G,WAAlB,CAA8B,uBAA9B,EAAuD,MAAvD,EAC7B;AAD6B,CAE5BC,mBAF4B,CAER,UAAUvE,OAAV,EAAmB;AACxC,MAAI,CAACxC,SAAS,CAACsD,OAAV,CAAkBd,OAAO,CAACI,KAA1B,CAAL,EAAuC;AACnC,UAAM,IAAIzC,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BK,aAA1D,CAAN;AACH;;AACD,MAAIzD,OAAO,CAACe,0BAAR,CAAmCwH,OAAnC,CAA2C7F,OAAO,CAAC8F,WAAnD,MAAoE,CAAC,CAAzE,EAA4E;AACxE,UAAM,IAAInI,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4B2E,gBAA1D,EAA4E,OAAOrF,OAAO,CAAC8F,WAAf,GAA6B,kDAAzG,CAAN;AACH;AACJ,CATgC,EAU7B;AAV6B,CAW5BlB,oBAX4B,CAWP,UAAUC,QAAV,EAAoB;AAC1C;AACA,MAAI,CAACA,QAAQ,CAACkB,OAAd,EAAuB;AACnB,UAAM,IAAIpI,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BqE,cAA1D,EAA0E,gEAA1E,CAAN;AACH;AACJ,CAhBgC,CAAjC;AAiBA;;AACA,IAAIiB,oBAAoB,GAAG,IAAIpI,aAAa,CAAC0G,WAAlB,CAA8B,+BAA9B,EAA+D,KAA/D,EACvB;AADuB,CAEtBM,oBAFsB,CAED,UAAUC,QAAV,EAAoB;AAC1C;AACA,MAAI,CAACrH,SAAS,CAACgD,gBAAV,CAA2BqE,QAAQ,CAACoB,IAApC,CAAL,EAAgD;AAC5C,UAAM,IAAItI,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BqE,cAA1D,EAA0E,0DAA1E,CAAN;AACH;AACJ,CAP0B,CAA3B;AAQA;;AACA,IAAImB,uBAAuB,GAAG,IAAItI,aAAa,CAAC0G,WAAlB,CAA8B,+BAA9B,EAA+D,QAA/D,CAA9B;AACA;;AACA,IAAI6B,uBAAuB,GAAG,IAAIvI,aAAa,CAAC0G,WAAlB,CAA8B,gDAA9B,EAAgF,MAAhF,EAC1B;AAD0B,CAEzBM,oBAFyB,CAEJ,UAAUC,QAAV,EAAoB;AAC1C;AACA,MAAI,CAACrH,SAAS,CAACgD,gBAAV,CAA2BqE,QAAQ,CAACoB,IAApC,CAAL,EAAgD;AAC5C,UAAM,IAAItI,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BqE,cAA1D,EAA0E,iEAA1E,CAAN;AACH;AACJ,CAP6B,CAA9B;AAQA;;AACA,IAAIqB,uBAAuB,GAAG,IAAIxI,aAAa,CAAC0G,WAAlB,CAA8B,uDAA9B,EAAuF,OAAvF,EAC1B;AAD0B,CAEzBM,oBAFyB,CAEJ,UAAUC,QAAV,EAAoB;AAC1C;AACA,MAAI,CAACrH,SAAS,CAACgD,gBAAV,CAA2BqE,QAAQ,CAACoB,IAApC,CAAL,EAAgD;AAC5C,UAAM,IAAItI,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BqE,cAA1D,EAA0E,6DAA1E,CAAN;AACH;AACJ,CAP6B,CAA9B;AAQA;;AACA,IAAIsB,sBAAsB,GAAG,IAAIzI,aAAa,CAAC0G,WAAlB,CAA8B,kBAA9B,EAAkD,KAAlD,EACzB;AADyB,CAExBC,mBAFwB,CAEJ,UAAUvE,OAAV,EAAmB;AACxC;AACA,MAAI,OAAOA,OAAO,CAACsG,SAAf,KAA6B,WAA7B,IACA,CAAC9I,SAAS,CAACgD,gBAAV,CAA2BR,OAAO,CAACsG,SAAnC,CADL,EACoD;AAChD,UAAM,IAAI3I,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4ByE,kBAA1D,CAAN;AACH,GALuC,CAMxC;;;AACA,MAAI,CAAC3H,SAAS,CAACsF,QAAV,CAAmB9C,OAAO,CAACuG,QAA3B,CAAD,IACAvG,OAAO,CAACuG,QAAR,IAAoB,CADpB,IAEAvG,OAAO,CAACuG,QAAR,GAAmB5H,yCAFvB,EAEkE;AAC9D,UAAM,IAAIhB,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4B2E,gBAA1D,EAA4E,8EAC7E1G,yCAAyC,GAAG,GADiC,CAA5E,CAAN;AAEH;AACJ,CAf4B,CAA7B;AAgBA;;AACA,IAAI6H,uBAAuB,GAAG,IAAI5I,aAAa,CAAC0G,WAAlB,CAA8B,kCAA9B,EAAkE,KAAlE,EAC1B;AAD0B,CAEzBM,oBAFyB,CAEJ,UAAUC,QAAV,EAAoB;AAC1C;AACA,MAAI,CAACrH,SAAS,CAACgD,gBAAV,CAA2BqE,QAAQ,CAACoB,IAApC,CAAL,EAAgD;AAC5C,UAAM,IAAItI,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BqE,cAA1D,EAA0E,0DAA1E,CAAN;AACH;AACJ,CAP6B,CAA9B;AAQA;;AACA,IAAI0B,0BAA0B,GAAG,IAAI7I,aAAa,CAAC0G,WAAlB,CAA8B,kCAA9B,EAAkE,QAAlE,CAAjC;AACA;;AACA,IAAIoC,0BAA0B,GAAG,IAAI9I,aAAa,CAAC0G,WAAlB,CAA8B,sDAA9B,EAAsF,MAAtF,EAC7B;AAD6B,CAE5BM,oBAF4B,CAEP,UAAUC,QAAV,EAAoB;AAC1C;AACA,MAAI,CAACrH,SAAS,CAACgD,gBAAV,CAA2BqE,QAAQ,CAACoB,IAApC,CAAL,EAAgD;AAC5C,UAAM,IAAItI,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BqE,cAA1D,EAA0E,iEAA1E,CAAN;AACH;AACJ,CAPgC,CAAjC;AAQA;;AACA,IAAI4B,0BAA0B,GAAG,IAAI/I,aAAa,CAAC0G,WAAlB,CAA8B,0DAA9B,EAA0F,OAA1F,EAC7B;AAD6B,CAE5BM,oBAF4B,CAEP,UAAUC,QAAV,EAAoB;AAC1C;AACA,MAAI,CAACrH,SAAS,CAACgD,gBAAV,CAA2BqE,QAAQ,CAACoB,IAApC,CAAL,EAAgD;AAC5C,UAAM,IAAItI,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BqE,cAA1D,EAA0E,6DAA1E,CAAN;AACH;AACJ,CAPgC,CAAjC;AAQA;;AACA,IAAI6B,yBAAyB,GAAG,IAAIhJ,aAAa,CAAC0G,WAAlB,CAA8B,qBAA9B,EAAqD,KAArD,EAC5B;AAD4B,CAE3BC,mBAF2B,CAEP,UAAUvE,OAAV,EAAmB;AACxC;AACA,MAAI,OAAOA,OAAO,CAACsG,SAAf,KAA6B,WAA7B,IACA,CAAC9I,SAAS,CAACgD,gBAAV,CAA2BR,OAAO,CAACsG,SAAnC,CADL,EACoD;AAChD,UAAM,IAAI3I,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4ByE,kBAA1D,CAAN;AACH,GALuC,CAMxC;;;AACA,MAAI,CAAC3H,SAAS,CAACsF,QAAV,CAAmB9C,OAAO,CAACuG,QAA3B,CAAD,IACAvG,OAAO,CAACuG,QAAR,IAAoB,CADpB,IAEAvG,OAAO,CAACuG,QAAR,GAAmB5H,yCAFvB,EAEkE;AAC9D,UAAM,IAAIhB,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4B2E,gBAA1D,EAA4E,8EAC7E1G,yCAAyC,GAAG,GADiC,CAA5E,CAAN;AAEH;AACJ,CAf+B,CAAhC;AAgBA;;;;AAGA,IAAIkI,0BAA0B;AAAG;AAAe,YAAY;AACxD;;;;AAIA,WAASA,0BAAT,CAAoCC,GAApC,EAAyC;AACrC,QAAI,OAAOA,GAAP,KAAe,QAAf,IAA2BA,GAAG,KAAK,IAAnC,IAA2C,EAAE,aAAaA,GAAf,CAA/C,EAAoE;AAChE,YAAM,IAAInJ,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4B2E,gBAA1D,EAA4E,8EAA5E,CAAN;AACH;;AACD,SAAKpG,SAAL,GAAiBnB,KAAK,CAACiJ,YAAN,CAAmBD,GAAnB,CAAjB;AACA,SAAKE,UAAL,GAAkB,IAAIpJ,aAAa,CAACqJ,oBAAlB,CAAuCH,GAAvC,CAAlB;AACH;AACD;;;;;;AAIAD,EAAAA,0BAA0B,CAACK,YAA3B,GAA0C,UAAUrC,QAAV,EAAoB;AAC1D,WAAQrH,SAAS,CAAC2J,eAAV,CAA0BtC,QAA1B,KAAuCA,QAAQ,CAACxB,KAAhD,IAAyDwB,QAAQ,CAACxB,KAAT,CAAeE,OAAzE,IAAqF,IAA5F;AACH,GAFD;AAGA;;;;;;;;;;;;AAUAsD,EAAAA,0BAA0B,CAAC1J,SAA3B,CAAqCiK,mBAArC,GAA2D,UAAU5C,OAAV,EAAmB6C,SAAnB,EAA8B;AACrF,QAAIrH,OAAO,GAAG;AACVwE,MAAAA,OAAO,EAAEA,OADC;AAEV;AACAE,MAAAA,aAAa,EAAE2C,SAAS,GAAG;AAHjB,KAAd;AAKA,WAAO,KAAKC,oBAAL,CAA0B,KAAKC,iBAAL,EAA1B,EAAoDjK,OAAO,CAAC+G,mCAA5D,EAAiGrE,OAAjG,EACFwH,IADE,CACG,UAAU3C,QAAV,EAAoB;AAAE,aAAOA,QAAQ,CAACC,aAAhB;AAAgC,KADzD,CAAP;AAEH,GARD;AASA;;;;;;;;AAMA+B,EAAAA,0BAA0B,CAAC1J,SAA3B,CAAqCsK,mBAArC,GAA2D,UAAUC,GAAV,EAAe;AACtE,QAAI,CAAClK,SAAS,CAAC+E,KAAV,CAAgBmF,GAAhB,CAAL,EAA2B;AACvB,aAAOC,OAAO,CAACC,MAAR,CAAe,IAAIjK,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BG,WAA1D,CAAf,CAAP;AACH;;AACD,QAAIb,OAAO,GAAG;AACVoB,MAAAA,OAAO,EAAE,CAACsG,GAAD;AADC,KAAd;AAGA,WAAO,KAAKJ,oBAAL,CAA0B,KAAKC,iBAAL,EAA1B,EAAoDjK,OAAO,CAACgI,8BAA5D,EAA4FtF,OAA5F,CAAP;AACH,GARD;AASA;;;;;;;;AAMA6G,EAAAA,0BAA0B,CAAC1J,SAA3B,CAAqC0K,qBAArC,GAA6D,UAAUzH,KAAV,EAAiB;AAC1E,QAAI,CAAC5C,SAAS,CAACsD,OAAV,CAAkBV,KAAlB,CAAL,EAA+B;AAC3B,aAAOuH,OAAO,CAACC,MAAR,CAAe,IAAIjK,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BK,aAA1D,CAAf,CAAP;AACH;;AACD,QAAIf,OAAO,GAAG;AACVI,MAAAA,KAAK,EAAE,CAACA,KAAD;AADG,KAAd;AAGA,WAAO,KAAKkH,oBAAL,CAA0B,KAAKC,iBAAL,EAA1B,EAAoDjK,OAAO,CAACgI,8BAA5D,EAA4FtF,OAA5F,CAAP;AACH,GARD;AASA;;;;;;;;AAMA6G,EAAAA,0BAA0B,CAAC1J,SAA3B,CAAqC2K,2BAArC,GAAmE,UAAUjG,WAAV,EAAuB;AACtF,QAAI,CAACrE,SAAS,CAACgF,aAAV,CAAwBX,WAAxB,CAAL,EAA2C;AACvC,aAAO8F,OAAO,CAACC,MAAR,CAAe,IAAIjK,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4B+B,oBAA1D,CAAf,CAAP;AACH;;AACD,QAAIzC,OAAO,GAAG;AACV6B,MAAAA,WAAW,EAAE,CAACA,WAAD;AADH,KAAd;AAGA,WAAO,KAAKyF,oBAAL,CAA0B,KAAKC,iBAAL,EAA1B,EAAoDjK,OAAO,CAACgI,8BAA5D,EAA4FtF,OAA5F,CAAP;AACH,GARD;AASA;;;;;;;;;;;;;;;AAaA6G,EAAAA,0BAA0B,CAAC1J,SAA3B,CAAqC4K,eAArC,GAAuD,UAAU3C,UAAV,EAAsBkB,SAAtB,EAAiC;AACpF,QAAIlB,UAAU,KAAK,KAAK,CAAxB,EAA2B;AAAEA,MAAAA,UAAU,GAAG7G,8BAAb;AAA8C,KADS,CAEpF;;;AACA,QAAIyB,OAAO,GAAG;AACVoF,MAAAA,UAAU,EAAEA,UADF;AAEVF,MAAAA,aAAa,EAAEoB;AAFL,KAAd,CAHoF,CAOpF;;AACA,QAAI,OAAOtG,OAAO,CAACkF,aAAf,KAAiC,WAArC,EAAkD;AAC9C,aAAOlF,OAAO,CAACkF,aAAf;AACH;;AACD,WAAO,KAAKoC,oBAAL,CAA0B,KAAKC,iBAAL,EAA1B,EAAoDjK,OAAO,CAAC2H,8BAA5D,EAA4FjF,OAA5F,EACFwH,IADE,CACG,UAAU3C,QAAV,EAAoB;AAC1B;AACA,UAAI,CAACA,QAAQ,CAACU,KAAd,EAAqB;AACjBV,QAAAA,QAAQ,CAACU,KAAT,GAAiB,EAAjB;AACH;;AACD,aAAOV,QAAP;AACH,KAPM,CAAP;AAQH,GAnBD;AAoBA;;;;;;;;;;;;;;;AAaAgC,EAAAA,0BAA0B,CAAC1J,SAA3B,CAAqC6K,aAArC,GAAqD,UAAUzC,KAAV,EAAiB0C,OAAjB,EAA0B;AAC3E;AACA;AACA;AACA;AACA,QAAIC,iBAAiB,GAAG,IAAIrK,qBAAqB,CAACsK,iBAA1B,CAA4C5C,KAA5C,EAAmD0C,OAAnD,EAA4D,UAAUG,WAAV,EAAuB;AACvG;AACAlH,MAAAA,yBAAyB,CAACkH,WAAD,EAAc,IAAd,CAAzB;AACH,KAHuB,CAAxB;AAIA,QAAIpI,OAAO,GAAGkI,iBAAiB,CAACG,YAAlB,EAAd,CAT2E,CAU3E;;AACA,QAAI7K,SAAS,CAAC0G,OAAV,CAAkBqB,KAAlB,KAA4BA,KAAK,CAAC3B,MAAN,GAAepF,6BAA/C,EAA8E;AAC1E,YAAM,IAAIb,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4B4H,2BAA1D,EAAuF,kBAAkB9J,6BAAlB,GAAkD,iCAAzI,CAAN;AACH,KAb0E,CAc3E;AACA;;;AACA,QAAIwB,OAAO,CAACuF,KAAR,CAAc3B,MAAd,KAAyB,CAA7B,EAAgC;AAC5B,aAAO+D,OAAO,CAACY,OAAR,CAAgBL,iBAAiB,CAACM,aAAlB,CAAgC,EAAhC,CAAhB,CAAP;AACH;;AACD,WAAO,KAAKlB,oBAAL,CAA0B,KAAKC,iBAAL,EAA1B,EAAoDjK,OAAO,CAAC0H,4BAA5D,EAA0FhF,OAA1F,EACFwH,IADE,CACG,UAAU3C,QAAV,EAAoB;AAC1B;AACA,UAAI4D,aAAa,GAAI5D,QAAQ,CAACxB,KAAT,IAAkB,EAAvC,CAF0B,CAG1B;;AACA,aAAO6E,iBAAiB,CAACM,aAAlB,CAAgCC,aAAhC,CAAP;AACH,KANM,CAAP;AAOH,GA1BD;AA2BA;;;;;;;;AAMA5B,EAAAA,0BAA0B,CAAC1J,SAA3B,CAAqCuL,aAArC,GAAqD,UAAUhB,GAAV,EAAe;AAChE,QAAI,CAAClK,SAAS,CAAC+E,KAAV,CAAgBmF,GAAhB,CAAL,EAA2B;AACvB,aAAOC,OAAO,CAACC,MAAR,CAAe,IAAIjK,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BG,WAA1D,CAAf,CAAP;AACH;;AACD,QAAIb,OAAO,GAAG;AACVoB,MAAAA,OAAO,EAAEsG;AADC,KAAd;AAGA,WAAO,KAAKJ,oBAAL,CAA0B,KAAKC,iBAAL,EAA1B,EAAoDjK,OAAO,CAACmI,4BAA5D,EAA0FzF,OAA1F,CAAP;AACH,GARD;AASA;;;;;;;;;;AAQA6G,EAAAA,0BAA0B,CAAC1J,SAA3B,CAAqCwL,mBAArC,GAA2D,UAAUjB,GAAV,EAAekB,gBAAf,EAAiC;AACxF;AACA,QAAI,CAACpL,SAAS,CAAC+E,KAAV,CAAgBmF,GAAhB,CAAL,EAA2B;AACvB,aAAOC,OAAO,CAACC,MAAR,CAAe,IAAIjK,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BG,WAA1D,CAAf,CAAP;AACH,KAFD,MAGK,IAAI,CAACrD,SAAS,CAACqL,QAAV,CAAmBD,gBAAnB,CAAL,EAA2C;AAC5C,aAAOjB,OAAO,CAACC,MAAR,CAAe,IAAIjK,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4B2E,gBAA1D,EAA4E,sDAA5E,CAAf,CAAP;AACH,KAPuF,CAQxF;;;AACA,QAAIuD,gBAAgB,KAAK,IAAzB,EAA+B;AAC3BA,MAAAA,gBAAgB,GAAG,EAAnB;AACH,KAXuF,CAYxF;;;AACA,QAAI5I,OAAO,GAAG;AACVoB,MAAAA,OAAO,EAAEsG,GADC;AAEV5F,MAAAA,gBAAgB,EAAEqB,IAAI,CAAC2F,SAAL,CAAeF,gBAAf;AAFR,KAAd;AAIA,WAAO,KAAKtB,oBAAL,CAA0B,KAAKC,iBAAL,EAA1B,EAAoDjK,OAAO,CAACoI,8BAA5D,EAA4F1F,OAA5F,EACFwH,IADE,CACG,UAAU3C,QAAV,EAAoB;AAC1B,aAAOA,QAAQ,CAACzD,OAAhB;AACH,KAHM,CAAP;AAIH,GArBD;AAsBA;;;;;;;;;;AAQAyF,EAAAA,0BAA0B,CAAC1J,SAA3B,CAAqC4L,qBAArC,GAA6D,UAAUrB,GAAV,EAAesB,UAAf,EAA2B;AACpF,QAAI,CAACxL,SAAS,CAAC+E,KAAV,CAAgBmF,GAAhB,CAAL,EAA2B;AACvB,aAAOC,OAAO,CAACC,MAAR,CAAe,IAAIjK,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BG,WAA1D,CAAf,CAAP;AACH,KAFD,MAGK,IAAI,CAACrD,SAAS,CAAC2J,eAAV,CAA0B6B,UAA1B,CAAL,EAA4C;AAC7C,aAAOrB,OAAO,CAACC,MAAR,CAAe,IAAIjK,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4B2E,gBAA1D,EAA4E,gDAA5E,CAAf,CAAP;AACH,KANmF,CAOpF;;;AACA,QAAIrF,OAAO,GAAGtC,WAAW,CAACuL,QAAZ,CAAqBD,UAArB,CAAd;AACAhJ,IAAAA,OAAO,CAACoB,OAAR,GAAkBsG,GAAlB,CAToF,CAUpF;AACA;AACA;AACA;AACA;AACA;;AACA,QAAIwB,eAAe,GAAG;AAClB7I,MAAAA,WAAW,EAAE,cADK;AAElB8I,MAAAA,QAAQ,EAAE;AAFQ,KAAtB,CAhBoF,CAoBpF;;AACAnJ,IAAAA,OAAO,CAAC0B,eAAR,GAA0B,EAA1B;;AACA,SAAK,IAAInB,GAAT,IAAgB2I,eAAhB,EAAiC;AAC7B,UAAIlJ,OAAO,CAACO,GAAD,CAAP,KAAiB,IAArB,EAA2B;AACvB;AACAP,QAAAA,OAAO,CAAC0B,eAAR,CAAwBiC,IAAxB,CAA6BuF,eAAe,CAAC3I,GAAD,CAA5C,EAFuB,CAGvB;;AACA,eAAOP,OAAO,CAACO,GAAD,CAAd;AACH;AACJ;;AACD,QAAIP,OAAO,CAAC0B,eAAR,CAAwBkC,MAAxB,KAAmC,CAAvC,EAA0C;AACtC,aAAO5D,OAAO,CAAC0B,eAAf;AACH,KAhCmF,CAiCpF;AACA;AACA;AACA;AACA;;;AACA,QAAI1B,OAAO,CAAC6B,WAAR,KAAwB,IAA5B,EAAkC;AAC9B7B,MAAAA,OAAO,CAAC2B,cAAR,GAAyB,CAAC,OAAD,CAAzB;AACA,aAAO3B,OAAO,CAAC6B,WAAf;AACH,KAHD,MAIK;AACD;AACA,aAAO7B,OAAO,CAAC2B,cAAf;AACH,KA7CmF,CA8CpF;;;AACA,QAAI,OAAO3B,OAAO,CAACmJ,QAAf,KAA4B,WAAhC,EAA6C;AACzCnJ,MAAAA,OAAO,CAACM,QAAR,GAAmBN,OAAO,CAACmJ,QAA3B;AACA,aAAOnJ,OAAO,CAACmJ,QAAf;AACH,KAlDmF,CAmDpF;;;AACA,QAAI,OAAOnJ,OAAO,CAACwB,QAAf,KAA4B,WAAhC,EAA6C;AACzCxB,MAAAA,OAAO,CAACyB,WAAR,GAAsBzB,OAAO,CAACwB,QAA9B;AACA,aAAOxB,OAAO,CAACwB,QAAf;AACH;;AACD,WAAO,KAAK8F,oBAAL,CAA0B,KAAKC,iBAAL,EAA1B,EAAoDjK,OAAO,CAACoI,8BAA5D,EAA4F1F,OAA5F,EACFwH,IADE,CACG,UAAU3C,QAAV,EAAoB;AAC1B,aAAOA,QAAQ,CAACzD,OAAhB;AACH,KAHM,CAAP;AAIH,GA5DD;AA6DA;;;;;;;;;;;;;;;AAaAyF,EAAAA,0BAA0B,CAAC1J,SAA3B,CAAqCiM,mBAArC,GAA2D,UAAU1B,GAAV,EAAe;AACtE;AACA,QAAI,CAAClK,SAAS,CAAC+E,KAAV,CAAgBmF,GAAhB,CAAL,EAA2B;AACvB,aAAOC,OAAO,CAACC,MAAR,CAAe,IAAIjK,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BG,WAA1D,CAAf,CAAP;AACH;;AACD,QAAIb,OAAO,GAAG;AACVoB,MAAAA,OAAO,EAAEsG,GADC;AAEV;AACA3F,MAAAA,UAAU,EAAEsH,IAAI,CAACC,IAAL,CAAU,IAAIC,IAAJ,GAAWC,OAAX,KAAuB,IAAjC;AAHF,KAAd;AAKA,WAAO,KAAKlC,oBAAL,CAA0B,KAAKC,iBAAL,EAA1B,EAAoDjK,OAAO,CAACoI,8BAA5D,EAA4F1F,OAA5F,EACFwH,IADE,CACG,UAAU3C,QAAV,EAAoB;AAC1B,aAAOA,QAAQ,CAACzD,OAAhB;AACH,KAHM,CAAP;AAIH,GAdD;AAeA;;;;;;;;;AAOAyF,EAAAA,0BAA0B,CAAC1J,SAA3B,CAAqCsM,gBAArC,GAAwD,UAAUT,UAAV,EAAsB;AAC1E,QAAI,CAACxL,SAAS,CAAC2J,eAAV,CAA0B6B,UAA1B,CAAL,EAA4C;AACxC,aAAOrB,OAAO,CAACC,MAAR,CAAe,IAAIjK,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4B2E,gBAA1D,EAA4E,gDAA5E,CAAf,CAAP;AACH,KAHyE,CAI1E;;;AACA,QAAIrF,OAAO,GAAGtC,WAAW,CAACuL,QAAZ,CAAqBD,UAArB,CAAd,CAL0E,CAM1E;;AACA,QAAI,OAAOhJ,OAAO,CAACmJ,QAAf,KAA4B,WAAhC,EAA6C;AACzCnJ,MAAAA,OAAO,CAACM,QAAR,GAAmBN,OAAO,CAACmJ,QAA3B;AACA,aAAOnJ,OAAO,CAACmJ,QAAf;AACH,KAVyE,CAW1E;;;AACA,QAAI,OAAOnJ,OAAO,CAAC0H,GAAf,KAAuB,WAA3B,EAAwC;AACpC1H,MAAAA,OAAO,CAACoB,OAAR,GAAkBpB,OAAO,CAAC0H,GAA1B;AACA,aAAO1H,OAAO,CAAC0H,GAAf;AACH;;AACD,WAAO,KAAKJ,oBAAL,CAA0B,KAAKC,iBAAL,EAA1B,EAAoDjK,OAAO,CAACqI,8BAA5D,EAA4F3F,OAA5F,EACFwH,IADE,CACG,UAAU3C,QAAV,EAAoB;AAC1B;AACA,aAAOA,QAAQ,CAACzD,OAAhB;AACH,KAJM,CAAP;AAKH,GArBD;AAsBA;;;;;;;;;;;;;;AAYAyF,EAAAA,0BAA0B,CAAC1J,SAA3B,CAAqCuM,kBAArC,GAA0D,UAAU5D,WAAV,EAAuB1F,KAAvB,EAA8BuJ,kBAA9B,EAAkD;AACxG,QAAI3J,OAAO,GAAG;AAAE8F,MAAAA,WAAW,EAAEA,WAAf;AAA4B1F,MAAAA,KAAK,EAAEA,KAAnC;AAA0CwJ,MAAAA,aAAa,EAAE;AAAzD,KAAd,CADwG,CAExG;AACA;;AACA,QAAI,OAAOD,kBAAP,KAA8B,WAA9B,IAA6C7D,WAAW,KAAK,cAAjE,EAAiF;AAC7E,UAAI;AACA,YAAI+D,OAAO,GAAG,IAAI9L,8BAA8B,CAAC+L,yBAAnC,CAA6DH,kBAA7D,CAAd;AACA3J,QAAAA,OAAO,GAAGtC,WAAW,CAACqM,UAAZ,CAAuB/J,OAAvB,EAAgC6J,OAAO,CAACxB,YAAR,EAAhC,CAAV;AACH,OAHD,CAIA,OAAO2B,CAAP,EAAU;AACN,eAAOrC,OAAO,CAACC,MAAR,CAAeoC,CAAf,CAAP;AACH;AACJ;;AACD,WAAO,KAAK1C,oBAAL,CAA0B,KAAKC,iBAAL,EAA1B,EAAoD3B,0BAApD,EAAgF5F,OAAhF,EACFwH,IADE,CACG,UAAU3C,QAAV,EAAoB;AAC1B;AACA,aAAOA,QAAQ,CAACkB,OAAhB;AACH,KAJM,CAAP;AAKH,GAlBD;AAmBA;;;;;;;;AAMAc,EAAAA,0BAA0B,CAAC1J,SAA3B,CAAqC8M,iBAArC,GAAyD,UAAU9J,UAAV,EAAsB;AAC3E,QAAI,CAACnC,aAAa,CAACkM,UAAd,CAAyBC,YAAzB,CAAsChK,UAAtC,CAAL,EAAwD;AACpD,aAAOwH,OAAO,CAACC,MAAR,CAAe,IAAIjK,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BC,mBAA1D,CAAf,CAAP;AACH;;AACD,WAAO,KAAK2G,oBAAL,CAA0B,KAAK8C,0BAAL,EAA1B,EAA6DpE,oBAA7D,EAAmF,EAAnF,EAAuF;AAAE7F,MAAAA,UAAU,EAAEA;AAAd,KAAvF,CAAP;AACH,GALD;AAMA;;;;;;;;;;;;;;;AAaA0G,EAAAA,0BAA0B,CAAC1J,SAA3B,CAAqCkN,mBAArC,GAA2D,UAAUjF,UAAV,EAAsBkB,SAAtB,EAAiC;AACxF,QAAIlB,UAAU,KAAK,KAAK,CAAxB,EAA2B;AAAEA,MAAAA,UAAU,GAAGzG,yCAAb;AAAyD;;AACtF,QAAIqB,OAAO,GAAG;AACVuG,MAAAA,QAAQ,EAAEnB;AADA,KAAd,CAFwF,CAKxF;;AACA,QAAI,OAAOkB,SAAP,KAAqB,WAAzB,EAAsC;AAClCtG,MAAAA,OAAO,CAACsG,SAAR,GAAoBA,SAApB;AACH;;AACD,WAAO,KAAKgB,oBAAL,CAA0B,KAAK8C,0BAAL,EAA1B,EAA6D/D,sBAA7D,EAAqFrG,OAArF,EACFwH,IADE,CACG,UAAU3C,QAAV,EAAoB;AAC1B,UAAI,CAACA,QAAQ,CAACyF,eAAd,EAA+B;AAC3BzF,QAAAA,QAAQ,CAACyF,eAAT,GAA2B,EAA3B;AACA,eAAOzF,QAAQ,CAACK,aAAhB;AACH;;AACD,aAAOL,QAAP;AACH,KAPM,CAAP;AAQH,GAjBD;AAkBA;;;;;;;;AAMAgC,EAAAA,0BAA0B,CAAC1J,SAA3B,CAAqCoN,oBAArC,GAA4D,UAAUpK,UAAV,EAAsB;AAC9E,QAAI,CAACnC,aAAa,CAACkM,UAAd,CAAyBC,YAAzB,CAAsChK,UAAtC,CAAL,EAAwD;AACpD,aAAOwH,OAAO,CAACC,MAAR,CAAe,IAAIjK,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BC,mBAA1D,CAAf,CAAP;AACH;;AACD,WAAO,KAAK2G,oBAAL,CAA0B,KAAK8C,0BAAL,EAA1B,EAA6DlE,uBAA7D,EAAsF,EAAtF,EAA0F;AAAE/F,MAAAA,UAAU,EAAEA;AAAd,KAA1F,EACFqH,IADE,CACG,UAAU3C,QAAV,EAAoB,CAC1B;AACH,KAHM,CAAP;AAIH,GARD;AASA;;;;;;;;;AAOAgC,EAAAA,0BAA0B,CAAC1J,SAA3B,CAAqCqN,oBAArC,GAA4D,UAAUvC,OAAV,EAAmB;AAC3E;AACA,QAAIjI,OAAJ;;AACA,QAAI;AACAA,MAAAA,OAAO,GAAGhC,aAAa,CAACkM,UAAd,CAAyBO,kBAAzB,CAA4CxC,OAA5C,CAAV;AACH,KAFD,CAGA,OAAO+B,CAAP,EAAU;AACN,aAAOrC,OAAO,CAACC,MAAR,CAAeoC,CAAf,CAAP;AACH;;AACD,QAAI7J,UAAU,GAAG8H,OAAO,CAAC9H,UAAzB;AACA,WAAO,KAAKmH,oBAAL,CAA0B,KAAK8C,0BAAL,EAA1B,EAA6DjE,uBAA7D,EAAsFnG,OAAtF,EAA+F;AAAEG,MAAAA,UAAU,EAAEA;AAAd,KAA/F,EACFqH,IADE,CACG,UAAU3C,QAAV,EAAoB;AAC1B,UAAI,CAAC7G,aAAa,CAACkM,UAAd,CAAyBQ,6BAAzB,CAAuD7F,QAAQ,CAACoB,IAAhE,CAAL,EAA4E;AACxE,cAAM,IAAItI,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BqE,cAA1D,EAA0E,0EAA1E,CAAN;AACH;;AACD,aAAOF,QAAP;AACH,KANM,CAAP;AAOH,GAjBD;AAkBA;;;;;;;;;;AAQAgC,EAAAA,0BAA0B,CAAC1J,SAA3B,CAAqCwN,oBAArC,GAA4D,UAAUxK,UAAV,EAAsB8H,OAAtB,EAA+B;AACvF,QAAI,CAACjK,aAAa,CAACkM,UAAd,CAAyBC,YAAzB,CAAsChK,UAAtC,CAAL,EAAwD;AACpD,aAAOwH,OAAO,CAACC,MAAR,CAAe,IAAIjK,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BC,mBAA1D,CAAf,CAAP;AACH,KAHsF,CAIvF;;;AACA,QAAIX,OAAJ;;AACA,QAAI;AACAA,MAAAA,OAAO,GAAGhC,aAAa,CAACkM,UAAd,CAAyBO,kBAAzB,CAA4CxC,OAA5C,EAAqD,IAArD,KAA8D,EAAxE;AACH,KAFD,CAGA,OAAO+B,CAAP,EAAU;AACN,aAAOrC,OAAO,CAACC,MAAR,CAAeoC,CAAf,CAAP;AACH;;AACD,QAAIY,UAAU,GAAG9M,KAAK,CAAC+M,kBAAN,CAAyB7K,OAAzB,CAAjB;AACA,WAAO,KAAKsH,oBAAL,CAA0B,KAAK8C,0BAAL,EAA1B,EAA6DhE,uBAA7D,EAAsFpG,OAAtF,EAA+F;AAAEG,MAAAA,UAAU,EAAEA,UAAd;AAA0ByK,MAAAA,UAAU,EAAEA,UAAU,CAAC9G,IAAX,CAAgB,GAAhB;AAAtC,KAA/F,EACF0D,IADE,CACG,UAAU3C,QAAV,EAAoB;AAC1B,UAAI,CAAC7G,aAAa,CAACkM,UAAd,CAAyBQ,6BAAzB,CAAuD7F,QAAQ,CAACoB,IAAhE,CAAL,EAA4E;AACxE,cAAM,IAAItI,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BqE,cAA1D,EAA0E,sEAA1E,CAAN;AACH;;AACD,aAAOF,QAAP;AACH,KANM,CAAP;AAOH,GApBD;AAqBA;;;;;;;;AAMAgC,EAAAA,0BAA0B,CAAC1J,SAA3B,CAAqC2N,oBAArC,GAA4D,UAAU3K,UAAV,EAAsB;AAC9E,QAAI,CAACnC,aAAa,CAAC+M,UAAd,CAAyBZ,YAAzB,CAAsChK,UAAtC,CAAL,EAAwD;AACpD,aAAOwH,OAAO,CAACC,MAAR,CAAe,IAAIjK,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BC,mBAA1D,CAAf,CAAP;AACH;;AACD,WAAO,KAAK2G,oBAAL,CAA0B,KAAK8C,0BAAL,EAA1B,EAA6D5D,uBAA7D,EAAsF,EAAtF,EAA0F;AAAErG,MAAAA,UAAU,EAAEA;AAAd,KAA1F,CAAP;AACH,GALD;AAMA;;;;;;;;;;;;;;;AAaA0G,EAAAA,0BAA0B,CAAC1J,SAA3B,CAAqC6N,sBAArC,GAA8D,UAAU5F,UAAV,EAAsBkB,SAAtB,EAAiC;AAC3F,QAAIlB,UAAU,KAAK,KAAK,CAAxB,EAA2B;AAAEA,MAAAA,UAAU,GAAGzG,yCAAb;AAAyD;;AACtF,QAAIqB,OAAO,GAAG;AACVuG,MAAAA,QAAQ,EAAEnB;AADA,KAAd,CAF2F,CAK3F;;AACA,QAAI,OAAOkB,SAAP,KAAqB,WAAzB,EAAsC;AAClCtG,MAAAA,OAAO,CAACsG,SAAR,GAAoBA,SAApB;AACH;;AACD,WAAO,KAAKgB,oBAAL,CAA0B,KAAK8C,0BAAL,EAA1B,EAA6DxD,yBAA7D,EAAwF5G,OAAxF,EACFwH,IADE,CACG,UAAU3C,QAAV,EAAoB;AAC1B,UAAI,CAACA,QAAQ,CAACoG,kBAAd,EAAkC;AAC9BpG,QAAAA,QAAQ,CAACoG,kBAAT,GAA8B,EAA9B;AACA,eAAOpG,QAAQ,CAACK,aAAhB;AACH;;AACD,aAAOL,QAAP;AACH,KAPM,CAAP;AAQH,GAjBD;AAkBA;;;;;;;;AAMAgC,EAAAA,0BAA0B,CAAC1J,SAA3B,CAAqC+N,uBAArC,GAA+D,UAAU/K,UAAV,EAAsB;AACjF,QAAI,CAACnC,aAAa,CAAC+M,UAAd,CAAyBZ,YAAzB,CAAsChK,UAAtC,CAAL,EAAwD;AACpD,aAAOwH,OAAO,CAACC,MAAR,CAAe,IAAIjK,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BC,mBAA1D,CAAf,CAAP;AACH;;AACD,WAAO,KAAK2G,oBAAL,CAA0B,KAAK8C,0BAAL,EAA1B,EAA6D3D,0BAA7D,EAAyF,EAAzF,EAA6F;AAAEtG,MAAAA,UAAU,EAAEA;AAAd,KAA7F,EACFqH,IADE,CACG,UAAU3C,QAAV,EAAoB,CAC1B;AACH,KAHM,CAAP;AAIH,GARD;AASA;;;;;;;;;AAOAgC,EAAAA,0BAA0B,CAAC1J,SAA3B,CAAqCgO,uBAArC,GAA+D,UAAUlD,OAAV,EAAmB;AAC9E;AACA,QAAIjI,OAAJ;;AACA,QAAI;AACAA,MAAAA,OAAO,GAAGhC,aAAa,CAAC+M,UAAd,CAAyBN,kBAAzB,CAA4CxC,OAA5C,CAAV;AACH,KAFD,CAGA,OAAO+B,CAAP,EAAU;AACN,aAAOrC,OAAO,CAACC,MAAR,CAAeoC,CAAf,CAAP;AACH;;AACD,QAAI7J,UAAU,GAAG8H,OAAO,CAAC9H,UAAzB;AACA,WAAO,KAAKmH,oBAAL,CAA0B,KAAK8C,0BAAL,EAA1B,EAA6D1D,0BAA7D,EAAyF1G,OAAzF,EAAkG;AAAEG,MAAAA,UAAU,EAAEA;AAAd,KAAlG,EACFqH,IADE,CACG,UAAU3C,QAAV,EAAoB;AAC1B,UAAI,CAAC7G,aAAa,CAAC+M,UAAd,CAAyBL,6BAAzB,CAAuD7F,QAAQ,CAACoB,IAAhE,CAAL,EAA4E;AACxE,cAAM,IAAItI,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BqE,cAA1D,EAA0E,0EAA1E,CAAN;AACH;;AACD,aAAOF,QAAP;AACH,KANM,CAAP;AAOH,GAjBD;AAkBA;;;;;;;;;;AAQAgC,EAAAA,0BAA0B,CAAC1J,SAA3B,CAAqCiO,uBAArC,GAA+D,UAAUjL,UAAV,EAAsB8H,OAAtB,EAA+B;AAC1F,QAAI,CAACjK,aAAa,CAAC+M,UAAd,CAAyBZ,YAAzB,CAAsChK,UAAtC,CAAL,EAAwD;AACpD,aAAOwH,OAAO,CAACC,MAAR,CAAe,IAAIjK,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BC,mBAA1D,CAAf,CAAP;AACH,KAHyF,CAI1F;;;AACA,QAAIX,OAAJ;;AACA,QAAI;AACAA,MAAAA,OAAO,GAAGhC,aAAa,CAAC+M,UAAd,CAAyBN,kBAAzB,CAA4CxC,OAA5C,EAAqD,IAArD,CAAV;AACH,KAFD,CAGA,OAAO+B,CAAP,EAAU;AACN,aAAOrC,OAAO,CAACC,MAAR,CAAeoC,CAAf,CAAP;AACH;;AACD,QAAIY,UAAU,GAAG9M,KAAK,CAAC+M,kBAAN,CAAyB7K,OAAzB,CAAjB;AACA,WAAO,KAAKsH,oBAAL,CAA0B,KAAK8C,0BAAL,EAA1B,EAA6DzD,0BAA7D,EAAyF3G,OAAzF,EAAkG;AAAEG,MAAAA,UAAU,EAAEA,UAAd;AAA0ByK,MAAAA,UAAU,EAAEA,UAAU,CAAC9G,IAAX,CAAgB,GAAhB;AAAtC,KAAlG,EACF0D,IADE,CACG,UAAU3C,QAAV,EAAoB;AAC1B,UAAI,CAAC7G,aAAa,CAAC+M,UAAd,CAAyBL,6BAAzB,CAAuD7F,QAAQ,CAACoB,IAAhE,CAAL,EAA4E;AACxE,cAAM,IAAItI,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BqE,cAA1D,EAA0E,sEAA1E,CAAN;AACH;;AACD,aAAOF,QAAP;AACH,KANM,CAAP;AAOH,GApBD;AAqBA;;;;;;;;;;;AASAgC,EAAAA,0BAA0B,CAAC1J,SAA3B,CAAqCmK,oBAArC,GAA4D,UAAU+D,UAAV,EAAsBC,WAAtB,EAAmCC,WAAnC,EAAgDC,wBAAhD,EAA0E;AAClI,QAAI3L,KAAK,GAAG,IAAZ;;AACA,WAAO8H,OAAO,CAACY,OAAR,GACFf,IADE,CACG,YAAY;AAClB;AACA,UAAIiE,gBAAgB,GAAGH,WAAW,CAACI,mBAAZ,EAAvB;AACAD,MAAAA,gBAAgB,CAACF,WAAD,CAAhB,CAHkB,CAIlB;;AACA,UAAII,GAAG,GAAG;AACNC,QAAAA,MAAM,EAAEN,WAAW,CAACO,aAAZ,EADF;AAENC,QAAAA,GAAG,EAAET,UAAU,CAACjM,MAAX,CAAkBkM,WAAW,CAACS,WAAZ,EAAlB,EAA6CP,wBAA7C,CAFC;AAGNQ,QAAAA,OAAO,EAAE9N,oBAHH;AAIN+N,QAAAA,IAAI,EAAEV,WAJA;AAKNW,QAAAA,OAAO,EAAE/N;AALH,OAAV;AAOA,aAAO0B,KAAK,CAACmH,UAAN,CAAiBmF,IAAjB,CAAsBR,GAAtB,CAAP;AACH,KAdM,EAeFnE,IAfE,CAeG,UAAU3C,QAAV,EAAoB;AAC1B;AACA,UAAIuH,iBAAiB,GAAGd,WAAW,CAACe,oBAAZ,EAAxB;AACAD,MAAAA,iBAAiB,CAACvH,QAAQ,CAACoH,IAAV,CAAjB,CAH0B,CAI1B;;AACA,aAAOpH,QAAQ,CAACoH,IAAhB;AACH,KArBM,EAsBFK,KAtBE,CAsBI,UAAUC,GAAV,EAAe;AACtB,UAAIA,GAAG,YAAY3O,aAAa,CAAC4O,SAAjC,EAA4C;AACxC,YAAInJ,KAAK,GAAGkJ,GAAG,CAAC1H,QAAJ,CAAaoH,IAAzB;AACA,YAAIQ,SAAS,GAAG5F,0BAA0B,CAACK,YAA3B,CAAwC7D,KAAxC,CAAhB;AACA,cAAM1F,OAAO,CAAC8C,iBAAR,CAA0BiM,eAA1B,CAA0CD,SAA1C;AAAqD;AAAcE,QAAAA,SAAnE,EAA8EtJ,KAA9E,CAAN;AACH;;AACD,YAAMkJ,GAAN;AACH,KA7BM,CAAP;AA8BH,GAhCD;AAiCA;;;;;AAGA1F,EAAAA,0BAA0B,CAAC1J,SAA3B,CAAqCoK,iBAArC,GAAyD,YAAY;AACjE,QAAI,CAAC,KAAKqF,cAAV,EAA0B;AACtB,WAAKA,cAAL,GAAsB,KAAKC,iBAAL,EAAtB;AACH;;AACD,WAAO,KAAKD,cAAZ;AACH,GALD;AAMA;;;;;AAGA/F,EAAAA,0BAA0B,CAAC1J,SAA3B,CAAqCiN,0BAArC,GAAkE,YAAY;AAC1E,QAAI,CAAC,KAAK0C,uBAAV,EAAmC;AAC/B,WAAKA,uBAAL,GAA+B,KAAKC,0BAAL,EAA/B;AACH;;AACD,WAAO,KAAKD,uBAAZ;AACH,GALD;;AAMA,SAAOjG,0BAAP;AACH,CAnoB+C,EAAhD;;AAooBAvJ,OAAO,CAACuJ,0BAAR,GAAqCA,0BAArC;AACA;;AACA,IAAImG,UAAU,GAAG,IAAIpP,aAAa,CAAC0G,WAAlB,CAA8B,qBAA9B,EAAqD,KAArD,EACb;AADa,CAEZM,oBAFY,CAES,UAAUC,QAAV,EAAoB;AAC1C;AACA,MAAI,CAACrH,SAAS,CAACgD,gBAAV,CAA2BqE,QAAQ,CAACoB,IAApC,CAAL,EAAgD;AAC5C,UAAM,IAAItI,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BqE,cAA1D,EAA0E,8CAA1E,CAAN;AACH;AACJ,CAPgB,CAAjB;AAQA;;AACA,IAAIkI,aAAa,GAAG,IAAIrP,aAAa,CAAC0G,WAAlB,CAA8B,qBAA9B,EAAqD,QAArD,CAApB;AACA;;AACA,IAAI4I,aAAa,GAAG,IAAItP,aAAa,CAAC0G,WAAlB,CAA8B,6CAA9B,EAA6E,OAA7E,EAChB;AADgB,CAEfM,oBAFe,CAEM,UAAUC,QAAV,EAAoB;AAC1C;AACA,MAAI,CAACrH,SAAS,CAACgD,gBAAV,CAA2BqE,QAAQ,CAACoB,IAApC,CAAD,IACA,CAAChI,QAAQ,CAACkP,MAAT,CAAgBC,2BAAhB,CAA4CvI,QAAQ,CAACoB,IAArD,CADL,EACiE;AAC7D,UAAM,IAAItI,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BqE,cAA1D,EAA0E,iDAA1E,CAAN;AACH;AACJ,CARmB,CAApB;AASA;;AACA,IAAIsI,YAAY,GAAG,IAAIzP,aAAa,CAAC0G,WAAlB,CAA8B,UAA9B,EAA0C,KAA1C,EACf;AADe,CAEdC,mBAFc,CAEM,UAAUvE,OAAV,EAAmB;AACxC;AACA,MAAI,OAAOA,OAAO,CAACsG,SAAf,KAA6B,WAA7B,IACA,CAAC9I,SAAS,CAACgD,gBAAV,CAA2BR,OAAO,CAACsG,SAAnC,CADL,EACoD;AAChD,UAAM,IAAI3I,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4ByE,kBAA1D,CAAN;AACH,GALuC,CAMxC;;;AACA,MAAI,CAAC3H,SAAS,CAACsF,QAAV,CAAmB9C,OAAO,CAACuG,QAA3B,CAAD,IACAvG,OAAO,CAACuG,QAAR,IAAoB,CADpB,IAEAvG,OAAO,CAACuG,QAAR,GAAmBxH,yBAFvB,EAEkD;AAC9C,UAAM,IAAIpB,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4B2E,gBAA1D,EAA4E,sFAC7E,iBAAiBtG,yBAAjB,GAA6C,GADgC,CAA5E,CAAN;AAEH;AACJ,CAfkB,CAAnB;AAgBA;;AACA,IAAIuO,aAAa,GAAG,IAAI1P,aAAa,CAAC0G,WAAlB,CAA8B,UAA9B,EAA0C,MAA1C,EAChB;AADgB,CAEfM,oBAFe,CAEM,UAAUC,QAAV,EAAoB;AAC1C;AACA,MAAI,CAACrH,SAAS,CAACgD,gBAAV,CAA2BqE,QAAQ,CAACoB,IAApC,CAAD,IACA,CAAChI,QAAQ,CAACkP,MAAT,CAAgBC,2BAAhB,CAA4CvI,QAAQ,CAACoB,IAArD,CADL,EACiE;AAC7D,UAAM,IAAItI,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4BqE,cAA1D,EAA0E,qDAA1E,CAAN;AACH;AACJ,CARmB,CAApB;AASA;;;;;;AAKA,IAAIwI,kBAAkB;AAAG;AAAe,UAAU5N,MAAV,EAAkB;AACtDpD,EAAAA,SAAS,CAACgR,kBAAD,EAAqB5N,MAArB,CAAT;AACA;;;;;;;;AAMA,WAAS4N,kBAAT,CAA4BzG,GAA5B,EAAiC;AAC7B,QAAIjH,KAAK,GAAGF,MAAM,CAACG,IAAP,CAAY,IAAZ,EAAkBgH,GAAlB,KAA0B,IAAtC;;AACAjH,IAAAA,KAAK,CAAC2N,yBAAN,GAAkC,IAAIxO,sBAAJ,CAA2BlB,KAAK,CAACiJ,YAAN,CAAmBD,GAAnB,CAA3B,EAAoD,SAApD,CAAlC;AACA,WAAOjH,KAAP;AACH;AACD;;;;;AAGA0N,EAAAA,kBAAkB,CAACpQ,SAAnB,CAA6B0P,iBAA7B,GAAiD,YAAY;AACzD,WAAO,IAAI7N,sBAAJ,CAA2B,KAAKC,SAAhC,EAA2C,IAA3C,CAAP;AACH,GAFD;AAGA;;;;;AAGAsO,EAAAA,kBAAkB,CAACpQ,SAAnB,CAA6B4P,0BAA7B,GAA0D,YAAY;AAClE,WAAO,IAAI/N,sBAAJ,CAA2B,KAAKC,SAAhC,EAA2C,SAA3C,CAAP;AACH,GAFD;AAGA;;;;;;;;AAMAsO,EAAAA,kBAAkB,CAACpQ,SAAnB,CAA6BsQ,SAA7B,GAAyC,UAAU7N,QAAV,EAAoB;AACzD,QAAI,CAACpC,SAAS,CAACgD,gBAAV,CAA2BZ,QAA3B,CAAL,EAA2C;AACvC,aAAO+H,OAAO,CAACC,MAAR,CAAe,IAAIjK,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4B2B,iBAA1D,CAAf,CAAP;AACH;;AACD,WAAO,KAAKiF,oBAAL,CAA0B,KAAKkG,yBAA/B,EAA0DR,UAA1D,EAAsE,EAAtE,EAA0E;AAAEpN,MAAAA,QAAQ,EAAEA;AAAZ,KAA1E,EACF4H,IADE,CACG,UAAU3C,QAAV,EAAoB;AAC1B,aAAOA,QAAP;AACH,KAHM,CAAP;AAIH,GARD;AASA;;;;;;;;;;;;;;;AAaA0I,EAAAA,kBAAkB,CAACpQ,SAAnB,CAA6BuQ,WAA7B,GAA2C,UAAUtI,UAAV,EAAsBkB,SAAtB,EAAiC;AACxE,QAAIlB,UAAU,KAAK,KAAK,CAAxB,EAA2B;AAAEA,MAAAA,UAAU,GAAGrG,yBAAb;AAAyC;;AACtE,QAAIiB,OAAO,GAAG;AACVuG,MAAAA,QAAQ,EAAEnB,UADA;AAEVkB,MAAAA,SAAS,EAAEA;AAFD,KAAd,CAFwE,CAMxE;;AACA,QAAI,OAAOtG,OAAO,CAACsG,SAAf,KAA6B,WAAjC,EAA8C;AAC1C,aAAOtG,OAAO,CAACsG,SAAf;AACH;;AACD,WAAO,KAAKgB,oBAAL,CAA0B,KAAKkG,yBAA/B,EAA0DH,YAA1D,EAAwErN,OAAxE,EACFwH,IADE,CACG,UAAU3C,QAAV,EAAoB;AAC1B,UAAI,CAACA,QAAQ,CAAC8I,OAAd,EAAuB;AACnB9I,QAAAA,QAAQ,CAAC8I,OAAT,GAAmB,EAAnB;AACA,eAAO9I,QAAQ,CAACK,aAAhB;AACH;;AACD,aAAOL,QAAP;AACH,KAPM,CAAP;AAQH,GAlBD;AAmBA;;;;;;;;AAMA0I,EAAAA,kBAAkB,CAACpQ,SAAnB,CAA6ByQ,YAA7B,GAA4C,UAAUhO,QAAV,EAAoB;AAC5D,QAAI,CAACpC,SAAS,CAACgD,gBAAV,CAA2BZ,QAA3B,CAAL,EAA2C;AACvC,aAAO+H,OAAO,CAACC,MAAR,CAAe,IAAIjK,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4B2B,iBAA1D,CAAf,CAAP;AACH;;AACD,WAAO,KAAKiF,oBAAL,CAA0B,KAAKkG,yBAA/B,EAA0DP,aAA1D,EAAyE,EAAzE,EAA6E;AAAErN,MAAAA,QAAQ,EAAEA;AAAZ,KAA7E,EACF4H,IADE,CACG,UAAU3C,QAAV,EAAoB,CAC1B;AACH,KAHM,CAAP;AAIH,GARD;AASA;;;;;;;;AAMA0I,EAAAA,kBAAkB,CAACpQ,SAAnB,CAA6B0Q,YAA7B,GAA4C,UAAUC,aAAV,EAAyB;AACjE,QAAI;AACA;AACA,UAAI9N,OAAO,GAAG/B,QAAQ,CAACkP,MAAT,CAAgB1C,kBAAhB,CAAmCqD,aAAnC,EAAkD,IAAlD,CAAd;AACA,aAAO,KAAKxG,oBAAL,CAA0B,KAAKkG,yBAA/B,EAA0DF,aAA1D,EAAyEtN,OAAzE,EACFwH,IADE,CACG,UAAU3C,QAAV,EAAoB;AAC1B,eAAOA,QAAP;AACH,OAHM,CAAP;AAIH,KAPD,CAQA,OAAOmF,CAAP,EAAU;AACN,aAAOrC,OAAO,CAACC,MAAR,CAAeoC,CAAf,CAAP;AACH;AACJ,GAZD;AAaA;;;;;;;;;AAOAuD,EAAAA,kBAAkB,CAACpQ,SAAnB,CAA6B4Q,YAA7B,GAA4C,UAAUnO,QAAV,EAAoBkO,aAApB,EAAmC;AAC3E,QAAI,CAACtQ,SAAS,CAACgD,gBAAV,CAA2BZ,QAA3B,CAAL,EAA2C;AACvC,aAAO+H,OAAO,CAACC,MAAR,CAAe,IAAIjK,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4B2B,iBAA1D,CAAf,CAAP;AACH;;AACD,QAAI;AACA;AACA,UAAIrC,OAAO,GAAG/B,QAAQ,CAACkP,MAAT,CAAgB1C,kBAAhB,CAAmCqD,aAAnC,EAAkD,KAAlD,CAAd;AACA,UAAIlD,UAAU,GAAG9M,KAAK,CAAC+M,kBAAN,CAAyB7K,OAAzB,CAAjB;AACA,aAAO,KAAKsH,oBAAL,CAA0B,KAAKkG,yBAA/B,EAA0DN,aAA1D,EAAyElN,OAAzE,EAAkF;AAAEJ,QAAAA,QAAQ,EAAEA,QAAZ;AAAsBgL,QAAAA,UAAU,EAAEA,UAAU,CAAC9G,IAAX,CAAgB,GAAhB;AAAlC,OAAlF,EACF0D,IADE,CACG,UAAU3C,QAAV,EAAoB;AAC1B,eAAOA,QAAP;AACH,OAHM,CAAP;AAIH,KARD,CASA,OAAOmF,CAAP,EAAU;AACN,aAAOrC,OAAO,CAACC,MAAR,CAAeoC,CAAf,CAAP;AACH;AACJ,GAhBD;;AAiBA,SAAOuD,kBAAP;AACH,CAnIuC,CAmItC1G,0BAnIsC,CAAxC;;AAoIAvJ,OAAO,CAACiQ,kBAAR,GAA6BA,kBAA7B;AACA;;;;;;AAKA,IAAIS,6BAA6B;AAAG;AAAe,UAAUrO,MAAV,EAAkB;AACjEpD,EAAAA,SAAS,CAACyR,6BAAD,EAAgCrO,MAAhC,CAAT;AACA;;;;;;;;;;AAQA,WAASqO,6BAAT,CAAuClH,GAAvC,EAA4ClH,QAA5C,EAAsD;AAClD,QAAIC,KAAK,GAAGF,MAAM,CAACG,IAAP,CAAY,IAAZ,EAAkBgH,GAAlB,KAA0B,IAAtC;;AACAjH,IAAAA,KAAK,CAACD,QAAN,GAAiBA,QAAjB;AACA,WAAOC,KAAP;AACH;AACD;;;;;AAGAmO,EAAAA,6BAA6B,CAAC7Q,SAA9B,CAAwC0P,iBAAxC,GAA4D,YAAY;AACpE,WAAO,IAAInN,iCAAJ,CAAsC,KAAKT,SAA3C,EAAsD,IAAtD,EAA4D,KAAKW,QAAjE,CAAP;AACH,GAFD;AAGA;;;;;AAGAoO,EAAAA,6BAA6B,CAAC7Q,SAA9B,CAAwC4P,0BAAxC,GAAqE,YAAY;AAC7E,WAAO,IAAIrN,iCAAJ,CAAsC,KAAKT,SAA3C,EAAsD,SAAtD,EAAiE,KAAKW,QAAtE,CAAP;AACH,GAFD;AAGA;;;;;;;;;;;;;;;;;;AAgBAoO,EAAAA,6BAA6B,CAAC7Q,SAA9B,CAAwC6K,aAAxC,GAAwD,UAAUzC,KAAV,EAAiB0C,OAAjB,EAA0B;AAC9E,QAAIpI,KAAK,GAAG,IAAZ,CAD8E,CAE9E;;;AACA0F,IAAAA,KAAK,CAAC9B,OAAN,CAAc,UAAUwK,IAAV,EAAgBC,KAAhB,EAAuB;AACjC,UAAI1Q,SAAS,CAACgD,gBAAV,CAA2ByN,IAAI,CAACrO,QAAhC,KACAqO,IAAI,CAACrO,QAAL,KAAkBC,KAAK,CAACD,QAD5B,EACsC;AAClC,cAAM,IAAIjC,OAAO,CAAC8C,iBAAZ,CAA8B9C,OAAO,CAAC+C,mBAAR,CAA4ByN,qBAA1D,EAAiF,2BAA2BD,KAA3B,GAAmC,iCAAnC,GAAuED,IAAI,CAACrO,QAA5E,GAAuF,IAAxK,CAAN;AACH;AACJ,KALD;AAMA,WAAOD,MAAM,CAACxC,SAAP,CAAiB6K,aAAjB,CAA+BlI,IAA/B,CAAoC,IAApC,EAA0CyF,KAA1C,EAAiD0C,OAAjD,CAAP;AACH,GAVD;;AAWA,SAAO+F,6BAAP;AACH,CAvDkD,CAuDjDnH,0BAvDiD,CAAnD;;AAwDAvJ,OAAO,CAAC0Q,6BAAR,GAAwCA,6BAAxC","sourcesContent":["/*! firebase-admin v8.8.0 */\n\"use strict\";\n/*!\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar validator = require(\"../utils/validator\");\nvar deep_copy_1 = require(\"../utils/deep-copy\");\nvar error_1 = require(\"../utils/error\");\nvar api_request_1 = require(\"../utils/api-request\");\nvar user_import_builder_1 = require(\"./user-import-builder\");\nvar utils = require(\"../utils/index\");\nvar action_code_settings_builder_1 = require(\"./action-code-settings-builder\");\nvar auth_config_1 = require(\"./auth-config\");\nvar tenant_1 = require(\"./tenant\");\n/** Firebase Auth request header. */\nvar FIREBASE_AUTH_HEADER = {\n    'X-Client-Version': 'Node/Admin/8.8.0',\n};\n/** Firebase Auth request timeout duration in milliseconds. */\nvar FIREBASE_AUTH_TIMEOUT = 25000;\n/** List of reserved claims which cannot be provided when creating a custom token. */\nexports.RESERVED_CLAIMS = [\n    'acr', 'amr', 'at_hash', 'aud', 'auth_time', 'azp', 'cnf', 'c_hash', 'exp', 'iat',\n    'iss', 'jti', 'nbf', 'nonce', 'sub', 'firebase',\n];\n/** List of supported email action request types. */\nexports.EMAIL_ACTION_REQUEST_TYPES = [\n    'PASSWORD_RESET', 'VERIFY_EMAIL', 'EMAIL_SIGNIN',\n];\n/** Maximum allowed number of characters in the custom claims payload. */\nvar MAX_CLAIMS_PAYLOAD_SIZE = 1000;\n/** Maximum allowed number of users to batch download at one time. */\nvar MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE = 1000;\n/** Maximum allowed number of users to batch upload at one time. */\nvar MAX_UPLOAD_ACCOUNT_BATCH_SIZE = 1000;\n/** Minimum allowed session cookie duration in seconds (5 minutes). */\nvar MIN_SESSION_COOKIE_DURATION_SECS = 5 * 60;\n/** Maximum allowed session cookie duration in seconds (2 weeks). */\nvar MAX_SESSION_COOKIE_DURATION_SECS = 14 * 24 * 60 * 60;\n/** Maximum allowed number of provider configurations to batch download at one time. */\nvar MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE = 100;\n/** The Firebase Auth backend base URL format. */\nvar FIREBASE_AUTH_BASE_URL_FORMAT = 'https://identitytoolkit.googleapis.com/{version}/projects/{projectId}{api}';\n/** The Firebase Auth backend multi-tenancy base URL format. */\nvar FIREBASE_AUTH_TENANT_URL_FORMAT = FIREBASE_AUTH_BASE_URL_FORMAT.replace('projects/{projectId}', 'projects/{projectId}/tenants/{tenantId}');\n/** Maximum allowed number of tenants to download at one time. */\nvar MAX_LIST_TENANT_PAGE_SIZE = 1000;\n/** Defines a base utility to help with resource URL construction. */\nvar AuthResourceUrlBuilder = /** @class */ (function () {\n    /**\n     * The resource URL builder constructor.\n     *\n     * @param {string} projectId The resource project ID.\n     * @param {string} version The endpoint API version.\n     * @constructor\n     */\n    function AuthResourceUrlBuilder(projectId, version) {\n        if (version === void 0) { version = 'v1'; }\n        this.projectId = projectId;\n        this.version = version;\n        this.urlFormat = FIREBASE_AUTH_BASE_URL_FORMAT;\n    }\n    /**\n     * Returns the resource URL corresponding to the provided parameters.\n     *\n     * @param {string=} api The backend API name.\n     * @param {object=} params The optional additional parameters to substitute in the\n     *     URL path.\n     * @return {string} The corresponding resource URL.\n     */\n    AuthResourceUrlBuilder.prototype.getUrl = function (api, params) {\n        var baseParams = {\n            version: this.version,\n            projectId: this.projectId,\n            api: api || '',\n        };\n        var baseUrl = utils.formatString(this.urlFormat, baseParams);\n        // Substitute additional api related parameters.\n        return utils.formatString(baseUrl, params || {});\n    };\n    return AuthResourceUrlBuilder;\n}());\n/** Tenant aware resource builder utility. */\nvar TenantAwareAuthResourceUrlBuilder = /** @class */ (function (_super) {\n    __extends(TenantAwareAuthResourceUrlBuilder, _super);\n    /**\n     * The tenant aware resource URL builder constructor.\n     *\n     * @param {string} projectId The resource project ID.\n     * @param {string} version The endpoint API version.\n     * @param {string} tenantId The tenant ID.\n     * @constructor\n     */\n    function TenantAwareAuthResourceUrlBuilder(projectId, version, tenantId) {\n        var _this = _super.call(this, projectId, version) || this;\n        _this.projectId = projectId;\n        _this.version = version;\n        _this.tenantId = tenantId;\n        _this.urlFormat = FIREBASE_AUTH_TENANT_URL_FORMAT;\n        return _this;\n    }\n    /**\n     * Returns the resource URL corresponding to the provided parameters.\n     *\n     * @param {string=} api The backend API name.\n     * @param {object=} params The optional additional parameters to substitute in the\n     *     URL path.\n     * @return {string} The corresponding resource URL.\n     */\n    TenantAwareAuthResourceUrlBuilder.prototype.getUrl = function (api, params) {\n        return utils.formatString(_super.prototype.getUrl.call(this, api, params), { tenantId: this.tenantId });\n    };\n    return TenantAwareAuthResourceUrlBuilder;\n}(AuthResourceUrlBuilder));\n/**\n * Validates a providerUserInfo object. All unsupported parameters\n * are removed from the original request. If an invalid field is passed\n * an error is thrown.\n *\n * @param {any} request The providerUserInfo request object.\n */\nfunction validateProviderUserInfo(request) {\n    var validKeys = {\n        rawId: true,\n        providerId: true,\n        email: true,\n        displayName: true,\n        photoUrl: true,\n    };\n    // Remove invalid keys from original request.\n    for (var key in request) {\n        if (!(key in validKeys)) {\n            delete request[key];\n        }\n    }\n    if (!validator.isNonEmptyString(request.providerId)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID);\n    }\n    if (typeof request.displayName !== 'undefined' &&\n        typeof request.displayName !== 'string') {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISPLAY_NAME, \"The provider \\\"displayName\\\" for \\\"\" + request.providerId + \"\\\" must be a valid string.\");\n    }\n    if (!validator.isNonEmptyString(request.rawId)) {\n        // This is called localId on the backend but the developer specifies this as\n        // uid externally. So the error message should use the client facing name.\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID, \"The provider \\\"uid\\\" for \\\"\" + request.providerId + \"\\\" must be a valid non-empty string.\");\n    }\n    // email should be a string and a valid email.\n    if (typeof request.email !== 'undefined' && !validator.isEmail(request.email)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL, \"The provider \\\"email\\\" for \\\"\" + request.providerId + \"\\\" must be a valid email string.\");\n    }\n    // photoUrl should be a URL.\n    if (typeof request.photoUrl !== 'undefined' &&\n        !validator.isURL(request.photoUrl)) {\n        // This is called photoUrl on the backend but the developer specifies this as\n        // photoURL externally. So the error message should use the client facing name.\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHOTO_URL, \"The provider \\\"photoURL\\\" for \\\"\" + request.providerId + \"\\\" must be a valid URL string.\");\n    }\n}\n/**\n * Validates a create/edit request object. All unsupported parameters\n * are removed from the original request. If an invalid field is passed\n * an error is thrown.\n *\n * @param {any} request The create/edit request object.\n * @param {boolean=} uploadAccountRequest Whether to validate as an uploadAccount request.\n */\nfunction validateCreateEditRequest(request, uploadAccountRequest) {\n    if (uploadAccountRequest === void 0) { uploadAccountRequest = false; }\n    // Hash set of whitelisted parameters.\n    var validKeys = {\n        displayName: true,\n        localId: true,\n        email: true,\n        password: true,\n        rawPassword: true,\n        emailVerified: true,\n        photoUrl: true,\n        disabled: true,\n        disableUser: true,\n        deleteAttribute: true,\n        deleteProvider: true,\n        sanityCheck: true,\n        phoneNumber: true,\n        customAttributes: true,\n        validSince: true,\n        // Pass tenantId only for uploadAccount requests.\n        tenantId: uploadAccountRequest,\n        passwordHash: uploadAccountRequest,\n        salt: uploadAccountRequest,\n        createdAt: uploadAccountRequest,\n        lastLoginAt: uploadAccountRequest,\n        providerUserInfo: uploadAccountRequest,\n    };\n    // Remove invalid keys from original request.\n    for (var key in request) {\n        if (!(key in validKeys)) {\n            delete request[key];\n        }\n    }\n    if (typeof request.tenantId !== 'undefined' &&\n        !validator.isNonEmptyString(request.tenantId)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID);\n    }\n    // For any invalid parameter, use the external key name in the error description.\n    // displayName should be a string.\n    if (typeof request.displayName !== 'undefined' &&\n        !validator.isString(request.displayName)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISPLAY_NAME);\n    }\n    if ((typeof request.localId !== 'undefined' || uploadAccountRequest) &&\n        !validator.isUid(request.localId)) {\n        // This is called localId on the backend but the developer specifies this as\n        // uid externally. So the error message should use the client facing name.\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID);\n    }\n    // email should be a string and a valid email.\n    if (typeof request.email !== 'undefined' && !validator.isEmail(request.email)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL);\n    }\n    // phoneNumber should be a string and a valid phone number.\n    if (typeof request.phoneNumber !== 'undefined' &&\n        !validator.isPhoneNumber(request.phoneNumber)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHONE_NUMBER);\n    }\n    // password should be a string and a minimum of 6 chars.\n    if (typeof request.password !== 'undefined' &&\n        !validator.isPassword(request.password)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD);\n    }\n    // rawPassword should be a string and a minimum of 6 chars.\n    if (typeof request.rawPassword !== 'undefined' &&\n        !validator.isPassword(request.rawPassword)) {\n        // This is called rawPassword on the backend but the developer specifies this as\n        // password externally. So the error message should use the client facing name.\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD);\n    }\n    // emailVerified should be a boolean.\n    if (typeof request.emailVerified !== 'undefined' &&\n        typeof request.emailVerified !== 'boolean') {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL_VERIFIED);\n    }\n    // photoUrl should be a URL.\n    if (typeof request.photoUrl !== 'undefined' &&\n        !validator.isURL(request.photoUrl)) {\n        // This is called photoUrl on the backend but the developer specifies this as\n        // photoURL externally. So the error message should use the client facing name.\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHOTO_URL);\n    }\n    // disabled should be a boolean.\n    if (typeof request.disabled !== 'undefined' &&\n        typeof request.disabled !== 'boolean') {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISABLED_FIELD);\n    }\n    // validSince should be a number.\n    if (typeof request.validSince !== 'undefined' &&\n        !validator.isNumber(request.validSince)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TOKENS_VALID_AFTER_TIME);\n    }\n    // createdAt should be a number.\n    if (typeof request.createdAt !== 'undefined' &&\n        !validator.isNumber(request.createdAt)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CREATION_TIME);\n    }\n    // lastSignInAt should be a number.\n    if (typeof request.lastLoginAt !== 'undefined' &&\n        !validator.isNumber(request.lastLoginAt)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_LAST_SIGN_IN_TIME);\n    }\n    // disableUser should be a boolean.\n    if (typeof request.disableUser !== 'undefined' &&\n        typeof request.disableUser !== 'boolean') {\n        // This is called disableUser on the backend but the developer specifies this as\n        // disabled externally. So the error message should use the client facing name.\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISABLED_FIELD);\n    }\n    // customAttributes should be stringified JSON with no blacklisted claims.\n    // The payload should not exceed 1KB.\n    if (typeof request.customAttributes !== 'undefined') {\n        var developerClaims_1;\n        try {\n            developerClaims_1 = JSON.parse(request.customAttributes);\n        }\n        catch (error) {\n            // JSON parsing error. This should never happen as we stringify the claims internally.\n            // However, we still need to check since setAccountInfo via edit requests could pass\n            // this field.\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CLAIMS, error.message);\n        }\n        var invalidClaims_1 = [];\n        // Check for any invalid claims.\n        exports.RESERVED_CLAIMS.forEach(function (blacklistedClaim) {\n            if (developerClaims_1.hasOwnProperty(blacklistedClaim)) {\n                invalidClaims_1.push(blacklistedClaim);\n            }\n        });\n        // Throw an error if an invalid claim is detected.\n        if (invalidClaims_1.length > 0) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.FORBIDDEN_CLAIM, invalidClaims_1.length > 1 ?\n                \"Developer claims \\\"\" + invalidClaims_1.join('\", \"') + \"\\\" are reserved and cannot be specified.\" :\n                \"Developer claim \\\"\" + invalidClaims_1[0] + \"\\\" is reserved and cannot be specified.\");\n        }\n        // Check claims payload does not exceed maxmimum size.\n        if (request.customAttributes.length > MAX_CLAIMS_PAYLOAD_SIZE) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.CLAIMS_TOO_LARGE, \"Developer claims payload should not exceed \" + MAX_CLAIMS_PAYLOAD_SIZE + \" characters.\");\n        }\n    }\n    // passwordHash has to be a base64 encoded string.\n    if (typeof request.passwordHash !== 'undefined' &&\n        !validator.isString(request.passwordHash)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_HASH);\n    }\n    // salt has to be a base64 encoded string.\n    if (typeof request.salt !== 'undefined' &&\n        !validator.isString(request.salt)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_SALT);\n    }\n    // providerUserInfo has to be an array of valid UserInfo requests.\n    if (typeof request.providerUserInfo !== 'undefined' &&\n        !validator.isArray(request.providerUserInfo)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_DATA);\n    }\n    else if (validator.isArray(request.providerUserInfo)) {\n        request.providerUserInfo.forEach(function (providerUserInfoEntry) {\n            validateProviderUserInfo(providerUserInfoEntry);\n        });\n    }\n}\n/** Instantiates the createSessionCookie endpoint settings. */\nexports.FIREBASE_AUTH_CREATE_SESSION_COOKIE = new api_request_1.ApiSettings(':createSessionCookie', 'POST')\n    // Set request validator.\n    .setRequestValidator(function (request) {\n    // Validate the ID token is a non-empty string.\n    if (!validator.isNonEmptyString(request.idToken)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ID_TOKEN);\n    }\n    // Validate the custom session cookie duration.\n    if (!validator.isNumber(request.validDuration) ||\n        request.validDuration < MIN_SESSION_COOKIE_DURATION_SECS ||\n        request.validDuration > MAX_SESSION_COOKIE_DURATION_SECS) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION);\n    }\n})\n    // Set response validator.\n    .setResponseValidator(function (response) {\n    // Response should always contain the session cookie.\n    if (!validator.isNonEmptyString(response.sessionCookie)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR);\n    }\n});\n/** Instantiates the uploadAccount endpoint settings. */\nexports.FIREBASE_AUTH_UPLOAD_ACCOUNT = new api_request_1.ApiSettings('/accounts:batchCreate', 'POST');\n/** Instantiates the downloadAccount endpoint settings. */\nexports.FIREBASE_AUTH_DOWNLOAD_ACCOUNT = new api_request_1.ApiSettings('/accounts:batchGet', 'GET')\n    // Set request validator.\n    .setRequestValidator(function (request) {\n    // Validate next page token.\n    if (typeof request.nextPageToken !== 'undefined' &&\n        !validator.isNonEmptyString(request.nextPageToken)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);\n    }\n    // Validate max results.\n    if (!validator.isNumber(request.maxResults) ||\n        request.maxResults <= 0 ||\n        request.maxResults > MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"Required \\\"maxResults\\\" must be a positive integer that does not exceed \" +\n            (MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE + \".\"));\n    }\n});\n/** Instantiates the getAccountInfo endpoint settings. */\nexports.FIREBASE_AUTH_GET_ACCOUNT_INFO = new api_request_1.ApiSettings('/accounts:lookup', 'POST')\n    // Set request validator.\n    .setRequestValidator(function (request) {\n    if (!request.localId && !request.email && !request.phoneNumber) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifier');\n    }\n})\n    // Set response validator.\n    .setResponseValidator(function (response) {\n    if (!response.users) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.USER_NOT_FOUND);\n    }\n});\n/** Instantiates the deleteAccount endpoint settings. */\nexports.FIREBASE_AUTH_DELETE_ACCOUNT = new api_request_1.ApiSettings('/accounts:delete', 'POST')\n    // Set request validator.\n    .setRequestValidator(function (request) {\n    if (!request.localId) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifier');\n    }\n});\n/** Instantiates the setAccountInfo endpoint settings for updating existing accounts. */\nexports.FIREBASE_AUTH_SET_ACCOUNT_INFO = new api_request_1.ApiSettings('/accounts:update', 'POST')\n    // Set request validator.\n    .setRequestValidator(function (request) {\n    // localId is a required parameter.\n    if (typeof request.localId === 'undefined') {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Server request is missing user identifier');\n    }\n    // Throw error when tenantId is passed in POST body.\n    if (typeof request.tenantId !== 'undefined') {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"tenantId\" is an invalid \"UpdateRequest\" property.');\n    }\n    validateCreateEditRequest(request);\n})\n    // Set response validator.\n    .setResponseValidator(function (response) {\n    // If the localId is not returned, then the request failed.\n    if (!response.localId) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.USER_NOT_FOUND);\n    }\n});\n/**\n * Instantiates the signupNewUser endpoint settings for creating a new user with or without\n * uid being specified. The backend will create a new one if not provided and return it.\n */\nexports.FIREBASE_AUTH_SIGN_UP_NEW_USER = new api_request_1.ApiSettings('/accounts', 'POST')\n    // Set request validator.\n    .setRequestValidator(function (request) {\n    // signupNewUser does not support customAttributes.\n    if (typeof request.customAttributes !== 'undefined') {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"\\\"customAttributes\\\" cannot be set when creating a new user.\");\n    }\n    // signupNewUser does not support validSince.\n    if (typeof request.validSince !== 'undefined') {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"\\\"validSince\\\" cannot be set when creating a new user.\");\n    }\n    // Throw error when tenantId is passed in POST body.\n    if (typeof request.tenantId !== 'undefined') {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"tenantId\" is an invalid \"CreateRequest\" property.');\n    }\n    validateCreateEditRequest(request);\n})\n    // Set response validator.\n    .setResponseValidator(function (response) {\n    // If the localId is not returned, then the request failed.\n    if (!response.localId) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new user');\n    }\n});\nvar FIREBASE_AUTH_GET_OOB_CODE = new api_request_1.ApiSettings('/accounts:sendOobCode', 'POST')\n    // Set request validator.\n    .setRequestValidator(function (request) {\n    if (!validator.isEmail(request.email)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL);\n    }\n    if (exports.EMAIL_ACTION_REQUEST_TYPES.indexOf(request.requestType) === -1) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"\\\"\" + request.requestType + \"\\\" is not a supported email action request type.\");\n    }\n})\n    // Set response validator.\n    .setResponseValidator(function (response) {\n    // If the oobLink is not returned, then the request failed.\n    if (!response.oobLink) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create the email action link');\n    }\n});\n/** Instantiates the retrieve OIDC configuration endpoint settings. */\nvar GET_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings('/oauthIdpConfigs/{providerId}', 'GET')\n    // Set response validator.\n    .setResponseValidator(function (response) {\n    // Response should always contain the OIDC provider resource name.\n    if (!validator.isNonEmptyString(response.name)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to get OIDC configuration');\n    }\n});\n/** Instantiates the delete OIDC configuration endpoint settings. */\nvar DELETE_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings('/oauthIdpConfigs/{providerId}', 'DELETE');\n/** Instantiates the create OIDC configuration endpoint settings. */\nvar CREATE_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings('/oauthIdpConfigs?oauthIdpConfigId={providerId}', 'POST')\n    // Set response validator.\n    .setResponseValidator(function (response) {\n    // Response should always contain the OIDC provider resource name.\n    if (!validator.isNonEmptyString(response.name)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new OIDC configuration');\n    }\n});\n/** Instantiates the update OIDC configuration endpoint settings. */\nvar UPDATE_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings('/oauthIdpConfigs/{providerId}?updateMask={updateMask}', 'PATCH')\n    // Set response validator.\n    .setResponseValidator(function (response) {\n    // Response should always contain the configuration resource name.\n    if (!validator.isNonEmptyString(response.name)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update OIDC configuration');\n    }\n});\n/** Instantiates the list OIDC configuration endpoint settings. */\nvar LIST_OAUTH_IDP_CONFIGS = new api_request_1.ApiSettings('/oauthIdpConfigs', 'GET')\n    // Set request validator.\n    .setRequestValidator(function (request) {\n    // Validate next page token.\n    if (typeof request.pageToken !== 'undefined' &&\n        !validator.isNonEmptyString(request.pageToken)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);\n    }\n    // Validate max results.\n    if (!validator.isNumber(request.pageSize) ||\n        request.pageSize <= 0 ||\n        request.pageSize > MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"Required \\\"maxResults\\\" must be a positive integer that does not exceed \" +\n            (MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE + \".\"));\n    }\n});\n/** Instantiates the retrieve SAML configuration endpoint settings. */\nvar GET_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings('/inboundSamlConfigs/{providerId}', 'GET')\n    // Set response validator.\n    .setResponseValidator(function (response) {\n    // Response should always contain the SAML provider resource name.\n    if (!validator.isNonEmptyString(response.name)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to get SAML configuration');\n    }\n});\n/** Instantiates the delete SAML configuration endpoint settings. */\nvar DELETE_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings('/inboundSamlConfigs/{providerId}', 'DELETE');\n/** Instantiates the create SAML configuration endpoint settings. */\nvar CREATE_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings('/inboundSamlConfigs?inboundSamlConfigId={providerId}', 'POST')\n    // Set response validator.\n    .setResponseValidator(function (response) {\n    // Response should always contain the SAML provider resource name.\n    if (!validator.isNonEmptyString(response.name)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new SAML configuration');\n    }\n});\n/** Instantiates the update SAML configuration endpoint settings. */\nvar UPDATE_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings('/inboundSamlConfigs/{providerId}?updateMask={updateMask}', 'PATCH')\n    // Set response validator.\n    .setResponseValidator(function (response) {\n    // Response should always contain the configuration resource name.\n    if (!validator.isNonEmptyString(response.name)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update SAML configuration');\n    }\n});\n/** Instantiates the list SAML configuration endpoint settings. */\nvar LIST_INBOUND_SAML_CONFIGS = new api_request_1.ApiSettings('/inboundSamlConfigs', 'GET')\n    // Set request validator.\n    .setRequestValidator(function (request) {\n    // Validate next page token.\n    if (typeof request.pageToken !== 'undefined' &&\n        !validator.isNonEmptyString(request.pageToken)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);\n    }\n    // Validate max results.\n    if (!validator.isNumber(request.pageSize) ||\n        request.pageSize <= 0 ||\n        request.pageSize > MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"Required \\\"maxResults\\\" must be a positive integer that does not exceed \" +\n            (MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE + \".\"));\n    }\n});\n/**\n * Class that provides the mechanism to send requests to the Firebase Auth backend endpoints.\n */\nvar AbstractAuthRequestHandler = /** @class */ (function () {\n    /**\n     * @param {FirebaseApp} app The app used to fetch access tokens to sign API requests.\n     * @constructor\n     */\n    function AbstractAuthRequestHandler(app) {\n        if (typeof app !== 'object' || app === null || !('options' in app)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'First argument passed to admin.auth() must be a valid Firebase app instance.');\n        }\n        this.projectId = utils.getProjectId(app);\n        this.httpClient = new api_request_1.AuthorizedHttpClient(app);\n    }\n    /**\n     * @param {any} response The response to check for errors.\n     * @return {string|null} The error code if present; null otherwise.\n     */\n    AbstractAuthRequestHandler.getErrorCode = function (response) {\n        return (validator.isNonNullObject(response) && response.error && response.error.message) || null;\n    };\n    /**\n     * Creates a new Firebase session cookie with the specified duration that can be used for\n     * session management (set as a server side session cookie with custom cookie policy).\n     * The session cookie JWT will have the same payload claims as the provided ID token.\n     *\n     * @param {string} idToken The Firebase ID token to exchange for a session cookie.\n     * @param {number} expiresIn The session cookie duration in milliseconds.\n     *\n     * @return {Promise<string>} A promise that resolves on success with the created session cookie.\n     */\n    AbstractAuthRequestHandler.prototype.createSessionCookie = function (idToken, expiresIn) {\n        var request = {\n            idToken: idToken,\n            // Convert to seconds.\n            validDuration: expiresIn / 1000,\n        };\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_CREATE_SESSION_COOKIE, request)\n            .then(function (response) { return response.sessionCookie; });\n    };\n    /**\n     * Looks up a user by uid.\n     *\n     * @param {string} uid The uid of the user to lookup.\n     * @return {Promise<object>} A promise that resolves with the user information.\n     */\n    AbstractAuthRequestHandler.prototype.getAccountInfoByUid = function (uid) {\n        if (!validator.isUid(uid)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));\n        }\n        var request = {\n            localId: [uid],\n        };\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request);\n    };\n    /**\n     * Looks up a user by email.\n     *\n     * @param {string} email The email of the user to lookup.\n     * @return {Promise<object>} A promise that resolves with the user information.\n     */\n    AbstractAuthRequestHandler.prototype.getAccountInfoByEmail = function (email) {\n        if (!validator.isEmail(email)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL));\n        }\n        var request = {\n            email: [email],\n        };\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request);\n    };\n    /**\n     * Looks up a user by phone number.\n     *\n     * @param {string} phoneNumber The phone number of the user to lookup.\n     * @return {Promise<object>} A promise that resolves with the user information.\n     */\n    AbstractAuthRequestHandler.prototype.getAccountInfoByPhoneNumber = function (phoneNumber) {\n        if (!validator.isPhoneNumber(phoneNumber)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHONE_NUMBER));\n        }\n        var request = {\n            phoneNumber: [phoneNumber],\n        };\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request);\n    };\n    /**\n     * Exports the users (single batch only) with a size of maxResults and starting from\n     * the offset as specified by pageToken.\n     *\n     * @param {number=} maxResults The page size, 1000 if undefined. This is also the maximum\n     *     allowed limit.\n     * @param {string=} pageToken The next page token. If not specified, returns users starting\n     *     without any offset. Users are returned in the order they were created from oldest to\n     *     newest, relative to the page token offset.\n     * @return {Promise<object>} A promise that resolves with the current batch of downloaded\n     *     users and the next page token if available. For the last page, an empty list of users\n     *     and no page token are returned.\n     */\n    AbstractAuthRequestHandler.prototype.downloadAccount = function (maxResults, pageToken) {\n        if (maxResults === void 0) { maxResults = MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE; }\n        // Construct request.\n        var request = {\n            maxResults: maxResults,\n            nextPageToken: pageToken,\n        };\n        // Remove next page token if not provided.\n        if (typeof request.nextPageToken === 'undefined') {\n            delete request.nextPageToken;\n        }\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_DOWNLOAD_ACCOUNT, request)\n            .then(function (response) {\n            // No more users available.\n            if (!response.users) {\n                response.users = [];\n            }\n            return response;\n        });\n    };\n    /**\n     * Imports the list of users provided to Firebase Auth. This is useful when\n     * migrating from an external authentication system without having to use the Firebase CLI SDK.\n     * At most, 1000 users are allowed to be imported one at a time.\n     * When importing a list of password users, UserImportOptions are required to be specified.\n     *\n     * @param {UserImportRecord[]} users The list of user records to import to Firebase Auth.\n     * @param {UserImportOptions=} options The user import options, required when the users provided\n     *     include password credentials.\n     * @return {Promise<UserImportResult>} A promise that resolves when the operation completes\n     *     with the result of the import. This includes the number of successful imports, the number\n     *     of failed uploads and their corresponding errors.\n     */\n    AbstractAuthRequestHandler.prototype.uploadAccount = function (users, options) {\n        // This will throw if any error is detected in the hash options.\n        // For errors in the list of users, this will not throw and will report the errors and the\n        // corresponding user index in the user import generated response below.\n        // No need to validate raw request or raw response as this is done in UserImportBuilder.\n        var userImportBuilder = new user_import_builder_1.UserImportBuilder(users, options, function (userRequest) {\n            // Pass true to validate the uploadAccount specific fields.\n            validateCreateEditRequest(userRequest, true);\n        });\n        var request = userImportBuilder.buildRequest();\n        // Fail quickly if more users than allowed are to be imported.\n        if (validator.isArray(users) && users.length > MAX_UPLOAD_ACCOUNT_BATCH_SIZE) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_USER_COUNT_EXCEEDED, \"A maximum of \" + MAX_UPLOAD_ACCOUNT_BATCH_SIZE + \" users can be imported at once.\");\n        }\n        // If no remaining user in request after client side processing, there is no need\n        // to send the request to the server.\n        if (request.users.length === 0) {\n            return Promise.resolve(userImportBuilder.buildResponse([]));\n        }\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_UPLOAD_ACCOUNT, request)\n            .then(function (response) {\n            // No error object is returned if no error encountered.\n            var failedUploads = (response.error || []);\n            // Rewrite response as UserImportResult and re-insert client previously detected errors.\n            return userImportBuilder.buildResponse(failedUploads);\n        });\n    };\n    /**\n     * Deletes an account identified by a uid.\n     *\n     * @param {string} uid The uid of the user to delete.\n     * @return {Promise<object>} A promise that resolves when the user is deleted.\n     */\n    AbstractAuthRequestHandler.prototype.deleteAccount = function (uid) {\n        if (!validator.isUid(uid)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));\n        }\n        var request = {\n            localId: uid,\n        };\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_DELETE_ACCOUNT, request);\n    };\n    /**\n     * Sets additional developer claims on an existing user identified by provided UID.\n     *\n     * @param {string} uid The user to edit.\n     * @param {object} customUserClaims The developer claims to set.\n     * @return {Promise<string>} A promise that resolves when the operation completes\n     *     with the user id that was edited.\n     */\n    AbstractAuthRequestHandler.prototype.setCustomUserClaims = function (uid, customUserClaims) {\n        // Validate user UID.\n        if (!validator.isUid(uid)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));\n        }\n        else if (!validator.isObject(customUserClaims)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'CustomUserClaims argument must be an object or null.'));\n        }\n        // Delete operation. Replace null with an empty object.\n        if (customUserClaims === null) {\n            customUserClaims = {};\n        }\n        // Construct custom user attribute editting request.\n        var request = {\n            localId: uid,\n            customAttributes: JSON.stringify(customUserClaims),\n        };\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SET_ACCOUNT_INFO, request)\n            .then(function (response) {\n            return response.localId;\n        });\n    };\n    /**\n     * Edits an existing user.\n     *\n     * @param {string} uid The user to edit.\n     * @param {object} properties The properties to set on the user.\n     * @return {Promise<string>} A promise that resolves when the operation completes\n     *     with the user id that was edited.\n     */\n    AbstractAuthRequestHandler.prototype.updateExistingAccount = function (uid, properties) {\n        if (!validator.isUid(uid)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));\n        }\n        else if (!validator.isNonNullObject(properties)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Properties argument must be a non-null object.'));\n        }\n        // Build the setAccountInfo request.\n        var request = deep_copy_1.deepCopy(properties);\n        request.localId = uid;\n        // For deleting displayName or photoURL, these values must be passed as null.\n        // They will be removed from the backend request and an additional parameter\n        // deleteAttribute: ['PHOTO_URL', 'DISPLAY_NAME']\n        // with an array of the parameter names to delete will be passed.\n        // Parameters that are deletable and their deleteAttribute names.\n        // Use client facing names, photoURL instead of photoUrl.\n        var deletableParams = {\n            displayName: 'DISPLAY_NAME',\n            photoURL: 'PHOTO_URL',\n        };\n        // Properties to delete if available.\n        request.deleteAttribute = [];\n        for (var key in deletableParams) {\n            if (request[key] === null) {\n                // Add property identifier to list of attributes to delete.\n                request.deleteAttribute.push(deletableParams[key]);\n                // Remove property from request.\n                delete request[key];\n            }\n        }\n        if (request.deleteAttribute.length === 0) {\n            delete request.deleteAttribute;\n        }\n        // For deleting phoneNumber, this value must be passed as null.\n        // It will be removed from the backend request and an additional parameter\n        // deleteProvider: ['phone'] with an array of providerIds (phone in this case),\n        // will be passed.\n        // Currently this applies to phone provider only.\n        if (request.phoneNumber === null) {\n            request.deleteProvider = ['phone'];\n            delete request.phoneNumber;\n        }\n        else {\n            // Doesn't apply to other providers in admin SDK.\n            delete request.deleteProvider;\n        }\n        // Rewrite photoURL to photoUrl.\n        if (typeof request.photoURL !== 'undefined') {\n            request.photoUrl = request.photoURL;\n            delete request.photoURL;\n        }\n        // Rewrite disabled to disableUser.\n        if (typeof request.disabled !== 'undefined') {\n            request.disableUser = request.disabled;\n            delete request.disabled;\n        }\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SET_ACCOUNT_INFO, request)\n            .then(function (response) {\n            return response.localId;\n        });\n    };\n    /**\n     * Revokes all refresh tokens for the specified user identified by the uid provided.\n     * In addition to revoking all refresh tokens for a user, all ID tokens issued\n     * before revocation will also be revoked on the Auth backend. Any request with an\n     * ID token generated before revocation will be rejected with a token expired error.\n     * Note that due to the fact that the timestamp is stored in seconds, any tokens minted in\n     * the same second as the revocation will still be valid. If there is a chance that a token\n     * was minted in the last second, delay for 1 second before revoking.\n     *\n     * @param {string} uid The user whose tokens are to be revoked.\n     * @return {Promise<string>} A promise that resolves when the operation completes\n     *     successfully with the user id of the corresponding user.\n     */\n    AbstractAuthRequestHandler.prototype.revokeRefreshTokens = function (uid) {\n        // Validate user UID.\n        if (!validator.isUid(uid)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));\n        }\n        var request = {\n            localId: uid,\n            // validSince is in UTC seconds.\n            validSince: Math.ceil(new Date().getTime() / 1000),\n        };\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SET_ACCOUNT_INFO, request)\n            .then(function (response) {\n            return response.localId;\n        });\n    };\n    /**\n     * Create a new user with the properties supplied.\n     *\n     * @param {object} properties The properties to set on the user.\n     * @return {Promise<string>} A promise that resolves when the operation completes\n     *     with the user id that was created.\n     */\n    AbstractAuthRequestHandler.prototype.createNewAccount = function (properties) {\n        if (!validator.isNonNullObject(properties)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'Properties argument must be a non-null object.'));\n        }\n        // Build the signupNewUser request.\n        var request = deep_copy_1.deepCopy(properties);\n        // Rewrite photoURL to photoUrl.\n        if (typeof request.photoURL !== 'undefined') {\n            request.photoUrl = request.photoURL;\n            delete request.photoURL;\n        }\n        // Rewrite uid to localId if it exists.\n        if (typeof request.uid !== 'undefined') {\n            request.localId = request.uid;\n            delete request.uid;\n        }\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SIGN_UP_NEW_USER, request)\n            .then(function (response) {\n            // Return the user id.\n            return response.localId;\n        });\n    };\n    /**\n     * Generates the out of band email action link for the email specified using the action code settings provided.\n     * Returns a promise that resolves with the generated link.\n     *\n     * @param {string} requestType The request type. This could be either used for password reset,\n     *     email verification, email link sign-in.\n     * @param {string} email The email of the user the link is being sent to.\n     * @param {ActionCodeSettings=} actionCodeSettings The optional action code setings which defines whether\n     *     the link is to be handled by a mobile app and the additional state information to be passed in the\n     *     deep link, etc.\n     * @return {Promise<string>} A promise that resolves with the email action link.\n     */\n    AbstractAuthRequestHandler.prototype.getEmailActionLink = function (requestType, email, actionCodeSettings) {\n        var request = { requestType: requestType, email: email, returnOobLink: true };\n        // ActionCodeSettings required for email link sign-in to determine the url where the sign-in will\n        // be completed.\n        if (typeof actionCodeSettings !== 'undefined' || requestType === 'EMAIL_SIGNIN') {\n            try {\n                var builder = new action_code_settings_builder_1.ActionCodeSettingsBuilder(actionCodeSettings);\n                request = deep_copy_1.deepExtend(request, builder.buildRequest());\n            }\n            catch (e) {\n                return Promise.reject(e);\n            }\n        }\n        return this.invokeRequestHandler(this.getAuthUrlBuilder(), FIREBASE_AUTH_GET_OOB_CODE, request)\n            .then(function (response) {\n            // Return the link.\n            return response.oobLink;\n        });\n    };\n    /**\n     * Looks up an OIDC provider configuration by provider ID.\n     *\n     * @param {string} providerId The provider identifier of the configuration to lookup.\n     * @return {Promise<OIDCConfigServerResponse>} A promise that resolves with the provider configuration information.\n     */\n    AbstractAuthRequestHandler.prototype.getOAuthIdpConfig = function (providerId) {\n        if (!auth_config_1.OIDCConfig.isProviderId(providerId)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n        }\n        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), GET_OAUTH_IDP_CONFIG, {}, { providerId: providerId });\n    };\n    /**\n     * Lists the OIDC configurations (single batch only) with a size of maxResults and starting from\n     * the offset as specified by pageToken.\n     *\n     * @param {number=} maxResults The page size, 100 if undefined. This is also the maximum\n     *     allowed limit.\n     * @param {string=} pageToken The next page token. If not specified, returns OIDC configurations\n     *     without any offset. Configurations are returned in the order they were created from oldest to\n     *     newest, relative to the page token offset.\n     * @return {Promise<object>} A promise that resolves with the current batch of downloaded\n     *     OIDC configurations and the next page token if available. For the last page, an empty list of provider\n     *     configuration and no page token are returned.\n     */\n    AbstractAuthRequestHandler.prototype.listOAuthIdpConfigs = function (maxResults, pageToken) {\n        if (maxResults === void 0) { maxResults = MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE; }\n        var request = {\n            pageSize: maxResults,\n        };\n        // Add next page token if provided.\n        if (typeof pageToken !== 'undefined') {\n            request.pageToken = pageToken;\n        }\n        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), LIST_OAUTH_IDP_CONFIGS, request)\n            .then(function (response) {\n            if (!response.oauthIdpConfigs) {\n                response.oauthIdpConfigs = [];\n                delete response.nextPageToken;\n            }\n            return response;\n        });\n    };\n    /**\n     * Deletes an OIDC configuration identified by a providerId.\n     *\n     * @param {string} providerId The identifier of the OIDC configuration to delete.\n     * @return {Promise<void>} A promise that resolves when the OIDC provider is deleted.\n     */\n    AbstractAuthRequestHandler.prototype.deleteOAuthIdpConfig = function (providerId) {\n        if (!auth_config_1.OIDCConfig.isProviderId(providerId)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n        }\n        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), DELETE_OAUTH_IDP_CONFIG, {}, { providerId: providerId })\n            .then(function (response) {\n            // Return nothing.\n        });\n    };\n    /**\n     * Creates a new OIDC provider configuration with the properties provided.\n     *\n     * @param {AuthProviderConfig} options The properties to set on the new OIDC provider configuration to be created.\n     * @return {Promise<OIDCConfigServerResponse>} A promise that resolves with the newly created OIDC\n     *     configuration.\n     */\n    AbstractAuthRequestHandler.prototype.createOAuthIdpConfig = function (options) {\n        // Construct backend request.\n        var request;\n        try {\n            request = auth_config_1.OIDCConfig.buildServerRequest(options);\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n        var providerId = options.providerId;\n        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), CREATE_OAUTH_IDP_CONFIG, request, { providerId: providerId })\n            .then(function (response) {\n            if (!auth_config_1.OIDCConfig.getProviderIdFromResourceName(response.name)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new OIDC provider configuration');\n            }\n            return response;\n        });\n    };\n    /**\n     * Updates an existing OIDC provider configuration with the properties provided.\n     *\n     * @param {string} providerId The provider identifier of the OIDC configuration to update.\n     * @param {OIDCUpdateAuthProviderRequest} options The properties to update on the existing configuration.\n     * @return {Promise<OIDCConfigServerResponse>} A promise that resolves with the modified provider\n     *     configuration.\n     */\n    AbstractAuthRequestHandler.prototype.updateOAuthIdpConfig = function (providerId, options) {\n        if (!auth_config_1.OIDCConfig.isProviderId(providerId)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n        }\n        // Construct backend request.\n        var request;\n        try {\n            request = auth_config_1.OIDCConfig.buildServerRequest(options, true) || {};\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n        var updateMask = utils.generateUpdateMask(request);\n        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), UPDATE_OAUTH_IDP_CONFIG, request, { providerId: providerId, updateMask: updateMask.join(',') })\n            .then(function (response) {\n            if (!auth_config_1.OIDCConfig.getProviderIdFromResourceName(response.name)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update OIDC provider configuration');\n            }\n            return response;\n        });\n    };\n    /**\n     * Looks up an SAML provider configuration by provider ID.\n     *\n     * @param {string} providerId The provider identifier of the configuration to lookup.\n     * @return {Promise<SAMLConfigServerResponse>} A promise that resolves with the provider configuration information.\n     */\n    AbstractAuthRequestHandler.prototype.getInboundSamlConfig = function (providerId) {\n        if (!auth_config_1.SAMLConfig.isProviderId(providerId)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n        }\n        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), GET_INBOUND_SAML_CONFIG, {}, { providerId: providerId });\n    };\n    /**\n     * Lists the SAML configurations (single batch only) with a size of maxResults and starting from\n     * the offset as specified by pageToken.\n     *\n     * @param {number=} maxResults The page size, 100 if undefined. This is also the maximum\n     *     allowed limit.\n     * @param {string=} pageToken The next page token. If not specified, returns SAML configurations starting\n     *     without any offset. Configurations are returned in the order they were created from oldest to\n     *     newest, relative to the page token offset.\n     * @return {Promise<object>} A promise that resolves with the current batch of downloaded\n     *     SAML configurations and the next page token if available. For the last page, an empty list of provider\n     *     configuration and no page token are returned.\n     */\n    AbstractAuthRequestHandler.prototype.listInboundSamlConfigs = function (maxResults, pageToken) {\n        if (maxResults === void 0) { maxResults = MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE; }\n        var request = {\n            pageSize: maxResults,\n        };\n        // Add next page token if provided.\n        if (typeof pageToken !== 'undefined') {\n            request.pageToken = pageToken;\n        }\n        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), LIST_INBOUND_SAML_CONFIGS, request)\n            .then(function (response) {\n            if (!response.inboundSamlConfigs) {\n                response.inboundSamlConfigs = [];\n                delete response.nextPageToken;\n            }\n            return response;\n        });\n    };\n    /**\n     * Deletes a SAML configuration identified by a providerId.\n     *\n     * @param {string} providerId The identifier of the SAML configuration to delete.\n     * @return {Promise<void>} A promise that resolves when the SAML provider is deleted.\n     */\n    AbstractAuthRequestHandler.prototype.deleteInboundSamlConfig = function (providerId) {\n        if (!auth_config_1.SAMLConfig.isProviderId(providerId)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n        }\n        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), DELETE_INBOUND_SAML_CONFIG, {}, { providerId: providerId })\n            .then(function (response) {\n            // Return nothing.\n        });\n    };\n    /**\n     * Creates a new SAML provider configuration with the properties provided.\n     *\n     * @param {AuthProviderConfig} options The properties to set on the new SAML provider configuration to be created.\n     * @return {Promise<SAMLConfigServerResponse>} A promise that resolves with the newly created SAML\n     *     configuration.\n     */\n    AbstractAuthRequestHandler.prototype.createInboundSamlConfig = function (options) {\n        // Construct backend request.\n        var request;\n        try {\n            request = auth_config_1.SAMLConfig.buildServerRequest(options);\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n        var providerId = options.providerId;\n        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), CREATE_INBOUND_SAML_CONFIG, request, { providerId: providerId })\n            .then(function (response) {\n            if (!auth_config_1.SAMLConfig.getProviderIdFromResourceName(response.name)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new SAML provider configuration');\n            }\n            return response;\n        });\n    };\n    /**\n     * Updates an existing SAML provider configuration with the properties provided.\n     *\n     * @param {string} providerId The provider identifier of the SAML configuration to update.\n     * @param {SAMLUpdateAuthProviderRequest} options The properties to update on the existing configuration.\n     * @return {Promise<SAMLConfigServerResponse>} A promise that resolves with the modified provider\n     *     configuration.\n     */\n    AbstractAuthRequestHandler.prototype.updateInboundSamlConfig = function (providerId, options) {\n        if (!auth_config_1.SAMLConfig.isProviderId(providerId)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n        }\n        // Construct backend request.\n        var request;\n        try {\n            request = auth_config_1.SAMLConfig.buildServerRequest(options, true);\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n        var updateMask = utils.generateUpdateMask(request);\n        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), UPDATE_INBOUND_SAML_CONFIG, request, { providerId: providerId, updateMask: updateMask.join(',') })\n            .then(function (response) {\n            if (!auth_config_1.SAMLConfig.getProviderIdFromResourceName(response.name)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update SAML provider configuration');\n            }\n            return response;\n        });\n    };\n    /**\n     * Invokes the request handler based on the API settings object passed.\n     *\n     * @param {AuthResourceUrlBuilder} urlBuilder The URL builder for Auth endpoints.\n     * @param {ApiSettings} apiSettings The API endpoint settings to apply to request and response.\n     * @param {object} requestData The request data.\n     * @param {object=} additionalResourceParams Additional resource related params if needed.\n     * @return {Promise<object>} A promise that resolves with the response.\n     */\n    AbstractAuthRequestHandler.prototype.invokeRequestHandler = function (urlBuilder, apiSettings, requestData, additionalResourceParams) {\n        var _this = this;\n        return Promise.resolve()\n            .then(function () {\n            // Validate request.\n            var requestValidator = apiSettings.getRequestValidator();\n            requestValidator(requestData);\n            // Process request.\n            var req = {\n                method: apiSettings.getHttpMethod(),\n                url: urlBuilder.getUrl(apiSettings.getEndpoint(), additionalResourceParams),\n                headers: FIREBASE_AUTH_HEADER,\n                data: requestData,\n                timeout: FIREBASE_AUTH_TIMEOUT,\n            };\n            return _this.httpClient.send(req);\n        })\n            .then(function (response) {\n            // Validate response.\n            var responseValidator = apiSettings.getResponseValidator();\n            responseValidator(response.data);\n            // Return entire response.\n            return response.data;\n        })\n            .catch(function (err) {\n            if (err instanceof api_request_1.HttpError) {\n                var error = err.response.data;\n                var errorCode = AbstractAuthRequestHandler.getErrorCode(error);\n                throw error_1.FirebaseAuthError.fromServerError(errorCode, /* message */ undefined, error);\n            }\n            throw err;\n        });\n    };\n    /**\n     * @return {AuthResourceUrlBuilder} The current Auth user management resource URL builder.\n     */\n    AbstractAuthRequestHandler.prototype.getAuthUrlBuilder = function () {\n        if (!this.authUrlBuilder) {\n            this.authUrlBuilder = this.newAuthUrlBuilder();\n        }\n        return this.authUrlBuilder;\n    };\n    /**\n     * @return {AuthResourceUrlBuilder} The current project config resource URL builder.\n     */\n    AbstractAuthRequestHandler.prototype.getProjectConfigUrlBuilder = function () {\n        if (!this.projectConfigUrlBuilder) {\n            this.projectConfigUrlBuilder = this.newProjectConfigUrlBuilder();\n        }\n        return this.projectConfigUrlBuilder;\n    };\n    return AbstractAuthRequestHandler;\n}());\nexports.AbstractAuthRequestHandler = AbstractAuthRequestHandler;\n/** Instantiates the getTenant endpoint settings. */\nvar GET_TENANT = new api_request_1.ApiSettings('/tenants/{tenantId}', 'GET')\n    // Set response validator.\n    .setResponseValidator(function (response) {\n    // Response should always contain at least the tenant name.\n    if (!validator.isNonEmptyString(response.name)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to get tenant');\n    }\n});\n/** Instantiates the deleteTenant endpoint settings. */\nvar DELETE_TENANT = new api_request_1.ApiSettings('/tenants/{tenantId}', 'DELETE');\n/** Instantiates the updateTenant endpoint settings. */\nvar UPDATE_TENANT = new api_request_1.ApiSettings('/tenants/{tenantId}?updateMask={updateMask}', 'PATCH')\n    // Set response validator.\n    .setResponseValidator(function (response) {\n    // Response should always contain at least the tenant name.\n    if (!validator.isNonEmptyString(response.name) ||\n        !tenant_1.Tenant.getTenantIdFromResourceName(response.name)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to update tenant');\n    }\n});\n/** Instantiates the listTenants endpoint settings. */\nvar LIST_TENANTS = new api_request_1.ApiSettings('/tenants', 'GET')\n    // Set request validator.\n    .setRequestValidator(function (request) {\n    // Validate next page token.\n    if (typeof request.pageToken !== 'undefined' &&\n        !validator.isNonEmptyString(request.pageToken)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);\n    }\n    // Validate max results.\n    if (!validator.isNumber(request.pageSize) ||\n        request.pageSize <= 0 ||\n        request.pageSize > MAX_LIST_TENANT_PAGE_SIZE) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"Required \\\"maxResults\\\" must be a positive non-zero number that does not exceed \" +\n            (\"the allowed \" + MAX_LIST_TENANT_PAGE_SIZE + \".\"));\n    }\n});\n/** Instantiates the createTenant endpoint settings. */\nvar CREATE_TENANT = new api_request_1.ApiSettings('/tenants', 'POST')\n    // Set response validator.\n    .setResponseValidator(function (response) {\n    // Response should always contain at least the tenant name.\n    if (!validator.isNonEmptyString(response.name) ||\n        !tenant_1.Tenant.getTenantIdFromResourceName(response.name)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Unable to create new tenant');\n    }\n});\n/**\n * Utility for sending requests to Auth server that are Auth instance related. This includes user and\n * tenant management related APIs. This extends the BaseFirebaseAuthRequestHandler class and defines\n * additional tenant management related APIs.\n */\nvar AuthRequestHandler = /** @class */ (function (_super) {\n    __extends(AuthRequestHandler, _super);\n    /**\n     * The FirebaseAuthRequestHandler constructor used to initialize an instance using a FirebaseApp.\n     *\n     * @param {FirebaseApp} app The app used to fetch access tokens to sign API requests.\n     * @constructor.\n     */\n    function AuthRequestHandler(app) {\n        var _this = _super.call(this, app) || this;\n        _this.tenantMgmtResourceBuilder = new AuthResourceUrlBuilder(utils.getProjectId(app), 'v2beta1');\n        return _this;\n    }\n    /**\n     * @return {AuthResourceUrlBuilder} A new Auth user management resource URL builder instance.\n     */\n    AuthRequestHandler.prototype.newAuthUrlBuilder = function () {\n        return new AuthResourceUrlBuilder(this.projectId, 'v1');\n    };\n    /**\n     * @return {AuthResourceUrlBuilder} A new project config resource URL builder instance.\n     */\n    AuthRequestHandler.prototype.newProjectConfigUrlBuilder = function () {\n        return new AuthResourceUrlBuilder(this.projectId, 'v2beta1');\n    };\n    /**\n     * Looks up a tenant by tenant ID.\n     *\n     * @param {string} tenantId The tenant identifier of the tenant to lookup.\n     * @return {Promise<TenantServerResponse>} A promise that resolves with the tenant information.\n     */\n    AuthRequestHandler.prototype.getTenant = function (tenantId) {\n        if (!validator.isNonEmptyString(tenantId)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID));\n        }\n        return this.invokeRequestHandler(this.tenantMgmtResourceBuilder, GET_TENANT, {}, { tenantId: tenantId })\n            .then(function (response) {\n            return response;\n        });\n    };\n    /**\n     * Exports the tenants (single batch only) with a size of maxResults and starting from\n     * the offset as specified by pageToken.\n     *\n     * @param {number=} maxResults The page size, 1000 if undefined. This is also the maximum\n     *     allowed limit.\n     * @param {string=} pageToken The next page token. If not specified, returns tenants starting\n     *     without any offset. Tenants are returned in the order they were created from oldest to\n     *     newest, relative to the page token offset.\n     * @return {Promise<object>} A promise that resolves with the current batch of downloaded\n     *     tenants and the next page token if available. For the last page, an empty list of tenants\n     *     and no page token are returned.\n     */\n    AuthRequestHandler.prototype.listTenants = function (maxResults, pageToken) {\n        if (maxResults === void 0) { maxResults = MAX_LIST_TENANT_PAGE_SIZE; }\n        var request = {\n            pageSize: maxResults,\n            pageToken: pageToken,\n        };\n        // Remove next page token if not provided.\n        if (typeof request.pageToken === 'undefined') {\n            delete request.pageToken;\n        }\n        return this.invokeRequestHandler(this.tenantMgmtResourceBuilder, LIST_TENANTS, request)\n            .then(function (response) {\n            if (!response.tenants) {\n                response.tenants = [];\n                delete response.nextPageToken;\n            }\n            return response;\n        });\n    };\n    /**\n     * Deletes a tenant identified by a tenantId.\n     *\n     * @param {string} tenantId The identifier of the tenant to delete.\n     * @return {Promise<void>} A promise that resolves when the tenant is deleted.\n     */\n    AuthRequestHandler.prototype.deleteTenant = function (tenantId) {\n        if (!validator.isNonEmptyString(tenantId)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID));\n        }\n        return this.invokeRequestHandler(this.tenantMgmtResourceBuilder, DELETE_TENANT, {}, { tenantId: tenantId })\n            .then(function (response) {\n            // Return nothing.\n        });\n    };\n    /**\n     * Creates a new tenant with the properties provided.\n     *\n     * @param {TenantOptions} tenantOptions The properties to set on the new tenant to be created.\n     * @return {Promise<TenantServerResponse>} A promise that resolves with the newly created tenant object.\n     */\n    AuthRequestHandler.prototype.createTenant = function (tenantOptions) {\n        try {\n            // Construct backend request.\n            var request = tenant_1.Tenant.buildServerRequest(tenantOptions, true);\n            return this.invokeRequestHandler(this.tenantMgmtResourceBuilder, CREATE_TENANT, request)\n                .then(function (response) {\n                return response;\n            });\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n    };\n    /**\n     * Updates an existing tenant with the properties provided.\n     *\n     * @param {string} tenantId The tenant identifier of the tenant to update.\n     * @param {TenantOptions} tenantOptions The properties to update on the existing tenant.\n     * @return {Promise<TenantServerResponse>} A promise that resolves with the modified tenant object.\n     */\n    AuthRequestHandler.prototype.updateTenant = function (tenantId, tenantOptions) {\n        if (!validator.isNonEmptyString(tenantId)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID));\n        }\n        try {\n            // Construct backend request.\n            var request = tenant_1.Tenant.buildServerRequest(tenantOptions, false);\n            var updateMask = utils.generateUpdateMask(request);\n            return this.invokeRequestHandler(this.tenantMgmtResourceBuilder, UPDATE_TENANT, request, { tenantId: tenantId, updateMask: updateMask.join(',') })\n                .then(function (response) {\n                return response;\n            });\n        }\n        catch (e) {\n            return Promise.reject(e);\n        }\n    };\n    return AuthRequestHandler;\n}(AbstractAuthRequestHandler));\nexports.AuthRequestHandler = AuthRequestHandler;\n/**\n * Utility for sending requests to Auth server that are tenant Auth instance related. This includes user\n * management related APIs for specified tenants.\n * This extends the BaseFirebaseAuthRequestHandler class.\n */\nvar TenantAwareAuthRequestHandler = /** @class */ (function (_super) {\n    __extends(TenantAwareAuthRequestHandler, _super);\n    /**\n     * The FirebaseTenantRequestHandler constructor used to initialize an instance using a\n     * FirebaseApp and a tenant ID.\n     *\n     * @param {FirebaseApp} app The app used to fetch access tokens to sign API requests.\n     * @param {string} tenantId The request handler's tenant ID.\n     * @constructor\n     */\n    function TenantAwareAuthRequestHandler(app, tenantId) {\n        var _this = _super.call(this, app) || this;\n        _this.tenantId = tenantId;\n        return _this;\n    }\n    /**\n     * @return {AuthResourceUrlBuilder} A new Auth user management resource URL builder instance.\n     */\n    TenantAwareAuthRequestHandler.prototype.newAuthUrlBuilder = function () {\n        return new TenantAwareAuthResourceUrlBuilder(this.projectId, 'v1', this.tenantId);\n    };\n    /**\n     * @return {AuthResourceUrlBuilder} A new project config resource URL builder instance.\n     */\n    TenantAwareAuthRequestHandler.prototype.newProjectConfigUrlBuilder = function () {\n        return new TenantAwareAuthResourceUrlBuilder(this.projectId, 'v2beta1', this.tenantId);\n    };\n    /**\n     * Imports the list of users provided to Firebase Auth. This is useful when\n     * migrating from an external authentication system without having to use the Firebase CLI SDK.\n     * At most, 1000 users are allowed to be imported one at a time.\n     * When importing a list of password users, UserImportOptions are required to be specified.\n     *\n     * Overrides the superclass methods by adding an additional check to match tenant IDs of\n     * imported user records if present.\n     *\n     * @param {UserImportRecord[]} users The list of user records to import to Firebase Auth.\n     * @param {UserImportOptions=} options The user import options, required when the users provided\n     *     include password credentials.\n     * @return {Promise<UserImportResult>} A promise that resolves when the operation completes\n     *     with the result of the import. This includes the number of successful imports, the number\n     *     of failed uploads and their corresponding errors.\n     */\n    TenantAwareAuthRequestHandler.prototype.uploadAccount = function (users, options) {\n        var _this = this;\n        // Add additional check to match tenant ID of imported user records.\n        users.forEach(function (user, index) {\n            if (validator.isNonEmptyString(user.tenantId) &&\n                user.tenantId !== _this.tenantId) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISMATCHING_TENANT_ID, \"UserRecord of index \\\"\" + index + \"\\\" has mismatching tenant ID \\\"\" + user.tenantId + \"\\\"\");\n            }\n        });\n        return _super.prototype.uploadAccount.call(this, users, options);\n    };\n    return TenantAwareAuthRequestHandler;\n}(AbstractAuthRequestHandler));\nexports.TenantAwareAuthRequestHandler = TenantAwareAuthRequestHandler;\n"]},"metadata":{},"sourceType":"script"}