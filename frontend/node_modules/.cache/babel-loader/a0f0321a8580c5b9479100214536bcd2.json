{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst url_1 = require(\"url\");\n\nconst util_1 = require(\"./util\");\n/**\n * Returns the name of the base class (ignoring Object).\n *\n * @private\n * @param value The object whose base class name to extract.\n * @returns The name of the base class constructor or \"Object\" if value does not\n * extend a custom class.\n */\n\n\nfunction extractBaseClassName(value) {\n  let constructorName = 'Object';\n\n  while (Object.getPrototypeOf(value) !== Object.prototype) {\n    value = Object.getPrototypeOf(value);\n    constructorName = value.constructor.name;\n  }\n\n  return constructorName;\n}\n/**\n * Generates an error message to use with custom objects that cannot be\n * serialized.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The value that failed serialization.\n * @param path The field path that the object is assigned to.\n */\n\n\nfunction customObjectMessage(arg, value, path) {\n  const fieldPathMessage = path ? ` (found in field ${path})` : '';\n\n  if (util_1.isObject(value)) {\n    // We use the base class name as the type name as the sentinel classes\n    // returned by the public FieldValue API are subclasses of FieldValue. By\n    // using the base name, we reduce the number of special cases below.\n    const typeName = extractBaseClassName(value);\n\n    switch (typeName) {\n      case 'DocumentReference':\n      case 'FieldPath':\n      case 'FieldValue':\n      case 'GeoPoint':\n      case 'Timestamp':\n        return `${invalidArgumentMessage(arg, 'Firestore document')} Detected an object of type \"${typeName}\" that doesn't match the ` + `expected instance${fieldPathMessage}. Please ensure that the ` + 'Firestore types you are using are from the same NPM package.)';\n\n      case 'Object':\n        return `${invalidArgumentMessage(arg, 'Firestore document')} Invalid use of type \"${typeof value}\" as a Firestore argument${fieldPathMessage}.`;\n\n      default:\n        return `${invalidArgumentMessage(arg, 'Firestore document')} Couldn't serialize object of type \"${typeName}\"${fieldPathMessage}. Firestore doesn't support JavaScript ` + 'objects with custom prototypes (i.e. objects that were created ' + 'via the \"new\" operator).';\n    }\n  } else {\n    return `${invalidArgumentMessage(arg, 'Firestore document')} Input is not a plain JavaScript object${fieldPathMessage}.`;\n  }\n}\n\nexports.customObjectMessage = customObjectMessage;\n/**\n * Validates that 'value' is a function.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the function can be omitted.\n */\n\nfunction validateFunction(arg, value, options) {\n  if (!validateOptional(value, options)) {\n    if (!util_1.isFunction(value)) {\n      throw new Error(invalidArgumentMessage(arg, 'function'));\n    }\n  }\n}\n\nexports.validateFunction = validateFunction;\n/**\n * Validates that 'value' is an object.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the object can be omitted.\n */\n\nfunction validateObject(arg, value, options) {\n  if (!validateOptional(value, options)) {\n    if (!util_1.isObject(value)) {\n      throw new Error(invalidArgumentMessage(arg, 'object'));\n    }\n  }\n}\n\nexports.validateObject = validateObject;\n/**\n * Validates that 'value' is a string.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the string can be omitted.\n */\n\nfunction validateString(arg, value, options) {\n  if (!validateOptional(value, options)) {\n    if (typeof value !== 'string') {\n      throw new Error(invalidArgumentMessage(arg, 'string'));\n    }\n  }\n}\n\nexports.validateString = validateString;\n/**\n * Validates that 'value' is a host.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the host can be omitted.\n */\n\nfunction validateHost(arg, value, options) {\n  if (!validateOptional(value, options)) {\n    validateString(arg, value);\n    const urlString = `http://${value}/`;\n    let parsed;\n\n    try {\n      parsed = new url_1.URL(urlString);\n    } catch (e) {\n      throw new Error(invalidArgumentMessage(arg, 'host'));\n    }\n\n    if (parsed.search !== '' || parsed.pathname !== '/' || parsed.username !== '') {\n      throw new Error(invalidArgumentMessage(arg, 'host'));\n    }\n  }\n}\n\nexports.validateHost = validateHost;\n/**\n * Validates that 'value' is a boolean.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the boolean can be omitted.\n */\n\nfunction validateBoolean(arg, value, options) {\n  if (!validateOptional(value, options)) {\n    if (typeof value !== 'boolean') {\n      throw new Error(invalidArgumentMessage(arg, 'boolean'));\n    }\n  }\n}\n\nexports.validateBoolean = validateBoolean;\n/**\n * Validates that 'value' is a number.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the number can be omitted.\n */\n\nfunction validateNumber(arg, value, options) {\n  const min = options !== undefined && options.minValue !== undefined ? options.minValue : -Infinity;\n  const max = options !== undefined && options.maxValue !== undefined ? options.maxValue : Infinity;\n\n  if (!validateOptional(value, options)) {\n    if (typeof value !== 'number' || isNaN(value)) {\n      throw new Error(invalidArgumentMessage(arg, 'number'));\n    } else if (value < min || value > max) {\n      throw new Error(`${formatArgumentName(arg)} must be within [${min}, ${max}] inclusive, but was: ${value}`);\n    }\n  }\n}\n\nexports.validateNumber = validateNumber;\n/**\n * Validates that 'value' is a integer.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the integer can be omitted.\n */\n\nfunction validateInteger(arg, value, options) {\n  const min = options !== undefined && options.minValue !== undefined ? options.minValue : -Infinity;\n  const max = options !== undefined && options.maxValue !== undefined ? options.maxValue : Infinity;\n\n  if (!validateOptional(value, options)) {\n    if (typeof value !== 'number' || isNaN(value) || value % 1 !== 0) {\n      throw new Error(invalidArgumentMessage(arg, 'integer'));\n    } else if (value < min || value > max) {\n      throw new Error(`${formatArgumentName(arg)} must be within [${min}, ${max}] inclusive, but was: ${value}`);\n    }\n  }\n}\n\nexports.validateInteger = validateInteger;\n/**\n * Generates an error message to use with invalid arguments.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param expectedType The expected input type.\n */\n\nfunction invalidArgumentMessage(arg, expectedType) {\n  return `${formatArgumentName(arg)} is not a valid ${expectedType}.`;\n}\n\nexports.invalidArgumentMessage = invalidArgumentMessage;\n/**\n * Enforces the 'options.optional' constraint for 'value'.\n *\n * @private\n * @param value The input to validate.\n * @param options Whether the function can be omitted.\n * @return Whether the object is omitted and is allowed to be omitted.\n */\n\nfunction validateOptional(value, options) {\n  return value === undefined && options !== undefined && options.optional === true;\n}\n\nexports.validateOptional = validateOptional;\n/**\n * Formats the given word as plural conditionally given the preceding number.\n *\n * @private\n * @param num The number to use for formatting.\n * @param str The string to format.\n */\n\nfunction formatPlural(num, str) {\n  return `${num} ${str}` + (num === 1 ? '' : 's');\n}\n/**\n * Creates a descriptive name for the provided argument name or index.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @return Either the argument name or its index description.\n */\n\n\nfunction formatArgumentName(arg) {\n  return typeof arg === 'string' ? `Value for argument \"${arg}\"` : `Element at index ${arg}`;\n}\n/**\n * Verifies that 'args' has at least 'minSize' elements.\n *\n * @private\n * @param funcName The function name to use in the error message.\n * @param args The array (or array-like structure) to verify.\n * @param minSize The minimum number of elements to enforce.\n * @throws if the expectation is not met.\n */\n\n\nfunction validateMinNumberOfArguments(funcName, args, minSize) {\n  if (args.length < minSize) {\n    throw new Error(`Function \"${funcName}()\" requires at least ` + `${formatPlural(minSize, 'argument')}.`);\n  }\n}\n\nexports.validateMinNumberOfArguments = validateMinNumberOfArguments;\n/**\n * Verifies that 'args' has at most 'maxSize' elements.\n *\n * @private\n * @param funcName The function name to use in the error message.\n * @param args The array (or array-like structure) to verify.\n * @param maxSize The maximum number of elements to enforce.\n * @throws if the expectation is not met.\n */\n\nfunction validateMaxNumberOfArguments(funcName, args, maxSize) {\n  if (args.length > maxSize) {\n    throw new Error(`Function \"${funcName}()\" accepts at most ` + `${formatPlural(maxSize, 'argument')}.`);\n  }\n}\n\nexports.validateMaxNumberOfArguments = validateMaxNumberOfArguments;\n/**\n * Validates that the provided named option equals one of the expected values.\n *\n * @param arg The argument name or argument index (for varargs methods).).\n * @param value The input to validate.\n * @param allowedValues A list of expected values.\n * @param options Whether the input can be omitted.\n * @private\n */\n\nfunction validateEnumValue(arg, value, allowedValues, options) {\n  if (!validateOptional(value, options)) {\n    const expectedDescription = [];\n\n    for (const allowed of allowedValues) {\n      if (allowed === value) {\n        return;\n      }\n\n      expectedDescription.push(allowed);\n    }\n\n    throw new Error(`${formatArgumentName(arg)} is invalid. Acceptable values are: ${expectedDescription.join(', ')}`);\n  }\n}\n\nexports.validateEnumValue = validateEnumValue;","map":{"version":3,"sources":["/home/strider/Desktop/github/klaviyo-weather-powered-email/frontend/node_modules/@google-cloud/firestore/build/src/validate.js"],"names":["Object","defineProperty","exports","value","url_1","require","util_1","extractBaseClassName","constructorName","getPrototypeOf","prototype","constructor","name","customObjectMessage","arg","path","fieldPathMessage","isObject","typeName","invalidArgumentMessage","validateFunction","options","validateOptional","isFunction","Error","validateObject","validateString","validateHost","urlString","parsed","URL","e","search","pathname","username","validateBoolean","validateNumber","min","undefined","minValue","Infinity","max","maxValue","isNaN","formatArgumentName","validateInteger","expectedType","optional","formatPlural","num","str","validateMinNumberOfArguments","funcName","args","minSize","length","validateMaxNumberOfArguments","maxSize","validateEnumValue","allowedValues","expectedDescription","allowed","push","join"],"mappings":"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","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst url_1 = require(\"url\");\nconst util_1 = require(\"./util\");\n/**\n * Returns the name of the base class (ignoring Object).\n *\n * @private\n * @param value The object whose base class name to extract.\n * @returns The name of the base class constructor or \"Object\" if value does not\n * extend a custom class.\n */\nfunction extractBaseClassName(value) {\n    let constructorName = 'Object';\n    while (Object.getPrototypeOf(value) !== Object.prototype) {\n        value = Object.getPrototypeOf(value);\n        constructorName = value.constructor.name;\n    }\n    return constructorName;\n}\n/**\n * Generates an error message to use with custom objects that cannot be\n * serialized.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The value that failed serialization.\n * @param path The field path that the object is assigned to.\n */\nfunction customObjectMessage(arg, value, path) {\n    const fieldPathMessage = path ? ` (found in field ${path})` : '';\n    if (util_1.isObject(value)) {\n        // We use the base class name as the type name as the sentinel classes\n        // returned by the public FieldValue API are subclasses of FieldValue. By\n        // using the base name, we reduce the number of special cases below.\n        const typeName = extractBaseClassName(value);\n        switch (typeName) {\n            case 'DocumentReference':\n            case 'FieldPath':\n            case 'FieldValue':\n            case 'GeoPoint':\n            case 'Timestamp':\n                return (`${invalidArgumentMessage(arg, 'Firestore document')} Detected an object of type \"${typeName}\" that doesn't match the ` +\n                    `expected instance${fieldPathMessage}. Please ensure that the ` +\n                    'Firestore types you are using are from the same NPM package.)');\n            case 'Object':\n                return `${invalidArgumentMessage(arg, 'Firestore document')} Invalid use of type \"${typeof value}\" as a Firestore argument${fieldPathMessage}.`;\n            default:\n                return (`${invalidArgumentMessage(arg, 'Firestore document')} Couldn't serialize object of type \"${typeName}\"${fieldPathMessage}. Firestore doesn't support JavaScript ` +\n                    'objects with custom prototypes (i.e. objects that were created ' +\n                    'via the \"new\" operator).');\n        }\n    }\n    else {\n        return `${invalidArgumentMessage(arg, 'Firestore document')} Input is not a plain JavaScript object${fieldPathMessage}.`;\n    }\n}\nexports.customObjectMessage = customObjectMessage;\n/**\n * Validates that 'value' is a function.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the function can be omitted.\n */\nfunction validateFunction(arg, value, options) {\n    if (!validateOptional(value, options)) {\n        if (!util_1.isFunction(value)) {\n            throw new Error(invalidArgumentMessage(arg, 'function'));\n        }\n    }\n}\nexports.validateFunction = validateFunction;\n/**\n * Validates that 'value' is an object.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the object can be omitted.\n */\nfunction validateObject(arg, value, options) {\n    if (!validateOptional(value, options)) {\n        if (!util_1.isObject(value)) {\n            throw new Error(invalidArgumentMessage(arg, 'object'));\n        }\n    }\n}\nexports.validateObject = validateObject;\n/**\n * Validates that 'value' is a string.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the string can be omitted.\n */\nfunction validateString(arg, value, options) {\n    if (!validateOptional(value, options)) {\n        if (typeof value !== 'string') {\n            throw new Error(invalidArgumentMessage(arg, 'string'));\n        }\n    }\n}\nexports.validateString = validateString;\n/**\n * Validates that 'value' is a host.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the host can be omitted.\n */\nfunction validateHost(arg, value, options) {\n    if (!validateOptional(value, options)) {\n        validateString(arg, value);\n        const urlString = `http://${value}/`;\n        let parsed;\n        try {\n            parsed = new url_1.URL(urlString);\n        }\n        catch (e) {\n            throw new Error(invalidArgumentMessage(arg, 'host'));\n        }\n        if (parsed.search !== '' ||\n            parsed.pathname !== '/' ||\n            parsed.username !== '') {\n            throw new Error(invalidArgumentMessage(arg, 'host'));\n        }\n    }\n}\nexports.validateHost = validateHost;\n/**\n * Validates that 'value' is a boolean.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the boolean can be omitted.\n */\nfunction validateBoolean(arg, value, options) {\n    if (!validateOptional(value, options)) {\n        if (typeof value !== 'boolean') {\n            throw new Error(invalidArgumentMessage(arg, 'boolean'));\n        }\n    }\n}\nexports.validateBoolean = validateBoolean;\n/**\n * Validates that 'value' is a number.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the number can be omitted.\n */\nfunction validateNumber(arg, value, options) {\n    const min = options !== undefined && options.minValue !== undefined\n        ? options.minValue\n        : -Infinity;\n    const max = options !== undefined && options.maxValue !== undefined\n        ? options.maxValue\n        : Infinity;\n    if (!validateOptional(value, options)) {\n        if (typeof value !== 'number' || isNaN(value)) {\n            throw new Error(invalidArgumentMessage(arg, 'number'));\n        }\n        else if (value < min || value > max) {\n            throw new Error(`${formatArgumentName(arg)} must be within [${min}, ${max}] inclusive, but was: ${value}`);\n        }\n    }\n}\nexports.validateNumber = validateNumber;\n/**\n * Validates that 'value' is a integer.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the integer can be omitted.\n */\nfunction validateInteger(arg, value, options) {\n    const min = options !== undefined && options.minValue !== undefined\n        ? options.minValue\n        : -Infinity;\n    const max = options !== undefined && options.maxValue !== undefined\n        ? options.maxValue\n        : Infinity;\n    if (!validateOptional(value, options)) {\n        if (typeof value !== 'number' || isNaN(value) || value % 1 !== 0) {\n            throw new Error(invalidArgumentMessage(arg, 'integer'));\n        }\n        else if (value < min || value > max) {\n            throw new Error(`${formatArgumentName(arg)} must be within [${min}, ${max}] inclusive, but was: ${value}`);\n        }\n    }\n}\nexports.validateInteger = validateInteger;\n/**\n * Generates an error message to use with invalid arguments.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param expectedType The expected input type.\n */\nfunction invalidArgumentMessage(arg, expectedType) {\n    return `${formatArgumentName(arg)} is not a valid ${expectedType}.`;\n}\nexports.invalidArgumentMessage = invalidArgumentMessage;\n/**\n * Enforces the 'options.optional' constraint for 'value'.\n *\n * @private\n * @param value The input to validate.\n * @param options Whether the function can be omitted.\n * @return Whether the object is omitted and is allowed to be omitted.\n */\nfunction validateOptional(value, options) {\n    return (value === undefined && options !== undefined && options.optional === true);\n}\nexports.validateOptional = validateOptional;\n/**\n * Formats the given word as plural conditionally given the preceding number.\n *\n * @private\n * @param num The number to use for formatting.\n * @param str The string to format.\n */\nfunction formatPlural(num, str) {\n    return `${num} ${str}` + (num === 1 ? '' : 's');\n}\n/**\n * Creates a descriptive name for the provided argument name or index.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @return Either the argument name or its index description.\n */\nfunction formatArgumentName(arg) {\n    return typeof arg === 'string'\n        ? `Value for argument \"${arg}\"`\n        : `Element at index ${arg}`;\n}\n/**\n * Verifies that 'args' has at least 'minSize' elements.\n *\n * @private\n * @param funcName The function name to use in the error message.\n * @param args The array (or array-like structure) to verify.\n * @param minSize The minimum number of elements to enforce.\n * @throws if the expectation is not met.\n */\nfunction validateMinNumberOfArguments(funcName, args, minSize) {\n    if (args.length < minSize) {\n        throw new Error(`Function \"${funcName}()\" requires at least ` +\n            `${formatPlural(minSize, 'argument')}.`);\n    }\n}\nexports.validateMinNumberOfArguments = validateMinNumberOfArguments;\n/**\n * Verifies that 'args' has at most 'maxSize' elements.\n *\n * @private\n * @param funcName The function name to use in the error message.\n * @param args The array (or array-like structure) to verify.\n * @param maxSize The maximum number of elements to enforce.\n * @throws if the expectation is not met.\n */\nfunction validateMaxNumberOfArguments(funcName, args, maxSize) {\n    if (args.length > maxSize) {\n        throw new Error(`Function \"${funcName}()\" accepts at most ` +\n            `${formatPlural(maxSize, 'argument')}.`);\n    }\n}\nexports.validateMaxNumberOfArguments = validateMaxNumberOfArguments;\n/**\n * Validates that the provided named option equals one of the expected values.\n *\n * @param arg The argument name or argument index (for varargs methods).).\n * @param value The input to validate.\n * @param allowedValues A list of expected values.\n * @param options Whether the input can be omitted.\n * @private\n */\nfunction validateEnumValue(arg, value, allowedValues, options) {\n    if (!validateOptional(value, options)) {\n        const expectedDescription = [];\n        for (const allowed of allowedValues) {\n            if (allowed === value) {\n                return;\n            }\n            expectedDescription.push(allowed);\n        }\n        throw new Error(`${formatArgumentName(arg)} is invalid. Acceptable values are: ${expectedDescription.join(', ')}`);\n    }\n}\nexports.validateEnumValue = validateEnumValue;\n//# sourceMappingURL=validate.js.map"]},"metadata":{},"sourceType":"script"}