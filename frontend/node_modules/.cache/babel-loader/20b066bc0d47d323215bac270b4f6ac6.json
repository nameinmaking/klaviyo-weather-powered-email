{"ast":null,"code":"var stream = require(\"readable-stream\");\n\nvar BunWrapper = function BunWrapper(options) {\n  options = options || {};\n\n  if (Array.isArray(options)) {\n    options = {\n      streams: options\n    };\n  }\n\n  options.objectMode = true;\n  stream.Duplex.call(this, options);\n  var self = this; // grab a copy of the streams array\n\n  this._streams = (options.streams || []).slice(); // we need at least one stream to do things\n\n  if (this._streams.length === 0) {\n    this._streams.push(new stream.PassThrough({\n      objectMode: true\n    }));\n  } // default: true\n\n\n  this._bubbleErrors = typeof options.bubbleErrors === \"undefined\" || !!options.bubbleErrors; // error bubbling! yay!\n\n  if (this._bubbleErrors) {\n    for (var i = 0; i < this._streams.length; ++i) {\n      this._streams[i].on(\"error\", function (e) {\n        return self.emit(\"error\", e);\n      });\n    }\n  } // 0 -> 1, 1 -> 2, ..., n-1 -> n\n\n\n  for (var i = 0; i < this._streams.length - 1; ++i) {\n    this._streams[i].pipe(this._streams[i + 1]);\n  } // these might actually be the same. that's ok.\n\n\n  this._first = this._streams[0];\n  this._last = this._streams[this._streams.length - 1]; // .on(\"data\") is supported again in 0.11 and has always worked in 0.10\n\n  this._last.on(\"data\", function (e) {\n    if (!self.push(e)) {\n      self._last.pause();\n    }\n  }); // this is the readable side of our pipe ending\n\n\n  this._last.on(\"end\", function () {\n    self.push(null);\n  }); // and here's the writable side finishing\n\n\n  this._first.on(\"finish\", function () {\n    self.end();\n  }); // proxy through the .end() action\n\n\n  this.on(\"finish\", function () {\n    self._first.end();\n  });\n};\n\nBunWrapper.prototype = Object.create(stream.Duplex.prototype, {\n  constructor: {\n    value: BunWrapper\n  }\n});\n\nBunWrapper.prototype._write = function _write(input, encoding, done) {\n  this._first.write(input, done);\n};\n\nBunWrapper.prototype._read = function _read(n) {\n  this._last.resume();\n}; // factory function\n\n\nvar bun = module.exports = function bun(options, streams) {\n  if (Array.isArray(options)) {\n    var tmp = streams;\n    streams = options;\n    options = tmp;\n  }\n\n  options = options || {};\n  options.streams = options.streams || streams;\n  return new BunWrapper(options);\n};\n\nbun.BunWrapper = BunWrapper;","map":{"version":3,"sources":["/home/strider/Desktop/github/klaviyo-weather-powered-email/frontend/node_modules/bun/lib/bun.js"],"names":["stream","require","BunWrapper","options","Array","isArray","streams","objectMode","Duplex","call","self","_streams","slice","length","push","PassThrough","_bubbleErrors","bubbleErrors","i","on","e","emit","pipe","_first","_last","pause","end","prototype","Object","create","constructor","value","_write","input","encoding","done","write","_read","n","resume","bun","module","exports","tmp"],"mappings":"AAAA,IAAIA,MAAM,GAAGC,OAAO,CAAC,iBAAD,CAApB;;AAEA,IAAIC,UAAU,GAAG,SAASA,UAAT,CAAoBC,OAApB,EAA6B;AAC5CA,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;;AAEA,MAAIC,KAAK,CAACC,OAAN,CAAcF,OAAd,CAAJ,EAA4B;AAC1BA,IAAAA,OAAO,GAAG;AAACG,MAAAA,OAAO,EAAEH;AAAV,KAAV;AACD;;AAEDA,EAAAA,OAAO,CAACI,UAAR,GAAqB,IAArB;AAEAP,EAAAA,MAAM,CAACQ,MAAP,CAAcC,IAAd,CAAmB,IAAnB,EAAyBN,OAAzB;AAEA,MAAIO,IAAI,GAAG,IAAX,CAX4C,CAa5C;;AACA,OAAKC,QAAL,GAAgB,CAACR,OAAO,CAACG,OAAR,IAAmB,EAApB,EAAwBM,KAAxB,EAAhB,CAd4C,CAgB5C;;AACA,MAAI,KAAKD,QAAL,CAAcE,MAAd,KAAyB,CAA7B,EAAgC;AAC9B,SAAKF,QAAL,CAAcG,IAAd,CAAmB,IAAId,MAAM,CAACe,WAAX,CAAuB;AAACR,MAAAA,UAAU,EAAE;AAAb,KAAvB,CAAnB;AACD,GAnB2C,CAqB5C;;;AACA,OAAKS,aAAL,GAAsB,OAAOb,OAAO,CAACc,YAAf,KAAgC,WAAjC,IAAiD,CAAC,CAACd,OAAO,CAACc,YAAhF,CAtB4C,CAwB5C;;AACA,MAAI,KAAKD,aAAT,EAAwB;AACtB,SAAK,IAAIE,CAAC,GAAC,CAAX,EAAaA,CAAC,GAAC,KAAKP,QAAL,CAAcE,MAA7B,EAAoC,EAAEK,CAAtC,EAAyC;AACvC,WAAKP,QAAL,CAAcO,CAAd,EAAiBC,EAAjB,CAAoB,OAApB,EAA6B,UAASC,CAAT,EAAY;AACvC,eAAOV,IAAI,CAACW,IAAL,CAAU,OAAV,EAAmBD,CAAnB,CAAP;AACD,OAFD;AAGD;AACF,GA/B2C,CAiC5C;;;AACA,OAAK,IAAIF,CAAC,GAAC,CAAX,EAAaA,CAAC,GAAC,KAAKP,QAAL,CAAcE,MAAd,GAAqB,CAApC,EAAsC,EAAEK,CAAxC,EAA2C;AACzC,SAAKP,QAAL,CAAcO,CAAd,EAAiBI,IAAjB,CAAsB,KAAKX,QAAL,CAAcO,CAAC,GAAC,CAAhB,CAAtB;AACD,GApC2C,CAsC5C;;;AACA,OAAKK,MAAL,GAAc,KAAKZ,QAAL,CAAc,CAAd,CAAd;AACA,OAAKa,KAAL,GAAc,KAAKb,QAAL,CAAc,KAAKA,QAAL,CAAcE,MAAd,GAAqB,CAAnC,CAAd,CAxC4C,CA0C5C;;AACA,OAAKW,KAAL,CAAWL,EAAX,CAAc,MAAd,EAAsB,UAASC,CAAT,EAAY;AAChC,QAAI,CAACV,IAAI,CAACI,IAAL,CAAUM,CAAV,CAAL,EAAmB;AACjBV,MAAAA,IAAI,CAACc,KAAL,CAAWC,KAAX;AACD;AACF,GAJD,EA3C4C,CAiD5C;;;AACA,OAAKD,KAAL,CAAWL,EAAX,CAAc,KAAd,EAAqB,YAAW;AAC9BT,IAAAA,IAAI,CAACI,IAAL,CAAU,IAAV;AACD,GAFD,EAlD4C,CAsD5C;;;AACA,OAAKS,MAAL,CAAYJ,EAAZ,CAAe,QAAf,EAAyB,YAAW;AAClCT,IAAAA,IAAI,CAACgB,GAAL;AACD,GAFD,EAvD4C,CA2D5C;;;AACA,OAAKP,EAAL,CAAQ,QAAR,EAAkB,YAAW;AAC3BT,IAAAA,IAAI,CAACa,MAAL,CAAYG,GAAZ;AACD,GAFD;AAGD,CA/DD;;AAgEAxB,UAAU,CAACyB,SAAX,GAAuBC,MAAM,CAACC,MAAP,CAAc7B,MAAM,CAACQ,MAAP,CAAcmB,SAA5B,EAAuC;AAACG,EAAAA,WAAW,EAAE;AAACC,IAAAA,KAAK,EAAE7B;AAAR;AAAd,CAAvC,CAAvB;;AAEAA,UAAU,CAACyB,SAAX,CAAqBK,MAArB,GAA8B,SAASA,MAAT,CAAgBC,KAAhB,EAAuBC,QAAvB,EAAiCC,IAAjC,EAAuC;AACnE,OAAKZ,MAAL,CAAYa,KAAZ,CAAkBH,KAAlB,EAAyBE,IAAzB;AACD,CAFD;;AAIAjC,UAAU,CAACyB,SAAX,CAAqBU,KAArB,GAA6B,SAASA,KAAT,CAAeC,CAAf,EAAkB;AAC7C,OAAKd,KAAL,CAAWe,MAAX;AACD,CAFD,C,CAIA;;;AACA,IAAIC,GAAG,GAAGC,MAAM,CAACC,OAAP,GAAiB,SAASF,GAAT,CAAarC,OAAb,EAAsBG,OAAtB,EAA+B;AACxD,MAAIF,KAAK,CAACC,OAAN,CAAcF,OAAd,CAAJ,EAA4B;AAC1B,QAAIwC,GAAG,GAAGrC,OAAV;AACAA,IAAAA,OAAO,GAAGH,OAAV;AACAA,IAAAA,OAAO,GAAGwC,GAAV;AACD;;AAEDxC,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AAEAA,EAAAA,OAAO,CAACG,OAAR,GAAkBH,OAAO,CAACG,OAAR,IAAmBA,OAArC;AAEA,SAAO,IAAIJ,UAAJ,CAAeC,OAAf,CAAP;AACD,CAZD;;AAcAqC,GAAG,CAACtC,UAAJ,GAAiBA,UAAjB","sourcesContent":["var stream = require(\"readable-stream\");\n\nvar BunWrapper = function BunWrapper(options) {\n  options = options || {};\n\n  if (Array.isArray(options)) {\n    options = {streams: options};\n  }\n\n  options.objectMode = true;\n\n  stream.Duplex.call(this, options);\n\n  var self = this;\n\n  // grab a copy of the streams array\n  this._streams = (options.streams || []).slice();\n\n  // we need at least one stream to do things\n  if (this._streams.length === 0) {\n    this._streams.push(new stream.PassThrough({objectMode: true}));\n  }\n\n  // default: true\n  this._bubbleErrors = (typeof options.bubbleErrors === \"undefined\") || !!options.bubbleErrors;\n\n  // error bubbling! yay!\n  if (this._bubbleErrors) {\n    for (var i=0;i<this._streams.length;++i) {\n      this._streams[i].on(\"error\", function(e) {\n        return self.emit(\"error\", e);\n      });\n    }\n  }\n\n  // 0 -> 1, 1 -> 2, ..., n-1 -> n\n  for (var i=0;i<this._streams.length-1;++i) {\n    this._streams[i].pipe(this._streams[i+1]);\n  }\n\n  // these might actually be the same. that's ok.\n  this._first = this._streams[0];\n  this._last  = this._streams[this._streams.length-1];\n\n  // .on(\"data\") is supported again in 0.11 and has always worked in 0.10\n  this._last.on(\"data\", function(e) {\n    if (!self.push(e)) {\n      self._last.pause();\n    }\n  });\n\n  // this is the readable side of our pipe ending\n  this._last.on(\"end\", function() {\n    self.push(null);\n  });\n\n  // and here's the writable side finishing\n  this._first.on(\"finish\", function() {\n    self.end();\n  });\n\n  // proxy through the .end() action\n  this.on(\"finish\", function() {\n    self._first.end();\n  });\n};\nBunWrapper.prototype = Object.create(stream.Duplex.prototype, {constructor: {value: BunWrapper}});\n\nBunWrapper.prototype._write = function _write(input, encoding, done) {\n  this._first.write(input, done);\n};\n\nBunWrapper.prototype._read = function _read(n) {\n  this._last.resume();\n};\n\n// factory function\nvar bun = module.exports = function bun(options, streams) {\n  if (Array.isArray(options)) {\n    var tmp = streams;\n    streams = options;\n    options = tmp;\n  }\n\n  options = options || {};\n\n  options.streams = options.streams || streams;\n\n  return new BunWrapper(options);\n};\n\nbun.BunWrapper = BunWrapper;\n"]},"metadata":{},"sourceType":"script"}