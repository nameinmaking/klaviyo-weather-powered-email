{"ast":null,"code":"/*! firebase-admin v8.8.0 */\n\"use strict\";\n/*!\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // Use untyped import syntax for Node built-ins\n\nvar fs = require(\"fs\");\n\nvar os = require(\"os\");\n\nvar path = require(\"path\");\n\nvar error_1 = require(\"../utils/error\");\n\nvar api_request_1 = require(\"../utils/api-request\");\n\nvar GOOGLE_TOKEN_AUDIENCE = 'https://accounts.google.com/o/oauth2/token';\nvar GOOGLE_AUTH_TOKEN_HOST = 'accounts.google.com';\nvar GOOGLE_AUTH_TOKEN_PATH = '/o/oauth2/token'; // NOTE: the Google Metadata Service uses HTTP over a vlan\n\nvar GOOGLE_METADATA_SERVICE_HOST = 'metadata.google.internal';\nvar GOOGLE_METADATA_SERVICE_PATH = '/computeMetadata/v1/instance/service-accounts/default/token';\n\nvar configDir = function () {\n  // Windows has a dedicated low-rights location for apps at ~/Application Data\n  var sys = os.platform();\n\n  if (sys && sys.length >= 3 && sys.substring(0, 3).toLowerCase() === 'win') {\n    return process.env.APPDATA;\n  } // On *nix the gcloud cli creates a . dir.\n\n\n  return process.env.HOME && path.resolve(process.env.HOME, '.config');\n}();\n\nvar GCLOUD_CREDENTIAL_SUFFIX = 'gcloud/application_default_credentials.json';\nvar GCLOUD_CREDENTIAL_PATH = configDir && path.resolve(configDir, GCLOUD_CREDENTIAL_SUFFIX);\nvar REFRESH_TOKEN_HOST = 'www.googleapis.com';\nvar REFRESH_TOKEN_PATH = '/oauth2/v4/token';\nvar ONE_HOUR_IN_SECONDS = 60 * 60;\nvar JWT_ALGORITHM = 'RS256';\n\nfunction copyAttr(to, from, key, alt) {\n  var tmp = from[key] || from[alt];\n\n  if (typeof tmp !== 'undefined') {\n    to[key] = tmp;\n  }\n}\n\nvar RefreshToken =\n/** @class */\nfunction () {\n  function RefreshToken(json) {\n    copyAttr(this, json, 'clientId', 'client_id');\n    copyAttr(this, json, 'clientSecret', 'client_secret');\n    copyAttr(this, json, 'refreshToken', 'refresh_token');\n    copyAttr(this, json, 'type', 'type');\n    var errorMessage;\n\n    if (typeof this.clientId !== 'string' || !this.clientId) {\n      errorMessage = 'Refresh token must contain a \"client_id\" property.';\n    } else if (typeof this.clientSecret !== 'string' || !this.clientSecret) {\n      errorMessage = 'Refresh token must contain a \"client_secret\" property.';\n    } else if (typeof this.refreshToken !== 'string' || !this.refreshToken) {\n      errorMessage = 'Refresh token must contain a \"refresh_token\" property.';\n    } else if (typeof this.type !== 'string' || !this.type) {\n      errorMessage = 'Refresh token must contain a \"type\" property.';\n    }\n\n    if (typeof errorMessage !== 'undefined') {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);\n    }\n  }\n  /*\n   * Tries to load a RefreshToken from a path. If the path is not present, returns null.\n   * Throws if data at the path is invalid.\n   */\n\n\n  RefreshToken.fromPath = function (filePath) {\n    var jsonString;\n\n    try {\n      jsonString = fs.readFileSync(filePath, 'utf8');\n    } catch (ignored) {\n      // Ignore errors if the file is not present, as this is sometimes an expected condition\n      return null;\n    }\n\n    try {\n      return new RefreshToken(JSON.parse(jsonString));\n    } catch (error) {\n      // Throw a nicely formed error message if the file contents cannot be parsed\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse refresh token file: ' + error);\n    }\n  };\n\n  return RefreshToken;\n}();\n\nexports.RefreshToken = RefreshToken;\n/**\n * A struct containing the properties necessary to use service-account JSON credentials.\n */\n\nvar Certificate =\n/** @class */\nfunction () {\n  function Certificate(json) {\n    if (typeof json !== 'object' || json === null) {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Certificate object must be an object.');\n    }\n\n    copyAttr(this, json, 'projectId', 'project_id');\n    copyAttr(this, json, 'privateKey', 'private_key');\n    copyAttr(this, json, 'clientEmail', 'client_email');\n    var errorMessage;\n\n    if (typeof this.privateKey !== 'string' || !this.privateKey) {\n      errorMessage = 'Certificate object must contain a string \"private_key\" property.';\n    } else if (typeof this.clientEmail !== 'string' || !this.clientEmail) {\n      errorMessage = 'Certificate object must contain a string \"client_email\" property.';\n    }\n\n    if (typeof errorMessage !== 'undefined') {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);\n    }\n\n    var forge = require('node-forge');\n\n    try {\n      forge.pki.privateKeyFromPem(this.privateKey);\n    } catch (error) {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse private key: ' + error);\n    }\n  }\n\n  Certificate.fromPath = function (filePath) {\n    // Node bug encountered in v6.x. fs.readFileSync hangs when path is a 0 or 1.\n    if (typeof filePath !== 'string') {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse certificate key file: TypeError: path must be a string');\n    }\n\n    try {\n      return new Certificate(JSON.parse(fs.readFileSync(filePath, 'utf8')));\n    } catch (error) {\n      // Throw a nicely formed error message if the file contents cannot be parsed\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse certificate key file: ' + error);\n    }\n  };\n\n  return Certificate;\n}();\n\nexports.Certificate = Certificate;\n/**\n * Obtain a new OAuth2 token by making a remote service call.\n */\n\nfunction requestAccessToken(client, request) {\n  return client.send(request).then(function (resp) {\n    var json = resp.data;\n\n    if (!json.access_token || !json.expires_in) {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, \"Unexpected response while fetching access token: \" + JSON.stringify(json));\n    }\n\n    return json;\n  }).catch(function (err) {\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, getErrorMessage(err));\n  });\n}\n/**\n * Constructs a human-readable error message from the given Error.\n */\n\n\nfunction getErrorMessage(err) {\n  var detail = err instanceof api_request_1.HttpError ? getDetailFromResponse(err.response) : err.message;\n  return \"Error fetching access token: \" + detail;\n}\n/**\n * Extracts details from the given HTTP error response, and returns a human-readable description. If\n * the response is JSON-formatted, looks up the error and error_description fields sent by the\n * Google Auth servers. Otherwise returns the entire response payload as the error detail.\n */\n\n\nfunction getDetailFromResponse(response) {\n  if (response.isJson() && response.data.error) {\n    var json = response.data;\n    var detail = json.error;\n\n    if (json.error_description) {\n      detail += ' (' + json.error_description + ')';\n    }\n\n    return detail;\n  }\n\n  return response.text;\n}\n/**\n * Implementation of Credential that uses a service account certificate.\n */\n\n\nvar CertCredential =\n/** @class */\nfunction () {\n  function CertCredential(serviceAccountPathOrObject, httpAgent) {\n    this.certificate = typeof serviceAccountPathOrObject === 'string' ? Certificate.fromPath(serviceAccountPathOrObject) : new Certificate(serviceAccountPathOrObject);\n    this.httpClient = new api_request_1.HttpClient();\n    this.httpAgent = httpAgent;\n  }\n\n  CertCredential.prototype.getAccessToken = function () {\n    var token = this.createAuthJwt_();\n    var postData = 'grant_type=urn%3Aietf%3Aparams%3Aoauth%3A' + 'grant-type%3Ajwt-bearer&assertion=' + token;\n    var request = {\n      method: 'POST',\n      url: \"https://\" + GOOGLE_AUTH_TOKEN_HOST + GOOGLE_AUTH_TOKEN_PATH,\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      },\n      data: postData,\n      httpAgent: this.httpAgent\n    };\n    return requestAccessToken(this.httpClient, request);\n  };\n\n  CertCredential.prototype.getCertificate = function () {\n    return this.certificate;\n  };\n\n  CertCredential.prototype.createAuthJwt_ = function () {\n    var claims = {\n      scope: ['https://www.googleapis.com/auth/cloud-platform', 'https://www.googleapis.com/auth/firebase.database', 'https://www.googleapis.com/auth/firebase.messaging', 'https://www.googleapis.com/auth/identitytoolkit', 'https://www.googleapis.com/auth/userinfo.email'].join(' ')\n    };\n\n    var jwt = require('jsonwebtoken'); // This method is actually synchronous so we can capture and return the buffer.\n\n\n    return jwt.sign(claims, this.certificate.privateKey, {\n      audience: GOOGLE_TOKEN_AUDIENCE,\n      expiresIn: ONE_HOUR_IN_SECONDS,\n      issuer: this.certificate.clientEmail,\n      algorithm: JWT_ALGORITHM\n    });\n  };\n\n  return CertCredential;\n}();\n\nexports.CertCredential = CertCredential;\n/**\n * Attempts to extract a Certificate from the given credential.\n *\n * @param {Credential} credential A Credential instance.\n * @return {Certificate} A Certificate instance or null.\n */\n\nfunction tryGetCertificate(credential) {\n  if (isFirebaseCredential(credential)) {\n    return credential.getCertificate();\n  }\n\n  return null;\n}\n\nexports.tryGetCertificate = tryGetCertificate;\n\nfunction isFirebaseCredential(credential) {\n  return 'getCertificate' in credential;\n}\n/**\n * Implementation of Credential that gets access tokens from refresh tokens.\n */\n\n\nvar RefreshTokenCredential =\n/** @class */\nfunction () {\n  function RefreshTokenCredential(refreshTokenPathOrObject, httpAgent) {\n    this.refreshToken = typeof refreshTokenPathOrObject === 'string' ? RefreshToken.fromPath(refreshTokenPathOrObject) : new RefreshToken(refreshTokenPathOrObject);\n    this.httpClient = new api_request_1.HttpClient();\n    this.httpAgent = httpAgent;\n  }\n\n  RefreshTokenCredential.prototype.getAccessToken = function () {\n    var postData = 'client_id=' + this.refreshToken.clientId + '&' + 'client_secret=' + this.refreshToken.clientSecret + '&' + 'refresh_token=' + this.refreshToken.refreshToken + '&' + 'grant_type=refresh_token';\n    var request = {\n      method: 'POST',\n      url: \"https://\" + REFRESH_TOKEN_HOST + REFRESH_TOKEN_PATH,\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      },\n      data: postData,\n      httpAgent: this.httpAgent\n    };\n    return requestAccessToken(this.httpClient, request);\n  };\n\n  return RefreshTokenCredential;\n}();\n\nexports.RefreshTokenCredential = RefreshTokenCredential;\n/**\n * Implementation of Credential that gets access tokens from the metadata service available\n * in the Google Cloud Platform. This authenticates the process as the default service account\n * of an App Engine instance or Google Compute Engine machine.\n */\n\nvar MetadataServiceCredential =\n/** @class */\nfunction () {\n  function MetadataServiceCredential(httpAgent) {\n    this.httpClient = new api_request_1.HttpClient();\n    this.httpAgent = httpAgent;\n  }\n\n  MetadataServiceCredential.prototype.getAccessToken = function () {\n    var request = {\n      method: 'GET',\n      url: \"http://\" + GOOGLE_METADATA_SERVICE_HOST + GOOGLE_METADATA_SERVICE_PATH,\n      headers: {\n        'Metadata-Flavor': 'Google'\n      },\n      httpAgent: this.httpAgent\n    };\n    return requestAccessToken(this.httpClient, request);\n  };\n\n  return MetadataServiceCredential;\n}();\n\nexports.MetadataServiceCredential = MetadataServiceCredential;\n/**\n * ApplicationDefaultCredential implements the process for loading credentials as\n * described in https://developers.google.com/identity/protocols/application-default-credentials\n */\n\nvar ApplicationDefaultCredential =\n/** @class */\nfunction () {\n  function ApplicationDefaultCredential(httpAgent) {\n    if (process.env.GOOGLE_APPLICATION_CREDENTIALS) {\n      this.credential_ = credentialFromFile(process.env.GOOGLE_APPLICATION_CREDENTIALS, httpAgent);\n      return;\n    } // It is OK to not have this file. If it is present, it must be valid.\n\n\n    var refreshToken = RefreshToken.fromPath(GCLOUD_CREDENTIAL_PATH);\n\n    if (refreshToken) {\n      this.credential_ = new RefreshTokenCredential(refreshToken, httpAgent);\n      return;\n    }\n\n    this.credential_ = new MetadataServiceCredential(httpAgent);\n  }\n\n  ApplicationDefaultCredential.prototype.getAccessToken = function () {\n    return this.credential_.getAccessToken();\n  };\n\n  ApplicationDefaultCredential.prototype.getCertificate = function () {\n    return tryGetCertificate(this.credential_);\n  }; // Used in testing to verify we are delegating to the correct implementation.\n\n\n  ApplicationDefaultCredential.prototype.getCredential = function () {\n    return this.credential_;\n  };\n\n  return ApplicationDefaultCredential;\n}();\n\nexports.ApplicationDefaultCredential = ApplicationDefaultCredential;\n\nfunction credentialFromFile(filePath, httpAgent) {\n  var credentialsFile = readCredentialFile(filePath);\n\n  if (typeof credentialsFile !== 'object') {\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse contents of the credentials file as an object');\n  }\n\n  if (credentialsFile.type === 'service_account') {\n    return new CertCredential(credentialsFile, httpAgent);\n  }\n\n  if (credentialsFile.type === 'authorized_user') {\n    return new RefreshTokenCredential(credentialsFile, httpAgent);\n  }\n\n  throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Invalid contents in the credentials file');\n}\n\nfunction readCredentialFile(filePath) {\n  if (typeof filePath !== 'string') {\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse credentials file: TypeError: path must be a string');\n  }\n\n  var fileText;\n\n  try {\n    fileText = fs.readFileSync(filePath, 'utf8');\n  } catch (error) {\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, \"Failed to read credentials from file \" + filePath + \": \" + error);\n  }\n\n  try {\n    return JSON.parse(fileText);\n  } catch (error) {\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse contents of the credentials file as an object: ' + error);\n  }\n}","map":{"version":3,"sources":["/home/strider/Desktop/github/klaviyo-weather-powered-email/frontend/node_modules/firebase-admin/lib/auth/credential.js"],"names":["Object","defineProperty","exports","value","fs","require","os","path","error_1","api_request_1","GOOGLE_TOKEN_AUDIENCE","GOOGLE_AUTH_TOKEN_HOST","GOOGLE_AUTH_TOKEN_PATH","GOOGLE_METADATA_SERVICE_HOST","GOOGLE_METADATA_SERVICE_PATH","configDir","sys","platform","length","substring","toLowerCase","process","env","APPDATA","HOME","resolve","GCLOUD_CREDENTIAL_SUFFIX","GCLOUD_CREDENTIAL_PATH","REFRESH_TOKEN_HOST","REFRESH_TOKEN_PATH","ONE_HOUR_IN_SECONDS","JWT_ALGORITHM","copyAttr","to","from","key","alt","tmp","RefreshToken","json","errorMessage","clientId","clientSecret","refreshToken","type","FirebaseAppError","AppErrorCodes","INVALID_CREDENTIAL","fromPath","filePath","jsonString","readFileSync","ignored","JSON","parse","error","Certificate","privateKey","clientEmail","forge","pki","privateKeyFromPem","requestAccessToken","client","request","send","then","resp","data","access_token","expires_in","stringify","catch","err","getErrorMessage","detail","HttpError","getDetailFromResponse","response","message","isJson","error_description","text","CertCredential","serviceAccountPathOrObject","httpAgent","certificate","httpClient","HttpClient","prototype","getAccessToken","token","createAuthJwt_","postData","method","url","headers","getCertificate","claims","scope","join","jwt","sign","audience","expiresIn","issuer","algorithm","tryGetCertificate","credential","isFirebaseCredential","RefreshTokenCredential","refreshTokenPathOrObject","MetadataServiceCredential","ApplicationDefaultCredential","GOOGLE_APPLICATION_CREDENTIALS","credential_","credentialFromFile","getCredential","credentialsFile","readCredentialFile","fileText"],"mappings":"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","sourcesContent":["/*! firebase-admin v8.8.0 */\n\"use strict\";\n/*!\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// Use untyped import syntax for Node built-ins\nvar fs = require(\"fs\");\nvar os = require(\"os\");\nvar path = require(\"path\");\nvar error_1 = require(\"../utils/error\");\nvar api_request_1 = require(\"../utils/api-request\");\nvar GOOGLE_TOKEN_AUDIENCE = 'https://accounts.google.com/o/oauth2/token';\nvar GOOGLE_AUTH_TOKEN_HOST = 'accounts.google.com';\nvar GOOGLE_AUTH_TOKEN_PATH = '/o/oauth2/token';\n// NOTE: the Google Metadata Service uses HTTP over a vlan\nvar GOOGLE_METADATA_SERVICE_HOST = 'metadata.google.internal';\nvar GOOGLE_METADATA_SERVICE_PATH = '/computeMetadata/v1/instance/service-accounts/default/token';\nvar configDir = (function () {\n    // Windows has a dedicated low-rights location for apps at ~/Application Data\n    var sys = os.platform();\n    if (sys && sys.length >= 3 && sys.substring(0, 3).toLowerCase() === 'win') {\n        return process.env.APPDATA;\n    }\n    // On *nix the gcloud cli creates a . dir.\n    return process.env.HOME && path.resolve(process.env.HOME, '.config');\n})();\nvar GCLOUD_CREDENTIAL_SUFFIX = 'gcloud/application_default_credentials.json';\nvar GCLOUD_CREDENTIAL_PATH = configDir && path.resolve(configDir, GCLOUD_CREDENTIAL_SUFFIX);\nvar REFRESH_TOKEN_HOST = 'www.googleapis.com';\nvar REFRESH_TOKEN_PATH = '/oauth2/v4/token';\nvar ONE_HOUR_IN_SECONDS = 60 * 60;\nvar JWT_ALGORITHM = 'RS256';\nfunction copyAttr(to, from, key, alt) {\n    var tmp = from[key] || from[alt];\n    if (typeof tmp !== 'undefined') {\n        to[key] = tmp;\n    }\n}\nvar RefreshToken = /** @class */ (function () {\n    function RefreshToken(json) {\n        copyAttr(this, json, 'clientId', 'client_id');\n        copyAttr(this, json, 'clientSecret', 'client_secret');\n        copyAttr(this, json, 'refreshToken', 'refresh_token');\n        copyAttr(this, json, 'type', 'type');\n        var errorMessage;\n        if (typeof this.clientId !== 'string' || !this.clientId) {\n            errorMessage = 'Refresh token must contain a \"client_id\" property.';\n        }\n        else if (typeof this.clientSecret !== 'string' || !this.clientSecret) {\n            errorMessage = 'Refresh token must contain a \"client_secret\" property.';\n        }\n        else if (typeof this.refreshToken !== 'string' || !this.refreshToken) {\n            errorMessage = 'Refresh token must contain a \"refresh_token\" property.';\n        }\n        else if (typeof this.type !== 'string' || !this.type) {\n            errorMessage = 'Refresh token must contain a \"type\" property.';\n        }\n        if (typeof errorMessage !== 'undefined') {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);\n        }\n    }\n    /*\n     * Tries to load a RefreshToken from a path. If the path is not present, returns null.\n     * Throws if data at the path is invalid.\n     */\n    RefreshToken.fromPath = function (filePath) {\n        var jsonString;\n        try {\n            jsonString = fs.readFileSync(filePath, 'utf8');\n        }\n        catch (ignored) {\n            // Ignore errors if the file is not present, as this is sometimes an expected condition\n            return null;\n        }\n        try {\n            return new RefreshToken(JSON.parse(jsonString));\n        }\n        catch (error) {\n            // Throw a nicely formed error message if the file contents cannot be parsed\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse refresh token file: ' + error);\n        }\n    };\n    return RefreshToken;\n}());\nexports.RefreshToken = RefreshToken;\n/**\n * A struct containing the properties necessary to use service-account JSON credentials.\n */\nvar Certificate = /** @class */ (function () {\n    function Certificate(json) {\n        if (typeof json !== 'object' || json === null) {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Certificate object must be an object.');\n        }\n        copyAttr(this, json, 'projectId', 'project_id');\n        copyAttr(this, json, 'privateKey', 'private_key');\n        copyAttr(this, json, 'clientEmail', 'client_email');\n        var errorMessage;\n        if (typeof this.privateKey !== 'string' || !this.privateKey) {\n            errorMessage = 'Certificate object must contain a string \"private_key\" property.';\n        }\n        else if (typeof this.clientEmail !== 'string' || !this.clientEmail) {\n            errorMessage = 'Certificate object must contain a string \"client_email\" property.';\n        }\n        if (typeof errorMessage !== 'undefined') {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);\n        }\n        var forge = require('node-forge');\n        try {\n            forge.pki.privateKeyFromPem(this.privateKey);\n        }\n        catch (error) {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse private key: ' + error);\n        }\n    }\n    Certificate.fromPath = function (filePath) {\n        // Node bug encountered in v6.x. fs.readFileSync hangs when path is a 0 or 1.\n        if (typeof filePath !== 'string') {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse certificate key file: TypeError: path must be a string');\n        }\n        try {\n            return new Certificate(JSON.parse(fs.readFileSync(filePath, 'utf8')));\n        }\n        catch (error) {\n            // Throw a nicely formed error message if the file contents cannot be parsed\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse certificate key file: ' + error);\n        }\n    };\n    return Certificate;\n}());\nexports.Certificate = Certificate;\n/**\n * Obtain a new OAuth2 token by making a remote service call.\n */\nfunction requestAccessToken(client, request) {\n    return client.send(request).then(function (resp) {\n        var json = resp.data;\n        if (!json.access_token || !json.expires_in) {\n            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, \"Unexpected response while fetching access token: \" + JSON.stringify(json));\n        }\n        return json;\n    }).catch(function (err) {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, getErrorMessage(err));\n    });\n}\n/**\n * Constructs a human-readable error message from the given Error.\n */\nfunction getErrorMessage(err) {\n    var detail = (err instanceof api_request_1.HttpError) ? getDetailFromResponse(err.response) : err.message;\n    return \"Error fetching access token: \" + detail;\n}\n/**\n * Extracts details from the given HTTP error response, and returns a human-readable description. If\n * the response is JSON-formatted, looks up the error and error_description fields sent by the\n * Google Auth servers. Otherwise returns the entire response payload as the error detail.\n */\nfunction getDetailFromResponse(response) {\n    if (response.isJson() && response.data.error) {\n        var json = response.data;\n        var detail = json.error;\n        if (json.error_description) {\n            detail += ' (' + json.error_description + ')';\n        }\n        return detail;\n    }\n    return response.text;\n}\n/**\n * Implementation of Credential that uses a service account certificate.\n */\nvar CertCredential = /** @class */ (function () {\n    function CertCredential(serviceAccountPathOrObject, httpAgent) {\n        this.certificate = (typeof serviceAccountPathOrObject === 'string') ?\n            Certificate.fromPath(serviceAccountPathOrObject) : new Certificate(serviceAccountPathOrObject);\n        this.httpClient = new api_request_1.HttpClient();\n        this.httpAgent = httpAgent;\n    }\n    CertCredential.prototype.getAccessToken = function () {\n        var token = this.createAuthJwt_();\n        var postData = 'grant_type=urn%3Aietf%3Aparams%3Aoauth%3A' +\n            'grant-type%3Ajwt-bearer&assertion=' + token;\n        var request = {\n            method: 'POST',\n            url: \"https://\" + GOOGLE_AUTH_TOKEN_HOST + GOOGLE_AUTH_TOKEN_PATH,\n            headers: {\n                'Content-Type': 'application/x-www-form-urlencoded',\n            },\n            data: postData,\n            httpAgent: this.httpAgent,\n        };\n        return requestAccessToken(this.httpClient, request);\n    };\n    CertCredential.prototype.getCertificate = function () {\n        return this.certificate;\n    };\n    CertCredential.prototype.createAuthJwt_ = function () {\n        var claims = {\n            scope: [\n                'https://www.googleapis.com/auth/cloud-platform',\n                'https://www.googleapis.com/auth/firebase.database',\n                'https://www.googleapis.com/auth/firebase.messaging',\n                'https://www.googleapis.com/auth/identitytoolkit',\n                'https://www.googleapis.com/auth/userinfo.email',\n            ].join(' '),\n        };\n        var jwt = require('jsonwebtoken');\n        // This method is actually synchronous so we can capture and return the buffer.\n        return jwt.sign(claims, this.certificate.privateKey, {\n            audience: GOOGLE_TOKEN_AUDIENCE,\n            expiresIn: ONE_HOUR_IN_SECONDS,\n            issuer: this.certificate.clientEmail,\n            algorithm: JWT_ALGORITHM,\n        });\n    };\n    return CertCredential;\n}());\nexports.CertCredential = CertCredential;\n/**\n * Attempts to extract a Certificate from the given credential.\n *\n * @param {Credential} credential A Credential instance.\n * @return {Certificate} A Certificate instance or null.\n */\nfunction tryGetCertificate(credential) {\n    if (isFirebaseCredential(credential)) {\n        return credential.getCertificate();\n    }\n    return null;\n}\nexports.tryGetCertificate = tryGetCertificate;\nfunction isFirebaseCredential(credential) {\n    return 'getCertificate' in credential;\n}\n/**\n * Implementation of Credential that gets access tokens from refresh tokens.\n */\nvar RefreshTokenCredential = /** @class */ (function () {\n    function RefreshTokenCredential(refreshTokenPathOrObject, httpAgent) {\n        this.refreshToken = (typeof refreshTokenPathOrObject === 'string') ?\n            RefreshToken.fromPath(refreshTokenPathOrObject) : new RefreshToken(refreshTokenPathOrObject);\n        this.httpClient = new api_request_1.HttpClient();\n        this.httpAgent = httpAgent;\n    }\n    RefreshTokenCredential.prototype.getAccessToken = function () {\n        var postData = 'client_id=' + this.refreshToken.clientId + '&' +\n            'client_secret=' + this.refreshToken.clientSecret + '&' +\n            'refresh_token=' + this.refreshToken.refreshToken + '&' +\n            'grant_type=refresh_token';\n        var request = {\n            method: 'POST',\n            url: \"https://\" + REFRESH_TOKEN_HOST + REFRESH_TOKEN_PATH,\n            headers: {\n                'Content-Type': 'application/x-www-form-urlencoded',\n            },\n            data: postData,\n            httpAgent: this.httpAgent,\n        };\n        return requestAccessToken(this.httpClient, request);\n    };\n    return RefreshTokenCredential;\n}());\nexports.RefreshTokenCredential = RefreshTokenCredential;\n/**\n * Implementation of Credential that gets access tokens from the metadata service available\n * in the Google Cloud Platform. This authenticates the process as the default service account\n * of an App Engine instance or Google Compute Engine machine.\n */\nvar MetadataServiceCredential = /** @class */ (function () {\n    function MetadataServiceCredential(httpAgent) {\n        this.httpClient = new api_request_1.HttpClient();\n        this.httpAgent = httpAgent;\n    }\n    MetadataServiceCredential.prototype.getAccessToken = function () {\n        var request = {\n            method: 'GET',\n            url: \"http://\" + GOOGLE_METADATA_SERVICE_HOST + GOOGLE_METADATA_SERVICE_PATH,\n            headers: {\n                'Metadata-Flavor': 'Google',\n            },\n            httpAgent: this.httpAgent,\n        };\n        return requestAccessToken(this.httpClient, request);\n    };\n    return MetadataServiceCredential;\n}());\nexports.MetadataServiceCredential = MetadataServiceCredential;\n/**\n * ApplicationDefaultCredential implements the process for loading credentials as\n * described in https://developers.google.com/identity/protocols/application-default-credentials\n */\nvar ApplicationDefaultCredential = /** @class */ (function () {\n    function ApplicationDefaultCredential(httpAgent) {\n        if (process.env.GOOGLE_APPLICATION_CREDENTIALS) {\n            this.credential_ = credentialFromFile(process.env.GOOGLE_APPLICATION_CREDENTIALS, httpAgent);\n            return;\n        }\n        // It is OK to not have this file. If it is present, it must be valid.\n        var refreshToken = RefreshToken.fromPath(GCLOUD_CREDENTIAL_PATH);\n        if (refreshToken) {\n            this.credential_ = new RefreshTokenCredential(refreshToken, httpAgent);\n            return;\n        }\n        this.credential_ = new MetadataServiceCredential(httpAgent);\n    }\n    ApplicationDefaultCredential.prototype.getAccessToken = function () {\n        return this.credential_.getAccessToken();\n    };\n    ApplicationDefaultCredential.prototype.getCertificate = function () {\n        return tryGetCertificate(this.credential_);\n    };\n    // Used in testing to verify we are delegating to the correct implementation.\n    ApplicationDefaultCredential.prototype.getCredential = function () {\n        return this.credential_;\n    };\n    return ApplicationDefaultCredential;\n}());\nexports.ApplicationDefaultCredential = ApplicationDefaultCredential;\nfunction credentialFromFile(filePath, httpAgent) {\n    var credentialsFile = readCredentialFile(filePath);\n    if (typeof credentialsFile !== 'object') {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse contents of the credentials file as an object');\n    }\n    if (credentialsFile.type === 'service_account') {\n        return new CertCredential(credentialsFile, httpAgent);\n    }\n    if (credentialsFile.type === 'authorized_user') {\n        return new RefreshTokenCredential(credentialsFile, httpAgent);\n    }\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Invalid contents in the credentials file');\n}\nfunction readCredentialFile(filePath) {\n    if (typeof filePath !== 'string') {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse credentials file: TypeError: path must be a string');\n    }\n    var fileText;\n    try {\n        fileText = fs.readFileSync(filePath, 'utf8');\n    }\n    catch (error) {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, \"Failed to read credentials from file \" + filePath + \": \" + error);\n    }\n    try {\n        return JSON.parse(fileText);\n    }\n    catch (error) {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse contents of the credentials file as an object: ' + error);\n    }\n}\n"]},"metadata":{},"sourceType":"script"}