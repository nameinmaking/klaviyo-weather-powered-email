{"ast":null,"code":"/*! firebase-admin v8.8.0 */\n\"use strict\";\n/*!\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar user_record_1 = require(\"./user-record\");\n\nvar token_generator_1 = require(\"./token-generator\");\n\nvar auth_api_request_1 = require(\"./auth-api-request\");\n\nvar error_1 = require(\"../utils/error\");\n\nvar utils = require(\"../utils/index\");\n\nvar validator = require(\"../utils/validator\");\n\nvar token_verifier_1 = require(\"./token-verifier\");\n\nvar auth_config_1 = require(\"./auth-config\");\n\nvar tenant_manager_1 = require(\"./tenant-manager\");\n/**\n * Internals of an Auth instance.\n */\n\n\nvar AuthInternals =\n/** @class */\nfunction () {\n  function AuthInternals() {}\n  /**\n   * Deletes the service and its associated resources.\n   *\n   * @return {Promise<()>} An empty Promise that will be fulfilled when the service is deleted.\n   */\n\n\n  AuthInternals.prototype.delete = function () {\n    // There are no resources to clean up\n    return Promise.resolve(undefined);\n  };\n\n  return AuthInternals;\n}();\n/**\n * Base Auth class. Mainly used for user management APIs.\n */\n\n\nvar BaseAuth =\n/** @class */\nfunction () {\n  /**\n   * The BaseAuth class constructor.\n   *\n   * @param {string} projectId The corresponding project ID.\n   * @param {T} authRequestHandler The RPC request handler\n   *     for this instance.\n   * @param {CryptoSigner} cryptoSigner The instance crypto signer used for custom token\n   *     minting.\n   * @constructor\n   */\n  function BaseAuth(app, authRequestHandler) {\n    this.authRequestHandler = authRequestHandler;\n    var cryptoSigner = token_generator_1.cryptoSignerFromApp(app);\n    this.tokenGenerator = new token_generator_1.FirebaseTokenGenerator(cryptoSigner);\n    var projectId = utils.getProjectId(app);\n    var httpAgent = app.options.httpAgent;\n    this.sessionCookieVerifier = token_verifier_1.createSessionCookieVerifier(projectId, httpAgent);\n    this.idTokenVerifier = token_verifier_1.createIdTokenVerifier(projectId, httpAgent);\n  }\n  /**\n   * Creates a new custom token that can be sent back to a client to use with\n   * signInWithCustomToken().\n   *\n   * @param {string} uid The uid to use as the JWT subject.\n   * @param {object=} developerClaims Optional additional claims to include in the JWT payload.\n   *\n   * @return {Promise<string>} A JWT for the provided payload.\n   */\n\n\n  BaseAuth.prototype.createCustomToken = function (uid, developerClaims) {\n    return this.tokenGenerator.createCustomToken(uid, developerClaims);\n  };\n  /**\n   * Verifies a JWT auth token. Returns a Promise with the tokens claims. Rejects\n   * the promise if the token could not be verified. If checkRevoked is set to true,\n   * verifies if the session corresponding to the ID token was revoked. If the corresponding\n   * user's session was invalidated, an auth/id-token-revoked error is thrown. If not specified\n   * the check is not applied.\n   *\n   * @param {string} idToken The JWT to verify.\n   * @param {boolean=} checkRevoked Whether to check if the ID token is revoked.\n   * @return {Promise<DecodedIdToken>} A Promise that will be fulfilled after a successful\n   *     verification.\n   */\n\n\n  BaseAuth.prototype.verifyIdToken = function (idToken, checkRevoked) {\n    var _this = this;\n\n    if (checkRevoked === void 0) {\n      checkRevoked = false;\n    }\n\n    return this.idTokenVerifier.verifyJWT(idToken).then(function (decodedIdToken) {\n      // Whether to check if the token was revoked.\n      if (!checkRevoked) {\n        return decodedIdToken;\n      }\n\n      return _this.verifyDecodedJWTNotRevoked(decodedIdToken, error_1.AuthClientErrorCode.ID_TOKEN_REVOKED);\n    });\n  };\n  /**\n   * Looks up the user identified by the provided user id and returns a promise that is\n   * fulfilled with a user record for the given user if that user is found.\n   *\n   * @param {string} uid The uid of the user to look up.\n   * @return {Promise<UserRecord>} A promise that resolves with the corresponding user record.\n   */\n\n\n  BaseAuth.prototype.getUser = function (uid) {\n    return this.authRequestHandler.getAccountInfoByUid(uid).then(function (response) {\n      // Returns the user record populated with server response.\n      return new user_record_1.UserRecord(response.users[0]);\n    });\n  };\n  /**\n   * Looks up the user identified by the provided email and returns a promise that is\n   * fulfilled with a user record for the given user if that user is found.\n   *\n   * @param {string} email The email of the user to look up.\n   * @return {Promise<UserRecord>} A promise that resolves with the corresponding user record.\n   */\n\n\n  BaseAuth.prototype.getUserByEmail = function (email) {\n    return this.authRequestHandler.getAccountInfoByEmail(email).then(function (response) {\n      // Returns the user record populated with server response.\n      return new user_record_1.UserRecord(response.users[0]);\n    });\n  };\n  /**\n   * Looks up the user identified by the provided phone number and returns a promise that is\n   * fulfilled with a user record for the given user if that user is found.\n   *\n   * @param {string} phoneNumber The phone number of the user to look up.\n   * @return {Promise<UserRecord>} A promise that resolves with the corresponding user record.\n   */\n\n\n  BaseAuth.prototype.getUserByPhoneNumber = function (phoneNumber) {\n    return this.authRequestHandler.getAccountInfoByPhoneNumber(phoneNumber).then(function (response) {\n      // Returns the user record populated with server response.\n      return new user_record_1.UserRecord(response.users[0]);\n    });\n  };\n  /**\n   * Exports a batch of user accounts. Batch size is determined by the maxResults argument.\n   * Starting point of the batch is determined by the pageToken argument.\n   *\n   * @param {number=} maxResults The page size, 1000 if undefined. This is also the maximum\n   *     allowed limit.\n   * @param {string=} pageToken The next page token. If not specified, returns users starting\n   *     without any offset.\n   * @return {Promise<{users: UserRecord[], pageToken?: string}>} A promise that resolves with\n   *     the current batch of downloaded users and the next page token. For the last page, an\n   *     empty list of users and no page token are returned.\n   */\n\n\n  BaseAuth.prototype.listUsers = function (maxResults, pageToken) {\n    return this.authRequestHandler.downloadAccount(maxResults, pageToken).then(function (response) {\n      // List of users to return.\n      var users = []; // Convert each user response to a UserRecord.\n\n      response.users.forEach(function (userResponse) {\n        users.push(new user_record_1.UserRecord(userResponse));\n      }); // Return list of user records and the next page token if available.\n\n      var result = {\n        users: users,\n        pageToken: response.nextPageToken\n      }; // Delete result.pageToken if undefined.\n\n      if (typeof result.pageToken === 'undefined') {\n        delete result.pageToken;\n      }\n\n      return result;\n    });\n  };\n  /**\n   * Creates a new user with the properties provided.\n   *\n   * @param {CreateRequest} properties The properties to set on the new user record to be created.\n   * @return {Promise<UserRecord>} A promise that resolves with the newly created user record.\n   */\n\n\n  BaseAuth.prototype.createUser = function (properties) {\n    var _this = this;\n\n    return this.authRequestHandler.createNewAccount(properties).then(function (uid) {\n      // Return the corresponding user record.\n      return _this.getUser(uid);\n    }).catch(function (error) {\n      if (error.code === 'auth/user-not-found') {\n        // Something must have happened after creating the user and then retrieving it.\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Unable to create the user record provided.');\n      }\n\n      throw error;\n    });\n  };\n  /**\n   * Deletes the user identified by the provided user id and returns a promise that is\n   * fulfilled when the user is found and successfully deleted.\n   *\n   * @param {string} uid The uid of the user to delete.\n   * @return {Promise<void>} A promise that resolves when the user is successfully deleted.\n   */\n\n\n  BaseAuth.prototype.deleteUser = function (uid) {\n    return this.authRequestHandler.deleteAccount(uid).then(function (response) {// Return nothing on success.\n    });\n  };\n  /**\n   * Updates an existing user with the properties provided.\n   *\n   * @param {string} uid The uid identifier of the user to update.\n   * @param {UpdateRequest} properties The properties to update on the existing user.\n   * @return {Promise<UserRecord>} A promise that resolves with the modified user record.\n   */\n\n\n  BaseAuth.prototype.updateUser = function (uid, properties) {\n    var _this = this;\n\n    return this.authRequestHandler.updateExistingAccount(uid, properties).then(function (existingUid) {\n      // Return the corresponding user record.\n      return _this.getUser(existingUid);\n    });\n  };\n  /**\n   * Sets additional developer claims on an existing user identified by the provided UID.\n   *\n   * @param {string} uid The user to edit.\n   * @param {object} customUserClaims The developer claims to set.\n   * @return {Promise<void>} A promise that resolves when the operation completes\n   *     successfully.\n   */\n\n\n  BaseAuth.prototype.setCustomUserClaims = function (uid, customUserClaims) {\n    return this.authRequestHandler.setCustomUserClaims(uid, customUserClaims).then(function (existingUid) {// Return nothing on success.\n    });\n  };\n  /**\n   * Revokes all refresh tokens for the specified user identified by the provided UID.\n   * In addition to revoking all refresh tokens for a user, all ID tokens issued before\n   * revocation will also be revoked on the Auth backend. Any request with an ID token\n   * generated before revocation will be rejected with a token expired error.\n   *\n   * @param {string} uid The user whose tokens are to be revoked.\n   * @return {Promise<void>} A promise that resolves when the operation completes\n   *     successfully.\n   */\n\n\n  BaseAuth.prototype.revokeRefreshTokens = function (uid) {\n    return this.authRequestHandler.revokeRefreshTokens(uid).then(function (existingUid) {// Return nothing on success.\n    });\n  };\n  /**\n   * Imports the list of users provided to Firebase Auth. This is useful when\n   * migrating from an external authentication system without having to use the Firebase CLI SDK.\n   * At most, 1000 users are allowed to be imported one at a time.\n   * When importing a list of password users, UserImportOptions are required to be specified.\n   *\n   * @param {UserImportRecord[]} users The list of user records to import to Firebase Auth.\n   * @param {UserImportOptions=} options The user import options, required when the users provided\n   *     include password credentials.\n   * @return {Promise<UserImportResult>} A promise that resolves when the operation completes\n   *     with the result of the import. This includes the number of successful imports, the number\n   *     of failed uploads and their corresponding errors.\n   */\n\n\n  BaseAuth.prototype.importUsers = function (users, options) {\n    return this.authRequestHandler.uploadAccount(users, options);\n  };\n  /**\n   * Creates a new Firebase session cookie with the specified options that can be used for\n   * session management (set as a server side session cookie with custom cookie policy).\n   * The session cookie JWT will have the same payload claims as the provided ID token.\n   *\n   * @param {string} idToken The Firebase ID token to exchange for a session cookie.\n   * @param {SessionCookieOptions} sessionCookieOptions The session cookie options which includes\n   *     custom session duration.\n   *\n   * @return {Promise<string>} A promise that resolves on success with the created session cookie.\n   */\n\n\n  BaseAuth.prototype.createSessionCookie = function (idToken, sessionCookieOptions) {\n    // Return rejected promise if expiresIn is not available.\n    if (!validator.isNonNullObject(sessionCookieOptions) || !validator.isNumber(sessionCookieOptions.expiresIn)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION));\n    }\n\n    return this.authRequestHandler.createSessionCookie(idToken, sessionCookieOptions.expiresIn);\n  };\n  /**\n   * Verifies a Firebase session cookie. Returns a Promise with the tokens claims. Rejects\n   * the promise if the token could not be verified. If checkRevoked is set to true,\n   * verifies if the session corresponding to the session cookie was revoked. If the corresponding\n   * user's session was invalidated, an auth/session-cookie-revoked error is thrown. If not\n   * specified the check is not performed.\n   *\n   * @param {string} sessionCookie The session cookie to verify.\n   * @param {boolean=} checkRevoked Whether to check if the session cookie is revoked.\n   * @return {Promise<DecodedIdToken>} A Promise that will be fulfilled after a successful\n   *     verification.\n   */\n\n\n  BaseAuth.prototype.verifySessionCookie = function (sessionCookie, checkRevoked) {\n    var _this = this;\n\n    if (checkRevoked === void 0) {\n      checkRevoked = false;\n    }\n\n    return this.sessionCookieVerifier.verifyJWT(sessionCookie).then(function (decodedIdToken) {\n      // Whether to check if the token was revoked.\n      if (!checkRevoked) {\n        return decodedIdToken;\n      }\n\n      return _this.verifyDecodedJWTNotRevoked(decodedIdToken, error_1.AuthClientErrorCode.SESSION_COOKIE_REVOKED);\n    });\n  };\n  /**\n   * Generates the out of band email action link for password reset flows for the\n   * email specified using the action code settings provided.\n   * Returns a promise that resolves with the generated link.\n   *\n   * @param {string} email The email of the user whose password is to be reset.\n   * @param {ActionCodeSettings=} actionCodeSettings The optional action code setings which defines whether\n   *     the link is to be handled by a mobile app and the additional state information to be passed in the\n   *     deep link, etc.\n   * @return {Promise<string>} A promise that resolves with the password reset link.\n   */\n\n\n  BaseAuth.prototype.generatePasswordResetLink = function (email, actionCodeSettings) {\n    return this.authRequestHandler.getEmailActionLink('PASSWORD_RESET', email, actionCodeSettings);\n  };\n  /**\n   * Generates the out of band email action link for email verification flows for the\n   * email specified using the action code settings provided.\n   * Returns a promise that resolves with the generated link.\n   *\n   * @param {string} email The email of the user to be verified.\n   * @param {ActionCodeSettings=} actionCodeSettings The optional action code setings which defines whether\n   *     the link is to be handled by a mobile app and the additional state information to be passed in the\n   *     deep link, etc.\n   * @return {Promise<string>} A promise that resolves with the email verification link.\n   */\n\n\n  BaseAuth.prototype.generateEmailVerificationLink = function (email, actionCodeSettings) {\n    return this.authRequestHandler.getEmailActionLink('VERIFY_EMAIL', email, actionCodeSettings);\n  };\n  /**\n   * Generates the out of band email action link for email link sign-in flows for the\n   * email specified using the action code settings provided.\n   * Returns a promise that resolves with the generated link.\n   *\n   * @param {string} email The email of the user signing in.\n   * @param {ActionCodeSettings} actionCodeSettings The required action code setings which defines whether\n   *     the link is to be handled by a mobile app and the additional state information to be passed in the\n   *     deep link, etc.\n   * @return {Promise<string>} A promise that resolves with the email sign-in link.\n   */\n\n\n  BaseAuth.prototype.generateSignInWithEmailLink = function (email, actionCodeSettings) {\n    return this.authRequestHandler.getEmailActionLink('EMAIL_SIGNIN', email, actionCodeSettings);\n  };\n  /**\n   * Returns the list of existing provider configuation matching the filter provided.\n   * At most, 100 provider configs are allowed to be imported at a time.\n   *\n   * @param {AuthProviderConfigFilter} options The provider config filter to apply.\n   * @return {Promise<ListProviderConfigResults>} A promise that resolves with the list of provider configs\n   *     meeting the filter requirements.\n   */\n\n\n  BaseAuth.prototype.listProviderConfigs = function (options) {\n    var processResponse = function (response, providerConfigs) {\n      // Return list of provider configuration and the next page token if available.\n      var result = {\n        providerConfigs: providerConfigs\n      }; // Delete result.pageToken if undefined.\n\n      if (response.hasOwnProperty('nextPageToken')) {\n        result.pageToken = response.nextPageToken;\n      }\n\n      return result;\n    };\n\n    if (options && options.type === 'oidc') {\n      return this.authRequestHandler.listOAuthIdpConfigs(options.maxResults, options.pageToken).then(function (response) {\n        // List of provider configurations to return.\n        var providerConfigs = []; // Convert each provider config response to a OIDCConfig.\n\n        response.oauthIdpConfigs.forEach(function (configResponse) {\n          providerConfigs.push(new auth_config_1.OIDCConfig(configResponse));\n        }); // Return list of provider configuration and the next page token if available.\n\n        return processResponse(response, providerConfigs);\n      });\n    } else if (options && options.type === 'saml') {\n      return this.authRequestHandler.listInboundSamlConfigs(options.maxResults, options.pageToken).then(function (response) {\n        // List of provider configurations to return.\n        var providerConfigs = []; // Convert each provider config response to a SAMLConfig.\n\n        response.inboundSamlConfigs.forEach(function (configResponse) {\n          providerConfigs.push(new auth_config_1.SAMLConfig(configResponse));\n        }); // Return list of provider configuration and the next page token if available.\n\n        return processResponse(response, providerConfigs);\n      });\n    }\n\n    return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"\\\"AuthProviderConfigFilter.type\\\" must be either \\\"saml' or \\\"oidc\\\"\"));\n  };\n  /**\n   * Looks up an Auth provider configuration by ID.\n   * Returns a promise that resolves with the provider configuration corresponding to the provider ID specified.\n   *\n   * @param {string} providerId  The provider ID corresponding to the provider config to return.\n   * @return {Promise<AuthProviderConfig>}\n   */\n\n\n  BaseAuth.prototype.getProviderConfig = function (providerId) {\n    if (auth_config_1.OIDCConfig.isProviderId(providerId)) {\n      return this.authRequestHandler.getOAuthIdpConfig(providerId).then(function (response) {\n        return new auth_config_1.OIDCConfig(response);\n      });\n    } else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {\n      return this.authRequestHandler.getInboundSamlConfig(providerId).then(function (response) {\n        return new auth_config_1.SAMLConfig(response);\n      });\n    }\n\n    return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n  };\n  /**\n   * Deletes the provider configuration corresponding to the provider ID passed.\n   *\n   * @param {string} providerId The provider ID corresponding to the provider config to delete.\n   * @return {Promise<void>} A promise that resolves on completion.\n   */\n\n\n  BaseAuth.prototype.deleteProviderConfig = function (providerId) {\n    if (auth_config_1.OIDCConfig.isProviderId(providerId)) {\n      return this.authRequestHandler.deleteOAuthIdpConfig(providerId);\n    } else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {\n      return this.authRequestHandler.deleteInboundSamlConfig(providerId);\n    }\n\n    return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n  };\n  /**\n   * Returns a promise that resolves with the updated AuthProviderConfig when the provider configuration corresponding\n   * to the provider ID specified is updated with the specified configuration.\n   *\n   * @param {string} providerId The provider ID corresponding to the provider config to update.\n   * @param {UpdateAuthProviderRequest} updatedConfig The updated configuration.\n   * @return {Promise<AuthProviderConfig>} A promise that resolves with the updated provider configuration.\n   */\n\n\n  BaseAuth.prototype.updateProviderConfig = function (providerId, updatedConfig) {\n    if (!validator.isNonNullObject(updatedConfig)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, 'Request is missing \"UpdateAuthProviderRequest\" configuration.'));\n    }\n\n    if (auth_config_1.OIDCConfig.isProviderId(providerId)) {\n      return this.authRequestHandler.updateOAuthIdpConfig(providerId, updatedConfig).then(function (response) {\n        return new auth_config_1.OIDCConfig(response);\n      });\n    } else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {\n      return this.authRequestHandler.updateInboundSamlConfig(providerId, updatedConfig).then(function (response) {\n        return new auth_config_1.SAMLConfig(response);\n      });\n    }\n\n    return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n  };\n  /**\n   * Returns a promise that resolves with the newly created AuthProviderConfig when the new provider configuration is\n   * created.\n   * @param {AuthProviderConfig} config The provider configuration to create.\n   * @return {Promise<AuthProviderConfig>} A promise that resolves with the created provider configuration.\n   */\n\n\n  BaseAuth.prototype.createProviderConfig = function (config) {\n    if (!validator.isNonNullObject(config)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, 'Request is missing \"AuthProviderConfig\" configuration.'));\n    }\n\n    if (auth_config_1.OIDCConfig.isProviderId(config.providerId)) {\n      return this.authRequestHandler.createOAuthIdpConfig(config).then(function (response) {\n        return new auth_config_1.OIDCConfig(response);\n      });\n    } else if (auth_config_1.SAMLConfig.isProviderId(config.providerId)) {\n      return this.authRequestHandler.createInboundSamlConfig(config).then(function (response) {\n        return new auth_config_1.SAMLConfig(response);\n      });\n    }\n\n    return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n  };\n  /**\n   * Verifies the decoded Firebase issued JWT is not revoked. Returns a promise that resolves\n   * with the decoded claims on success. Rejects the promise with revocation error if revoked.\n   *\n   * @param {DecodedIdToken} decodedIdToken The JWT's decoded claims.\n   * @param {ErrorInfo} revocationErrorInfo The revocation error info to throw on revocation\n   *     detection.\n   * @return {Promise<DecodedIdToken>} A Promise that will be fulfilled after a successful\n   *     verification.\n   */\n\n\n  BaseAuth.prototype.verifyDecodedJWTNotRevoked = function (decodedIdToken, revocationErrorInfo) {\n    // Get tokens valid after time for the corresponding user.\n    return this.getUser(decodedIdToken.sub).then(function (user) {\n      // If no tokens valid after time available, token is not revoked.\n      if (user.tokensValidAfterTime) {\n        // Get the ID token authentication time and convert to milliseconds UTC.\n        var authTimeUtc = decodedIdToken.auth_time * 1000; // Get user tokens valid after time in milliseconds UTC.\n\n        var validSinceUtc = new Date(user.tokensValidAfterTime).getTime(); // Check if authentication time is older than valid since time.\n\n        if (authTimeUtc < validSinceUtc) {\n          throw new error_1.FirebaseAuthError(revocationErrorInfo);\n        }\n      } // All checks above passed. Return the decoded token.\n\n\n      return decodedIdToken;\n    });\n  };\n\n  return BaseAuth;\n}();\n\nexports.BaseAuth = BaseAuth;\n/**\n * The tenant aware Auth class.\n */\n\nvar TenantAwareAuth =\n/** @class */\nfunction (_super) {\n  __extends(TenantAwareAuth, _super);\n  /**\n   * The TenantAwareAuth class constructor.\n   *\n   * @param {object} app The app that created this tenant.\n   * @param tenantId The corresponding tenant ID.\n   * @constructor\n   */\n\n\n  function TenantAwareAuth(app, tenantId) {\n    var _this = _super.call(this, app, new auth_api_request_1.TenantAwareAuthRequestHandler(app, tenantId)) || this;\n\n    utils.addReadonlyGetter(_this, 'tenantId', tenantId);\n    return _this;\n  }\n  /**\n   * Creates a new custom token that can be sent back to a client to use with\n   * signInWithCustomToken().\n   *\n   * @param {string} uid The uid to use as the JWT subject.\n   * @param {object=} developerClaims Optional additional claims to include in the JWT payload.\n   *\n   * @return {Promise<string>} A JWT for the provided payload.\n   */\n\n\n  TenantAwareAuth.prototype.createCustomToken = function (uid, developerClaims) {\n    // This is not yet supported by the Auth server. It is also not yet determined how this will be\n    // supported.\n    return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.UNSUPPORTED_TENANT_OPERATION));\n  };\n  /**\n   * Verifies a JWT auth token. Returns a Promise with the tokens claims. Rejects\n   * the promise if the token could not be verified. If checkRevoked is set to true,\n   * verifies if the session corresponding to the ID token was revoked. If the corresponding\n   * user's session was invalidated, an auth/id-token-revoked error is thrown. If not specified\n   * the check is not applied.\n   *\n   * @param {string} idToken The JWT to verify.\n   * @param {boolean=} checkRevoked Whether to check if the ID token is revoked.\n   * @return {Promise<DecodedIdToken>} A Promise that will be fulfilled after a successful\n   *     verification.\n   */\n\n\n  TenantAwareAuth.prototype.verifyIdToken = function (idToken, checkRevoked) {\n    var _this = this;\n\n    if (checkRevoked === void 0) {\n      checkRevoked = false;\n    }\n\n    return _super.prototype.verifyIdToken.call(this, idToken, checkRevoked).then(function (decodedClaims) {\n      // Validate tenant ID.\n      if (decodedClaims.firebase.tenant !== _this.tenantId) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISMATCHING_TENANT_ID);\n      }\n\n      return decodedClaims;\n    });\n  };\n  /**\n   * Creates a new Firebase session cookie with the specified options that can be used for\n   * session management (set as a server side session cookie with custom cookie policy).\n   * The session cookie JWT will have the same payload claims as the provided ID token.\n   *\n   * @param {string} idToken The Firebase ID token to exchange for a session cookie.\n   * @param {SessionCookieOptions} sessionCookieOptions The session cookie options which includes\n   *     custom session duration.\n   *\n   * @return {Promise<string>} A promise that resolves on success with the created session cookie.\n   */\n\n\n  TenantAwareAuth.prototype.createSessionCookie = function (idToken, sessionCookieOptions) {\n    var _this = this; // Validate arguments before processing.\n\n\n    if (!validator.isNonEmptyString(idToken)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ID_TOKEN));\n    }\n\n    if (!validator.isNonNullObject(sessionCookieOptions) || !validator.isNumber(sessionCookieOptions.expiresIn)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION));\n    } // This will verify the ID token and then match the tenant ID before creating the session cookie.\n\n\n    return this.verifyIdToken(idToken).then(function (decodedIdTokenClaims) {\n      return _super.prototype.createSessionCookie.call(_this, idToken, sessionCookieOptions);\n    });\n  };\n  /**\n   * Verifies a Firebase session cookie. Returns a Promise with the tokens claims. Rejects\n   * the promise if the token could not be verified. If checkRevoked is set to true,\n   * verifies if the session corresponding to the session cookie was revoked. If the corresponding\n   * user's session was invalidated, an auth/session-cookie-revoked error is thrown. If not\n   * specified the check is not performed.\n   *\n   * @param {string} sessionCookie The session cookie to verify.\n   * @param {boolean=} checkRevoked Whether to check if the session cookie is revoked.\n   * @return {Promise<DecodedIdToken>} A Promise that will be fulfilled after a successful\n   *     verification.\n   */\n\n\n  TenantAwareAuth.prototype.verifySessionCookie = function (sessionCookie, checkRevoked) {\n    var _this = this;\n\n    if (checkRevoked === void 0) {\n      checkRevoked = false;\n    }\n\n    return _super.prototype.verifySessionCookie.call(this, sessionCookie, checkRevoked).then(function (decodedClaims) {\n      if (decodedClaims.firebase.tenant !== _this.tenantId) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISMATCHING_TENANT_ID);\n      }\n\n      return decodedClaims;\n    });\n  };\n\n  return TenantAwareAuth;\n}(BaseAuth);\n\nexports.TenantAwareAuth = TenantAwareAuth;\n/**\n * Auth service bound to the provided app.\n * An Auth instance can have multiple tenants.\n */\n\nvar Auth =\n/** @class */\nfunction (_super) {\n  __extends(Auth, _super);\n  /**\n   * @param {object} app The app for this Auth service.\n   * @constructor\n   */\n\n\n  function Auth(app) {\n    var _this = _super.call(this, app, new auth_api_request_1.AuthRequestHandler(app)) || this;\n\n    _this.INTERNAL = new AuthInternals();\n    _this.app_ = app;\n    _this.tenantManager_ = new tenant_manager_1.TenantManager(app);\n    return _this;\n  }\n\n  Object.defineProperty(Auth.prototype, \"app\", {\n    /**\n     * Returns the app associated with this Auth instance.\n     *\n     * @return {FirebaseApp} The app associated with this Auth instance.\n     */\n    get: function () {\n      return this.app_;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /** @return The current Auth instance's tenant manager. */\n\n  Auth.prototype.tenantManager = function () {\n    return this.tenantManager_;\n  };\n\n  return Auth;\n}(BaseAuth);\n\nexports.Auth = Auth;","map":{"version":3,"sources":["/home/strider/Desktop/github/klaviyo-weather-powered-email/frontend/node_modules/firebase-admin/lib/auth/auth.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","defineProperty","exports","value","user_record_1","require","token_generator_1","auth_api_request_1","error_1","utils","validator","token_verifier_1","auth_config_1","tenant_manager_1","AuthInternals","delete","Promise","resolve","undefined","BaseAuth","app","authRequestHandler","cryptoSigner","cryptoSignerFromApp","tokenGenerator","FirebaseTokenGenerator","projectId","getProjectId","httpAgent","options","sessionCookieVerifier","createSessionCookieVerifier","idTokenVerifier","createIdTokenVerifier","createCustomToken","uid","developerClaims","verifyIdToken","idToken","checkRevoked","_this","verifyJWT","then","decodedIdToken","verifyDecodedJWTNotRevoked","AuthClientErrorCode","ID_TOKEN_REVOKED","getUser","getAccountInfoByUid","response","UserRecord","users","getUserByEmail","email","getAccountInfoByEmail","getUserByPhoneNumber","phoneNumber","getAccountInfoByPhoneNumber","listUsers","maxResults","pageToken","downloadAccount","forEach","userResponse","push","result","nextPageToken","createUser","properties","createNewAccount","catch","error","code","FirebaseAuthError","INTERNAL_ERROR","deleteUser","deleteAccount","updateUser","updateExistingAccount","existingUid","setCustomUserClaims","customUserClaims","revokeRefreshTokens","importUsers","uploadAccount","createSessionCookie","sessionCookieOptions","isNonNullObject","isNumber","expiresIn","reject","INVALID_SESSION_COOKIE_DURATION","verifySessionCookie","sessionCookie","SESSION_COOKIE_REVOKED","generatePasswordResetLink","actionCodeSettings","getEmailActionLink","generateEmailVerificationLink","generateSignInWithEmailLink","listProviderConfigs","processResponse","providerConfigs","type","listOAuthIdpConfigs","oauthIdpConfigs","configResponse","OIDCConfig","listInboundSamlConfigs","inboundSamlConfigs","SAMLConfig","INVALID_ARGUMENT","getProviderConfig","providerId","isProviderId","getOAuthIdpConfig","getInboundSamlConfig","INVALID_PROVIDER_ID","deleteProviderConfig","deleteOAuthIdpConfig","deleteInboundSamlConfig","updateProviderConfig","updatedConfig","INVALID_CONFIG","updateOAuthIdpConfig","updateInboundSamlConfig","createProviderConfig","config","createOAuthIdpConfig","createInboundSamlConfig","revocationErrorInfo","sub","user","tokensValidAfterTime","authTimeUtc","auth_time","validSinceUtc","Date","getTime","TenantAwareAuth","_super","tenantId","call","TenantAwareAuthRequestHandler","addReadonlyGetter","UNSUPPORTED_TENANT_OPERATION","decodedClaims","firebase","tenant","MISMATCHING_TENANT_ID","isNonEmptyString","INVALID_ID_TOKEN","decodedIdTokenClaims","Auth","AuthRequestHandler","INTERNAL","app_","tenantManager_","TenantManager","get","enumerable","configurable","tenantManager"],"mappings":"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","sourcesContent":["/*! firebase-admin v8.8.0 */\n\"use strict\";\n/*!\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar user_record_1 = require(\"./user-record\");\nvar token_generator_1 = require(\"./token-generator\");\nvar auth_api_request_1 = require(\"./auth-api-request\");\nvar error_1 = require(\"../utils/error\");\nvar utils = require(\"../utils/index\");\nvar validator = require(\"../utils/validator\");\nvar token_verifier_1 = require(\"./token-verifier\");\nvar auth_config_1 = require(\"./auth-config\");\nvar tenant_manager_1 = require(\"./tenant-manager\");\n/**\n * Internals of an Auth instance.\n */\nvar AuthInternals = /** @class */ (function () {\n    function AuthInternals() {\n    }\n    /**\n     * Deletes the service and its associated resources.\n     *\n     * @return {Promise<()>} An empty Promise that will be fulfilled when the service is deleted.\n     */\n    AuthInternals.prototype.delete = function () {\n        // There are no resources to clean up\n        return Promise.resolve(undefined);\n    };\n    return AuthInternals;\n}());\n/**\n * Base Auth class. Mainly used for user management APIs.\n */\nvar BaseAuth = /** @class */ (function () {\n    /**\n     * The BaseAuth class constructor.\n     *\n     * @param {string} projectId The corresponding project ID.\n     * @param {T} authRequestHandler The RPC request handler\n     *     for this instance.\n     * @param {CryptoSigner} cryptoSigner The instance crypto signer used for custom token\n     *     minting.\n     * @constructor\n     */\n    function BaseAuth(app, authRequestHandler) {\n        this.authRequestHandler = authRequestHandler;\n        var cryptoSigner = token_generator_1.cryptoSignerFromApp(app);\n        this.tokenGenerator = new token_generator_1.FirebaseTokenGenerator(cryptoSigner);\n        var projectId = utils.getProjectId(app);\n        var httpAgent = app.options.httpAgent;\n        this.sessionCookieVerifier = token_verifier_1.createSessionCookieVerifier(projectId, httpAgent);\n        this.idTokenVerifier = token_verifier_1.createIdTokenVerifier(projectId, httpAgent);\n    }\n    /**\n     * Creates a new custom token that can be sent back to a client to use with\n     * signInWithCustomToken().\n     *\n     * @param {string} uid The uid to use as the JWT subject.\n     * @param {object=} developerClaims Optional additional claims to include in the JWT payload.\n     *\n     * @return {Promise<string>} A JWT for the provided payload.\n     */\n    BaseAuth.prototype.createCustomToken = function (uid, developerClaims) {\n        return this.tokenGenerator.createCustomToken(uid, developerClaims);\n    };\n    /**\n     * Verifies a JWT auth token. Returns a Promise with the tokens claims. Rejects\n     * the promise if the token could not be verified. If checkRevoked is set to true,\n     * verifies if the session corresponding to the ID token was revoked. If the corresponding\n     * user's session was invalidated, an auth/id-token-revoked error is thrown. If not specified\n     * the check is not applied.\n     *\n     * @param {string} idToken The JWT to verify.\n     * @param {boolean=} checkRevoked Whether to check if the ID token is revoked.\n     * @return {Promise<DecodedIdToken>} A Promise that will be fulfilled after a successful\n     *     verification.\n     */\n    BaseAuth.prototype.verifyIdToken = function (idToken, checkRevoked) {\n        var _this = this;\n        if (checkRevoked === void 0) { checkRevoked = false; }\n        return this.idTokenVerifier.verifyJWT(idToken)\n            .then(function (decodedIdToken) {\n            // Whether to check if the token was revoked.\n            if (!checkRevoked) {\n                return decodedIdToken;\n            }\n            return _this.verifyDecodedJWTNotRevoked(decodedIdToken, error_1.AuthClientErrorCode.ID_TOKEN_REVOKED);\n        });\n    };\n    /**\n     * Looks up the user identified by the provided user id and returns a promise that is\n     * fulfilled with a user record for the given user if that user is found.\n     *\n     * @param {string} uid The uid of the user to look up.\n     * @return {Promise<UserRecord>} A promise that resolves with the corresponding user record.\n     */\n    BaseAuth.prototype.getUser = function (uid) {\n        return this.authRequestHandler.getAccountInfoByUid(uid)\n            .then(function (response) {\n            // Returns the user record populated with server response.\n            return new user_record_1.UserRecord(response.users[0]);\n        });\n    };\n    /**\n     * Looks up the user identified by the provided email and returns a promise that is\n     * fulfilled with a user record for the given user if that user is found.\n     *\n     * @param {string} email The email of the user to look up.\n     * @return {Promise<UserRecord>} A promise that resolves with the corresponding user record.\n     */\n    BaseAuth.prototype.getUserByEmail = function (email) {\n        return this.authRequestHandler.getAccountInfoByEmail(email)\n            .then(function (response) {\n            // Returns the user record populated with server response.\n            return new user_record_1.UserRecord(response.users[0]);\n        });\n    };\n    /**\n     * Looks up the user identified by the provided phone number and returns a promise that is\n     * fulfilled with a user record for the given user if that user is found.\n     *\n     * @param {string} phoneNumber The phone number of the user to look up.\n     * @return {Promise<UserRecord>} A promise that resolves with the corresponding user record.\n     */\n    BaseAuth.prototype.getUserByPhoneNumber = function (phoneNumber) {\n        return this.authRequestHandler.getAccountInfoByPhoneNumber(phoneNumber)\n            .then(function (response) {\n            // Returns the user record populated with server response.\n            return new user_record_1.UserRecord(response.users[0]);\n        });\n    };\n    /**\n     * Exports a batch of user accounts. Batch size is determined by the maxResults argument.\n     * Starting point of the batch is determined by the pageToken argument.\n     *\n     * @param {number=} maxResults The page size, 1000 if undefined. This is also the maximum\n     *     allowed limit.\n     * @param {string=} pageToken The next page token. If not specified, returns users starting\n     *     without any offset.\n     * @return {Promise<{users: UserRecord[], pageToken?: string}>} A promise that resolves with\n     *     the current batch of downloaded users and the next page token. For the last page, an\n     *     empty list of users and no page token are returned.\n     */\n    BaseAuth.prototype.listUsers = function (maxResults, pageToken) {\n        return this.authRequestHandler.downloadAccount(maxResults, pageToken)\n            .then(function (response) {\n            // List of users to return.\n            var users = [];\n            // Convert each user response to a UserRecord.\n            response.users.forEach(function (userResponse) {\n                users.push(new user_record_1.UserRecord(userResponse));\n            });\n            // Return list of user records and the next page token if available.\n            var result = {\n                users: users,\n                pageToken: response.nextPageToken,\n            };\n            // Delete result.pageToken if undefined.\n            if (typeof result.pageToken === 'undefined') {\n                delete result.pageToken;\n            }\n            return result;\n        });\n    };\n    /**\n     * Creates a new user with the properties provided.\n     *\n     * @param {CreateRequest} properties The properties to set on the new user record to be created.\n     * @return {Promise<UserRecord>} A promise that resolves with the newly created user record.\n     */\n    BaseAuth.prototype.createUser = function (properties) {\n        var _this = this;\n        return this.authRequestHandler.createNewAccount(properties)\n            .then(function (uid) {\n            // Return the corresponding user record.\n            return _this.getUser(uid);\n        })\n            .catch(function (error) {\n            if (error.code === 'auth/user-not-found') {\n                // Something must have happened after creating the user and then retrieving it.\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Unable to create the user record provided.');\n            }\n            throw error;\n        });\n    };\n    /**\n     * Deletes the user identified by the provided user id and returns a promise that is\n     * fulfilled when the user is found and successfully deleted.\n     *\n     * @param {string} uid The uid of the user to delete.\n     * @return {Promise<void>} A promise that resolves when the user is successfully deleted.\n     */\n    BaseAuth.prototype.deleteUser = function (uid) {\n        return this.authRequestHandler.deleteAccount(uid)\n            .then(function (response) {\n            // Return nothing on success.\n        });\n    };\n    /**\n     * Updates an existing user with the properties provided.\n     *\n     * @param {string} uid The uid identifier of the user to update.\n     * @param {UpdateRequest} properties The properties to update on the existing user.\n     * @return {Promise<UserRecord>} A promise that resolves with the modified user record.\n     */\n    BaseAuth.prototype.updateUser = function (uid, properties) {\n        var _this = this;\n        return this.authRequestHandler.updateExistingAccount(uid, properties)\n            .then(function (existingUid) {\n            // Return the corresponding user record.\n            return _this.getUser(existingUid);\n        });\n    };\n    /**\n     * Sets additional developer claims on an existing user identified by the provided UID.\n     *\n     * @param {string} uid The user to edit.\n     * @param {object} customUserClaims The developer claims to set.\n     * @return {Promise<void>} A promise that resolves when the operation completes\n     *     successfully.\n     */\n    BaseAuth.prototype.setCustomUserClaims = function (uid, customUserClaims) {\n        return this.authRequestHandler.setCustomUserClaims(uid, customUserClaims)\n            .then(function (existingUid) {\n            // Return nothing on success.\n        });\n    };\n    /**\n     * Revokes all refresh tokens for the specified user identified by the provided UID.\n     * In addition to revoking all refresh tokens for a user, all ID tokens issued before\n     * revocation will also be revoked on the Auth backend. Any request with an ID token\n     * generated before revocation will be rejected with a token expired error.\n     *\n     * @param {string} uid The user whose tokens are to be revoked.\n     * @return {Promise<void>} A promise that resolves when the operation completes\n     *     successfully.\n     */\n    BaseAuth.prototype.revokeRefreshTokens = function (uid) {\n        return this.authRequestHandler.revokeRefreshTokens(uid)\n            .then(function (existingUid) {\n            // Return nothing on success.\n        });\n    };\n    /**\n     * Imports the list of users provided to Firebase Auth. This is useful when\n     * migrating from an external authentication system without having to use the Firebase CLI SDK.\n     * At most, 1000 users are allowed to be imported one at a time.\n     * When importing a list of password users, UserImportOptions are required to be specified.\n     *\n     * @param {UserImportRecord[]} users The list of user records to import to Firebase Auth.\n     * @param {UserImportOptions=} options The user import options, required when the users provided\n     *     include password credentials.\n     * @return {Promise<UserImportResult>} A promise that resolves when the operation completes\n     *     with the result of the import. This includes the number of successful imports, the number\n     *     of failed uploads and their corresponding errors.\n     */\n    BaseAuth.prototype.importUsers = function (users, options) {\n        return this.authRequestHandler.uploadAccount(users, options);\n    };\n    /**\n     * Creates a new Firebase session cookie with the specified options that can be used for\n     * session management (set as a server side session cookie with custom cookie policy).\n     * The session cookie JWT will have the same payload claims as the provided ID token.\n     *\n     * @param {string} idToken The Firebase ID token to exchange for a session cookie.\n     * @param {SessionCookieOptions} sessionCookieOptions The session cookie options which includes\n     *     custom session duration.\n     *\n     * @return {Promise<string>} A promise that resolves on success with the created session cookie.\n     */\n    BaseAuth.prototype.createSessionCookie = function (idToken, sessionCookieOptions) {\n        // Return rejected promise if expiresIn is not available.\n        if (!validator.isNonNullObject(sessionCookieOptions) ||\n            !validator.isNumber(sessionCookieOptions.expiresIn)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION));\n        }\n        return this.authRequestHandler.createSessionCookie(idToken, sessionCookieOptions.expiresIn);\n    };\n    /**\n     * Verifies a Firebase session cookie. Returns a Promise with the tokens claims. Rejects\n     * the promise if the token could not be verified. If checkRevoked is set to true,\n     * verifies if the session corresponding to the session cookie was revoked. If the corresponding\n     * user's session was invalidated, an auth/session-cookie-revoked error is thrown. If not\n     * specified the check is not performed.\n     *\n     * @param {string} sessionCookie The session cookie to verify.\n     * @param {boolean=} checkRevoked Whether to check if the session cookie is revoked.\n     * @return {Promise<DecodedIdToken>} A Promise that will be fulfilled after a successful\n     *     verification.\n     */\n    BaseAuth.prototype.verifySessionCookie = function (sessionCookie, checkRevoked) {\n        var _this = this;\n        if (checkRevoked === void 0) { checkRevoked = false; }\n        return this.sessionCookieVerifier.verifyJWT(sessionCookie)\n            .then(function (decodedIdToken) {\n            // Whether to check if the token was revoked.\n            if (!checkRevoked) {\n                return decodedIdToken;\n            }\n            return _this.verifyDecodedJWTNotRevoked(decodedIdToken, error_1.AuthClientErrorCode.SESSION_COOKIE_REVOKED);\n        });\n    };\n    /**\n     * Generates the out of band email action link for password reset flows for the\n     * email specified using the action code settings provided.\n     * Returns a promise that resolves with the generated link.\n     *\n     * @param {string} email The email of the user whose password is to be reset.\n     * @param {ActionCodeSettings=} actionCodeSettings The optional action code setings which defines whether\n     *     the link is to be handled by a mobile app and the additional state information to be passed in the\n     *     deep link, etc.\n     * @return {Promise<string>} A promise that resolves with the password reset link.\n     */\n    BaseAuth.prototype.generatePasswordResetLink = function (email, actionCodeSettings) {\n        return this.authRequestHandler.getEmailActionLink('PASSWORD_RESET', email, actionCodeSettings);\n    };\n    /**\n     * Generates the out of band email action link for email verification flows for the\n     * email specified using the action code settings provided.\n     * Returns a promise that resolves with the generated link.\n     *\n     * @param {string} email The email of the user to be verified.\n     * @param {ActionCodeSettings=} actionCodeSettings The optional action code setings which defines whether\n     *     the link is to be handled by a mobile app and the additional state information to be passed in the\n     *     deep link, etc.\n     * @return {Promise<string>} A promise that resolves with the email verification link.\n     */\n    BaseAuth.prototype.generateEmailVerificationLink = function (email, actionCodeSettings) {\n        return this.authRequestHandler.getEmailActionLink('VERIFY_EMAIL', email, actionCodeSettings);\n    };\n    /**\n     * Generates the out of band email action link for email link sign-in flows for the\n     * email specified using the action code settings provided.\n     * Returns a promise that resolves with the generated link.\n     *\n     * @param {string} email The email of the user signing in.\n     * @param {ActionCodeSettings} actionCodeSettings The required action code setings which defines whether\n     *     the link is to be handled by a mobile app and the additional state information to be passed in the\n     *     deep link, etc.\n     * @return {Promise<string>} A promise that resolves with the email sign-in link.\n     */\n    BaseAuth.prototype.generateSignInWithEmailLink = function (email, actionCodeSettings) {\n        return this.authRequestHandler.getEmailActionLink('EMAIL_SIGNIN', email, actionCodeSettings);\n    };\n    /**\n     * Returns the list of existing provider configuation matching the filter provided.\n     * At most, 100 provider configs are allowed to be imported at a time.\n     *\n     * @param {AuthProviderConfigFilter} options The provider config filter to apply.\n     * @return {Promise<ListProviderConfigResults>} A promise that resolves with the list of provider configs\n     *     meeting the filter requirements.\n     */\n    BaseAuth.prototype.listProviderConfigs = function (options) {\n        var processResponse = function (response, providerConfigs) {\n            // Return list of provider configuration and the next page token if available.\n            var result = {\n                providerConfigs: providerConfigs,\n            };\n            // Delete result.pageToken if undefined.\n            if (response.hasOwnProperty('nextPageToken')) {\n                result.pageToken = response.nextPageToken;\n            }\n            return result;\n        };\n        if (options && options.type === 'oidc') {\n            return this.authRequestHandler.listOAuthIdpConfigs(options.maxResults, options.pageToken)\n                .then(function (response) {\n                // List of provider configurations to return.\n                var providerConfigs = [];\n                // Convert each provider config response to a OIDCConfig.\n                response.oauthIdpConfigs.forEach(function (configResponse) {\n                    providerConfigs.push(new auth_config_1.OIDCConfig(configResponse));\n                });\n                // Return list of provider configuration and the next page token if available.\n                return processResponse(response, providerConfigs);\n            });\n        }\n        else if (options && options.type === 'saml') {\n            return this.authRequestHandler.listInboundSamlConfigs(options.maxResults, options.pageToken)\n                .then(function (response) {\n                // List of provider configurations to return.\n                var providerConfigs = [];\n                // Convert each provider config response to a SAMLConfig.\n                response.inboundSamlConfigs.forEach(function (configResponse) {\n                    providerConfigs.push(new auth_config_1.SAMLConfig(configResponse));\n                });\n                // Return list of provider configuration and the next page token if available.\n                return processResponse(response, providerConfigs);\n            });\n        }\n        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, \"\\\"AuthProviderConfigFilter.type\\\" must be either \\\"saml' or \\\"oidc\\\"\"));\n    };\n    /**\n     * Looks up an Auth provider configuration by ID.\n     * Returns a promise that resolves with the provider configuration corresponding to the provider ID specified.\n     *\n     * @param {string} providerId  The provider ID corresponding to the provider config to return.\n     * @return {Promise<AuthProviderConfig>}\n     */\n    BaseAuth.prototype.getProviderConfig = function (providerId) {\n        if (auth_config_1.OIDCConfig.isProviderId(providerId)) {\n            return this.authRequestHandler.getOAuthIdpConfig(providerId)\n                .then(function (response) {\n                return new auth_config_1.OIDCConfig(response);\n            });\n        }\n        else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {\n            return this.authRequestHandler.getInboundSamlConfig(providerId)\n                .then(function (response) {\n                return new auth_config_1.SAMLConfig(response);\n            });\n        }\n        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n    };\n    /**\n     * Deletes the provider configuration corresponding to the provider ID passed.\n     *\n     * @param {string} providerId The provider ID corresponding to the provider config to delete.\n     * @return {Promise<void>} A promise that resolves on completion.\n     */\n    BaseAuth.prototype.deleteProviderConfig = function (providerId) {\n        if (auth_config_1.OIDCConfig.isProviderId(providerId)) {\n            return this.authRequestHandler.deleteOAuthIdpConfig(providerId);\n        }\n        else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {\n            return this.authRequestHandler.deleteInboundSamlConfig(providerId);\n        }\n        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n    };\n    /**\n     * Returns a promise that resolves with the updated AuthProviderConfig when the provider configuration corresponding\n     * to the provider ID specified is updated with the specified configuration.\n     *\n     * @param {string} providerId The provider ID corresponding to the provider config to update.\n     * @param {UpdateAuthProviderRequest} updatedConfig The updated configuration.\n     * @return {Promise<AuthProviderConfig>} A promise that resolves with the updated provider configuration.\n     */\n    BaseAuth.prototype.updateProviderConfig = function (providerId, updatedConfig) {\n        if (!validator.isNonNullObject(updatedConfig)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, 'Request is missing \"UpdateAuthProviderRequest\" configuration.'));\n        }\n        if (auth_config_1.OIDCConfig.isProviderId(providerId)) {\n            return this.authRequestHandler.updateOAuthIdpConfig(providerId, updatedConfig)\n                .then(function (response) {\n                return new auth_config_1.OIDCConfig(response);\n            });\n        }\n        else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {\n            return this.authRequestHandler.updateInboundSamlConfig(providerId, updatedConfig)\n                .then(function (response) {\n                return new auth_config_1.SAMLConfig(response);\n            });\n        }\n        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n    };\n    /**\n     * Returns a promise that resolves with the newly created AuthProviderConfig when the new provider configuration is\n     * created.\n     * @param {AuthProviderConfig} config The provider configuration to create.\n     * @return {Promise<AuthProviderConfig>} A promise that resolves with the created provider configuration.\n     */\n    BaseAuth.prototype.createProviderConfig = function (config) {\n        if (!validator.isNonNullObject(config)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, 'Request is missing \"AuthProviderConfig\" configuration.'));\n        }\n        if (auth_config_1.OIDCConfig.isProviderId(config.providerId)) {\n            return this.authRequestHandler.createOAuthIdpConfig(config)\n                .then(function (response) {\n                return new auth_config_1.OIDCConfig(response);\n            });\n        }\n        else if (auth_config_1.SAMLConfig.isProviderId(config.providerId)) {\n            return this.authRequestHandler.createInboundSamlConfig(config)\n                .then(function (response) {\n                return new auth_config_1.SAMLConfig(response);\n            });\n        }\n        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));\n    };\n    /**\n     * Verifies the decoded Firebase issued JWT is not revoked. Returns a promise that resolves\n     * with the decoded claims on success. Rejects the promise with revocation error if revoked.\n     *\n     * @param {DecodedIdToken} decodedIdToken The JWT's decoded claims.\n     * @param {ErrorInfo} revocationErrorInfo The revocation error info to throw on revocation\n     *     detection.\n     * @return {Promise<DecodedIdToken>} A Promise that will be fulfilled after a successful\n     *     verification.\n     */\n    BaseAuth.prototype.verifyDecodedJWTNotRevoked = function (decodedIdToken, revocationErrorInfo) {\n        // Get tokens valid after time for the corresponding user.\n        return this.getUser(decodedIdToken.sub)\n            .then(function (user) {\n            // If no tokens valid after time available, token is not revoked.\n            if (user.tokensValidAfterTime) {\n                // Get the ID token authentication time and convert to milliseconds UTC.\n                var authTimeUtc = decodedIdToken.auth_time * 1000;\n                // Get user tokens valid after time in milliseconds UTC.\n                var validSinceUtc = new Date(user.tokensValidAfterTime).getTime();\n                // Check if authentication time is older than valid since time.\n                if (authTimeUtc < validSinceUtc) {\n                    throw new error_1.FirebaseAuthError(revocationErrorInfo);\n                }\n            }\n            // All checks above passed. Return the decoded token.\n            return decodedIdToken;\n        });\n    };\n    return BaseAuth;\n}());\nexports.BaseAuth = BaseAuth;\n/**\n * The tenant aware Auth class.\n */\nvar TenantAwareAuth = /** @class */ (function (_super) {\n    __extends(TenantAwareAuth, _super);\n    /**\n     * The TenantAwareAuth class constructor.\n     *\n     * @param {object} app The app that created this tenant.\n     * @param tenantId The corresponding tenant ID.\n     * @constructor\n     */\n    function TenantAwareAuth(app, tenantId) {\n        var _this = _super.call(this, app, new auth_api_request_1.TenantAwareAuthRequestHandler(app, tenantId)) || this;\n        utils.addReadonlyGetter(_this, 'tenantId', tenantId);\n        return _this;\n    }\n    /**\n     * Creates a new custom token that can be sent back to a client to use with\n     * signInWithCustomToken().\n     *\n     * @param {string} uid The uid to use as the JWT subject.\n     * @param {object=} developerClaims Optional additional claims to include in the JWT payload.\n     *\n     * @return {Promise<string>} A JWT for the provided payload.\n     */\n    TenantAwareAuth.prototype.createCustomToken = function (uid, developerClaims) {\n        // This is not yet supported by the Auth server. It is also not yet determined how this will be\n        // supported.\n        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.UNSUPPORTED_TENANT_OPERATION));\n    };\n    /**\n     * Verifies a JWT auth token. Returns a Promise with the tokens claims. Rejects\n     * the promise if the token could not be verified. If checkRevoked is set to true,\n     * verifies if the session corresponding to the ID token was revoked. If the corresponding\n     * user's session was invalidated, an auth/id-token-revoked error is thrown. If not specified\n     * the check is not applied.\n     *\n     * @param {string} idToken The JWT to verify.\n     * @param {boolean=} checkRevoked Whether to check if the ID token is revoked.\n     * @return {Promise<DecodedIdToken>} A Promise that will be fulfilled after a successful\n     *     verification.\n     */\n    TenantAwareAuth.prototype.verifyIdToken = function (idToken, checkRevoked) {\n        var _this = this;\n        if (checkRevoked === void 0) { checkRevoked = false; }\n        return _super.prototype.verifyIdToken.call(this, idToken, checkRevoked)\n            .then(function (decodedClaims) {\n            // Validate tenant ID.\n            if (decodedClaims.firebase.tenant !== _this.tenantId) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISMATCHING_TENANT_ID);\n            }\n            return decodedClaims;\n        });\n    };\n    /**\n     * Creates a new Firebase session cookie with the specified options that can be used for\n     * session management (set as a server side session cookie with custom cookie policy).\n     * The session cookie JWT will have the same payload claims as the provided ID token.\n     *\n     * @param {string} idToken The Firebase ID token to exchange for a session cookie.\n     * @param {SessionCookieOptions} sessionCookieOptions The session cookie options which includes\n     *     custom session duration.\n     *\n     * @return {Promise<string>} A promise that resolves on success with the created session cookie.\n     */\n    TenantAwareAuth.prototype.createSessionCookie = function (idToken, sessionCookieOptions) {\n        var _this = this;\n        // Validate arguments before processing.\n        if (!validator.isNonEmptyString(idToken)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ID_TOKEN));\n        }\n        if (!validator.isNonNullObject(sessionCookieOptions) ||\n            !validator.isNumber(sessionCookieOptions.expiresIn)) {\n            return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION));\n        }\n        // This will verify the ID token and then match the tenant ID before creating the session cookie.\n        return this.verifyIdToken(idToken)\n            .then(function (decodedIdTokenClaims) {\n            return _super.prototype.createSessionCookie.call(_this, idToken, sessionCookieOptions);\n        });\n    };\n    /**\n     * Verifies a Firebase session cookie. Returns a Promise with the tokens claims. Rejects\n     * the promise if the token could not be verified. If checkRevoked is set to true,\n     * verifies if the session corresponding to the session cookie was revoked. If the corresponding\n     * user's session was invalidated, an auth/session-cookie-revoked error is thrown. If not\n     * specified the check is not performed.\n     *\n     * @param {string} sessionCookie The session cookie to verify.\n     * @param {boolean=} checkRevoked Whether to check if the session cookie is revoked.\n     * @return {Promise<DecodedIdToken>} A Promise that will be fulfilled after a successful\n     *     verification.\n     */\n    TenantAwareAuth.prototype.verifySessionCookie = function (sessionCookie, checkRevoked) {\n        var _this = this;\n        if (checkRevoked === void 0) { checkRevoked = false; }\n        return _super.prototype.verifySessionCookie.call(this, sessionCookie, checkRevoked)\n            .then(function (decodedClaims) {\n            if (decodedClaims.firebase.tenant !== _this.tenantId) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISMATCHING_TENANT_ID);\n            }\n            return decodedClaims;\n        });\n    };\n    return TenantAwareAuth;\n}(BaseAuth));\nexports.TenantAwareAuth = TenantAwareAuth;\n/**\n * Auth service bound to the provided app.\n * An Auth instance can have multiple tenants.\n */\nvar Auth = /** @class */ (function (_super) {\n    __extends(Auth, _super);\n    /**\n     * @param {object} app The app for this Auth service.\n     * @constructor\n     */\n    function Auth(app) {\n        var _this = _super.call(this, app, new auth_api_request_1.AuthRequestHandler(app)) || this;\n        _this.INTERNAL = new AuthInternals();\n        _this.app_ = app;\n        _this.tenantManager_ = new tenant_manager_1.TenantManager(app);\n        return _this;\n    }\n    Object.defineProperty(Auth.prototype, \"app\", {\n        /**\n         * Returns the app associated with this Auth instance.\n         *\n         * @return {FirebaseApp} The app associated with this Auth instance.\n         */\n        get: function () {\n            return this.app_;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /** @return The current Auth instance's tenant manager. */\n    Auth.prototype.tenantManager = function () {\n        return this.tenantManager_;\n    };\n    return Auth;\n}(BaseAuth));\nexports.Auth = Auth;\n"]},"metadata":{},"sourceType":"script"}