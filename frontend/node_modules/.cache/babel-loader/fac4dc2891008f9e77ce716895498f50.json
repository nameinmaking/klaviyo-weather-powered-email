{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst path_1 = require(\"./path\");\n\nconst reference_1 = require(\"./reference\");\n\nconst serializer_1 = require(\"./serializer\");\n\nconst util_1 = require(\"./util\");\n\nconst validate_1 = require(\"./validate\");\n/*!\n * Error message for transactional reads that were executed after performing\n * writes.\n */\n\n\nconst READ_AFTER_WRITE_ERROR_MSG = 'Firestore transactions require all reads to be executed before all writes.';\n/*!\n * Transactions can be retried if the initial stream opening errors out.\n */\n\nconst ALLOW_RETRIES = true;\n/**\n * A reference to a transaction.\n *\n * The Transaction object passed to a transaction's updateFunction provides\n * the methods to read and write data within the transaction context. See\n * [runTransaction()]{@link Firestore#runTransaction}.\n *\n * @class\n */\n\nclass Transaction {\n  /**\n   * @hideconstructor\n   *\n   * @param firestore The Firestore Database client.\n   * @param requestTag A unique client-assigned identifier for the scope of\n   * this transaction.\n   * @param previousTransaction If available, the failed transaction that is\n   * being retried.\n   */\n  constructor(firestore, requestTag, previousTransaction) {\n    this._firestore = firestore;\n    this._transactionId = previousTransaction && previousTransaction._transactionId;\n    this._writeBatch = firestore.batch();\n    this._requestTag = requestTag;\n  }\n  /**\n   * Retrieve a document or a query result from the database. Holds a\n   * pessimistic lock on all returned documents.\n   *\n   * @param {DocumentReference|Query} refOrQuery The document or query to\n   * return.\n   * @returns {Promise} A Promise that resolves with a DocumentSnapshot or\n   * QuerySnapshot for the returned documents.\n   *\n   * @example\n   * firestore.runTransaction(transaction => {\n   *   let documentRef = firestore.doc('col/doc');\n   *   return transaction.get(documentRef).then(doc => {\n   *     if (doc.exists) {\n   *       transaction.update(documentRef, { count: doc.get('count') + 1 });\n   *     } else {\n   *       transaction.create(documentRef, { count: 1 });\n   *     }\n   *   });\n   * });\n   */\n\n\n  get(refOrQuery) {\n    if (!this._writeBatch.isEmpty) {\n      throw new Error(READ_AFTER_WRITE_ERROR_MSG);\n    }\n\n    if (refOrQuery instanceof reference_1.DocumentReference) {\n      return this._firestore.getAll_([refOrQuery],\n      /* fieldMask= */\n      null, this._requestTag, this._transactionId).then(res => {\n        return Promise.resolve(res[0]);\n      });\n    }\n\n    if (refOrQuery instanceof reference_1.Query) {\n      return refOrQuery._get(this._transactionId);\n    }\n\n    throw new Error('Value for argument \"refOrQuery\" must be a DocumentReference or a Query.');\n  }\n  /**\n   * Retrieves multiple documents from Firestore. Holds a pessimistic lock on\n   * all returned documents.\n   *\n   * The first argument is required and must be of type `DocumentReference`\n   * followed by any additional `DocumentReference` documents. If used, the\n   * optional `ReadOptions` must be the last argument.\n   *\n   * @param {...DocumentReference|ReadOptions} documentRefsOrReadOptions The\n   * `DocumentReferences` to receive, followed by an optional field mask.\n   * @returns {Promise<Array.<DocumentSnapshot>>} A Promise that\n   * contains an array with the resulting document snapshots.\n   *\n   * @example\n   * let firstDoc = firestore.doc('col/doc1');\n   * let secondDoc = firestore.doc('col/doc2');\n   * let resultDoc = firestore.doc('col/doc3');\n   *\n   * firestore.runTransaction(transaction => {\n   *   return transaction.getAll(firstDoc, secondDoc).then(docs => {\n   *     transaction.set(resultDoc, {\n   *       sum: docs[0].get('count') + docs[1].get('count')\n   *     });\n   *   });\n   * });\n   */\n\n\n  getAll(...documentRefsOrReadOptions) {\n    if (!this._writeBatch.isEmpty) {\n      throw new Error(READ_AFTER_WRITE_ERROR_MSG);\n    }\n\n    validate_1.validateMinNumberOfArguments('Transaction.getAll', arguments, 1);\n\n    const _parseGetAllArguments = parseGetAllArguments(documentRefsOrReadOptions),\n          documents = _parseGetAllArguments.documents,\n          fieldMask = _parseGetAllArguments.fieldMask;\n\n    return this._firestore.getAll_(documents, fieldMask, this._requestTag, this._transactionId);\n  }\n  /**\n   * Create the document referred to by the provided\n   * [DocumentReference]{@link DocumentReference}. The operation will\n   * fail the transaction if a document exists at the specified location.\n   *\n   * @param {DocumentReference} documentRef A reference to the document to be\n   * created.\n   * @param {DocumentData} data The object data to serialize as the document.\n   * @returns {Transaction} This Transaction instance. Used for\n   * chaining method calls.\n   *\n   * @example\n   * firestore.runTransaction(transaction => {\n   *   let documentRef = firestore.doc('col/doc');\n   *   return transaction.get(documentRef).then(doc => {\n   *     if (!doc.exists) {\n   *       transaction.create(documentRef, { foo: 'bar' });\n   *     }\n   *   });\n   * });\n   */\n\n\n  create(documentRef, data) {\n    this._writeBatch.create(documentRef, data);\n\n    return this;\n  }\n  /**\n   * Writes to the document referred to by the provided\n   * [DocumentReference]{@link DocumentReference}. If the document\n   * does not exist yet, it will be created. If you pass\n   * [SetOptions]{@link SetOptions}, the provided data can be merged into the\n   * existing document.\n   *\n   * @param {DocumentReference} documentRef A reference to the document to be\n   * set.\n   * @param {DocumentData} data The object to serialize as the document.\n   * @param {SetOptions=} options An object to configure the set behavior.\n   * @param {boolean=} options.merge - If true, set() merges the values\n   * specified in its data argument. Fields omitted from this set() call\n   * remain untouched.\n   * @param {Array.<string|FieldPath>=} options.mergeFields - If provided,\n   * set() only replaces the specified field paths. Any field path that is not\n   * specified is ignored and remains untouched.\n   * @returns {Transaction} This Transaction instance. Used for\n   * chaining method calls.\n   *\n   * @example\n   * firestore.runTransaction(transaction => {\n   *   let documentRef = firestore.doc('col/doc');\n   *   transaction.set(documentRef, { foo: 'bar' });\n   *   return Promise.resolve();\n   * });\n   */\n\n\n  set(documentRef, data, options) {\n    this._writeBatch.set(documentRef, data, options);\n\n    return this;\n  }\n  /**\n   * Updates fields in the document referred to by the provided\n   * [DocumentReference]{@link DocumentReference}. The update will\n   * fail if applied to a document that does not exist.\n   *\n   * The update() method accepts either an object with field paths encoded as\n   * keys and field values encoded as values, or a variable number of arguments\n   * that alternate between field paths and field values. Nested fields can be\n   * updated by providing dot-separated field path strings or by providing\n   * FieldPath objects.\n   *\n   * A Precondition restricting this update can be specified as the last\n   * argument.\n   *\n   * @param {DocumentReference} documentRef A reference to the document to be\n   * updated.\n   * @param {UpdateData|string|FieldPath} dataOrField An object\n   * containing the fields and values with which to update the document\n   * or the path of the first field to update.\n   * @param {\n   * ...(Precondition|*|string|FieldPath)} preconditionOrValues -\n   * An alternating list of field paths and values to update or a Precondition\n   * to to enforce on this update.\n   * @returns {Transaction} This Transaction instance. Used for\n   * chaining method calls.\n   *\n   * @example\n   * firestore.runTransaction(transaction => {\n   *   let documentRef = firestore.doc('col/doc');\n   *   return transaction.get(documentRef).then(doc => {\n   *     if (doc.exists) {\n   *       transaction.update(documentRef, { count: doc.get('count') + 1 });\n   *     } else {\n   *       transaction.create(documentRef, { count: 1 });\n   *     }\n   *   });\n   * });\n   */\n\n\n  update(documentRef, dataOrField, ...preconditionOrValues) {\n    validate_1.validateMinNumberOfArguments('Transaction.update', arguments, 2);\n\n    this._writeBatch.update.apply(this._writeBatch, [documentRef, dataOrField, ...preconditionOrValues]);\n\n    return this;\n  }\n  /**\n   * Deletes the document referred to by the provided [DocumentReference]\n   * {@link DocumentReference}.\n   *\n   * @param {DocumentReference} documentRef A reference to the document to be\n   * deleted.\n   * @param {Precondition=} precondition A precondition to enforce for this\n   * delete.\n   * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n   * document was last updated at lastUpdateTime. Fails the transaction if the\n   * document doesn't exist or was last updated at a different time.\n   * @returns {Transaction} This Transaction instance. Used for\n   * chaining method calls.\n   *\n   * @example\n   * firestore.runTransaction(transaction => {\n   *   let documentRef = firestore.doc('col/doc');\n   *   transaction.delete(documentRef);\n   *   return Promise.resolve();\n   * });\n   */\n\n\n  delete(documentRef, precondition) {\n    this._writeBatch.delete(documentRef, precondition);\n\n    return this;\n  }\n  /**\n   * Starts a transaction and obtains the transaction id from the server.\n   *\n   * @private\n   */\n\n\n  begin() {\n    const request = {\n      database: this._firestore.formattedName\n    };\n\n    if (this._transactionId) {\n      request.options = {\n        readWrite: {\n          retryTransaction: this._transactionId\n        }\n      };\n    }\n\n    return this._firestore.request('beginTransaction', request, this._requestTag, ALLOW_RETRIES).then(resp => {\n      this._transactionId = resp.transaction;\n    });\n  }\n  /**\n   * Commits all queued-up changes in this transaction and releases all locks.\n   *\n   * @private\n   */\n\n\n  commit() {\n    return this._writeBatch.commit_({\n      transactionId: this._transactionId,\n      requestTag: this._requestTag\n    }).then(() => {});\n  }\n  /**\n   * Releases all locks and rolls back this transaction.\n   *\n   * @private\n   */\n\n\n  rollback() {\n    const request = {\n      database: this._firestore.formattedName,\n      transaction: this._transactionId\n    };\n    return this._firestore.request('rollback', request, this._requestTag,\n    /* allowRetries= */\n    false);\n  }\n  /**\n   * Returns the tag to use with with all request for this Transaction.\n   * @private\n   * @return A unique client-generated identifier for this transaction.\n   */\n\n\n  get requestTag() {\n    return this._requestTag;\n  }\n\n}\n\nexports.Transaction = Transaction;\n/**\n * Parses the arguments for the `getAll()` call supported by both the Firestore\n * and Transaction class.\n *\n * @private\n * @param documentRefsOrReadOptions An array of document references followed by\n * an optional ReadOptions object.\n */\n\nfunction parseGetAllArguments(documentRefsOrReadOptions) {\n  let documents;\n  let readOptions = undefined;\n\n  if (Array.isArray(documentRefsOrReadOptions[0])) {\n    throw new Error('getAll() no longer accepts an array as its first argument. ' + 'Please unpack your array and call getAll() with individual arguments.');\n  }\n\n  if (documentRefsOrReadOptions.length > 0 && serializer_1.isPlainObject(documentRefsOrReadOptions[documentRefsOrReadOptions.length - 1])) {\n    readOptions = documentRefsOrReadOptions.pop();\n    documents = documentRefsOrReadOptions;\n  } else {\n    documents = documentRefsOrReadOptions;\n  }\n\n  for (let i = 0; i < documents.length; ++i) {\n    reference_1.validateDocumentReference(i, documents[i]);\n  }\n\n  validateReadOptions('options', readOptions, {\n    optional: true\n  });\n  const fieldMask = readOptions && readOptions.fieldMask ? readOptions.fieldMask.map(fieldPath => path_1.FieldPath.fromArgument(fieldPath)) : null;\n  return {\n    fieldMask,\n    documents\n  };\n}\n\nexports.parseGetAllArguments = parseGetAllArguments;\n/**\n * Validates the use of 'options' as ReadOptions and enforces that 'fieldMask'\n * is an array of strings or field paths.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the ReadOptions can be omitted.\n */\n\nfunction validateReadOptions(arg, value, options) {\n  if (!validate_1.validateOptional(value, options)) {\n    if (!util_1.isObject(value)) {\n      throw new Error(`${validate_1.invalidArgumentMessage(arg, 'read option')} Input is not an object.'`);\n    }\n\n    const options = value;\n\n    if (options.fieldMask !== undefined) {\n      if (!Array.isArray(options.fieldMask)) {\n        throw new Error(`${validate_1.invalidArgumentMessage(arg, 'read option')} \"fieldMask\" is not an array.`);\n      }\n\n      for (let i = 0; i < options.fieldMask.length; ++i) {\n        try {\n          path_1.validateFieldPath(i, options.fieldMask[i]);\n        } catch (err) {\n          throw new Error(`${validate_1.invalidArgumentMessage(arg, 'read option')} \"fieldMask\" is not valid: ${err.message}`);\n        }\n      }\n    }\n  }\n}","map":{"version":3,"sources":["/home/strider/Desktop/github/klaviyo-weather-powered-email/frontend/node_modules/@google-cloud/firestore/build/src/transaction.js"],"names":["Object","defineProperty","exports","value","path_1","require","reference_1","serializer_1","util_1","validate_1","READ_AFTER_WRITE_ERROR_MSG","ALLOW_RETRIES","Transaction","constructor","firestore","requestTag","previousTransaction","_firestore","_transactionId","_writeBatch","batch","_requestTag","get","refOrQuery","isEmpty","Error","DocumentReference","getAll_","then","res","Promise","resolve","Query","_get","getAll","documentRefsOrReadOptions","validateMinNumberOfArguments","arguments","parseGetAllArguments","documents","fieldMask","create","documentRef","data","set","options","update","dataOrField","preconditionOrValues","apply","delete","precondition","begin","request","database","formattedName","readWrite","retryTransaction","resp","transaction","commit","commit_","transactionId","rollback","readOptions","undefined","Array","isArray","length","isPlainObject","pop","i","validateDocumentReference","validateReadOptions","optional","map","fieldPath","FieldPath","fromArgument","arg","validateOptional","isObject","invalidArgumentMessage","validateFieldPath","err","message"],"mappings":"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","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst path_1 = require(\"./path\");\nconst reference_1 = require(\"./reference\");\nconst serializer_1 = require(\"./serializer\");\nconst util_1 = require(\"./util\");\nconst validate_1 = require(\"./validate\");\n/*!\n * Error message for transactional reads that were executed after performing\n * writes.\n */\nconst READ_AFTER_WRITE_ERROR_MSG = 'Firestore transactions require all reads to be executed before all writes.';\n/*!\n * Transactions can be retried if the initial stream opening errors out.\n */\nconst ALLOW_RETRIES = true;\n/**\n * A reference to a transaction.\n *\n * The Transaction object passed to a transaction's updateFunction provides\n * the methods to read and write data within the transaction context. See\n * [runTransaction()]{@link Firestore#runTransaction}.\n *\n * @class\n */\nclass Transaction {\n    /**\n     * @hideconstructor\n     *\n     * @param firestore The Firestore Database client.\n     * @param requestTag A unique client-assigned identifier for the scope of\n     * this transaction.\n     * @param previousTransaction If available, the failed transaction that is\n     * being retried.\n     */\n    constructor(firestore, requestTag, previousTransaction) {\n        this._firestore = firestore;\n        this._transactionId =\n            previousTransaction && previousTransaction._transactionId;\n        this._writeBatch = firestore.batch();\n        this._requestTag = requestTag;\n    }\n    /**\n     * Retrieve a document or a query result from the database. Holds a\n     * pessimistic lock on all returned documents.\n     *\n     * @param {DocumentReference|Query} refOrQuery The document or query to\n     * return.\n     * @returns {Promise} A Promise that resolves with a DocumentSnapshot or\n     * QuerySnapshot for the returned documents.\n     *\n     * @example\n     * firestore.runTransaction(transaction => {\n     *   let documentRef = firestore.doc('col/doc');\n     *   return transaction.get(documentRef).then(doc => {\n     *     if (doc.exists) {\n     *       transaction.update(documentRef, { count: doc.get('count') + 1 });\n     *     } else {\n     *       transaction.create(documentRef, { count: 1 });\n     *     }\n     *   });\n     * });\n     */\n    get(refOrQuery) {\n        if (!this._writeBatch.isEmpty) {\n            throw new Error(READ_AFTER_WRITE_ERROR_MSG);\n        }\n        if (refOrQuery instanceof reference_1.DocumentReference) {\n            return this._firestore\n                .getAll_([refOrQuery], \n            /* fieldMask= */ null, this._requestTag, this._transactionId)\n                .then(res => {\n                return Promise.resolve(res[0]);\n            });\n        }\n        if (refOrQuery instanceof reference_1.Query) {\n            return refOrQuery._get(this._transactionId);\n        }\n        throw new Error('Value for argument \"refOrQuery\" must be a DocumentReference or a Query.');\n    }\n    /**\n     * Retrieves multiple documents from Firestore. Holds a pessimistic lock on\n     * all returned documents.\n     *\n     * The first argument is required and must be of type `DocumentReference`\n     * followed by any additional `DocumentReference` documents. If used, the\n     * optional `ReadOptions` must be the last argument.\n     *\n     * @param {...DocumentReference|ReadOptions} documentRefsOrReadOptions The\n     * `DocumentReferences` to receive, followed by an optional field mask.\n     * @returns {Promise<Array.<DocumentSnapshot>>} A Promise that\n     * contains an array with the resulting document snapshots.\n     *\n     * @example\n     * let firstDoc = firestore.doc('col/doc1');\n     * let secondDoc = firestore.doc('col/doc2');\n     * let resultDoc = firestore.doc('col/doc3');\n     *\n     * firestore.runTransaction(transaction => {\n     *   return transaction.getAll(firstDoc, secondDoc).then(docs => {\n     *     transaction.set(resultDoc, {\n     *       sum: docs[0].get('count') + docs[1].get('count')\n     *     });\n     *   });\n     * });\n     */\n    getAll(...documentRefsOrReadOptions) {\n        if (!this._writeBatch.isEmpty) {\n            throw new Error(READ_AFTER_WRITE_ERROR_MSG);\n        }\n        validate_1.validateMinNumberOfArguments('Transaction.getAll', arguments, 1);\n        const { documents, fieldMask } = parseGetAllArguments(documentRefsOrReadOptions);\n        return this._firestore.getAll_(documents, fieldMask, this._requestTag, this._transactionId);\n    }\n    /**\n     * Create the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. The operation will\n     * fail the transaction if a document exists at the specified location.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * created.\n     * @param {DocumentData} data The object data to serialize as the document.\n     * @returns {Transaction} This Transaction instance. Used for\n     * chaining method calls.\n     *\n     * @example\n     * firestore.runTransaction(transaction => {\n     *   let documentRef = firestore.doc('col/doc');\n     *   return transaction.get(documentRef).then(doc => {\n     *     if (!doc.exists) {\n     *       transaction.create(documentRef, { foo: 'bar' });\n     *     }\n     *   });\n     * });\n     */\n    create(documentRef, data) {\n        this._writeBatch.create(documentRef, data);\n        return this;\n    }\n    /**\n     * Writes to the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. If the document\n     * does not exist yet, it will be created. If you pass\n     * [SetOptions]{@link SetOptions}, the provided data can be merged into the\n     * existing document.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * set.\n     * @param {DocumentData} data The object to serialize as the document.\n     * @param {SetOptions=} options An object to configure the set behavior.\n     * @param {boolean=} options.merge - If true, set() merges the values\n     * specified in its data argument. Fields omitted from this set() call\n     * remain untouched.\n     * @param {Array.<string|FieldPath>=} options.mergeFields - If provided,\n     * set() only replaces the specified field paths. Any field path that is not\n     * specified is ignored and remains untouched.\n     * @returns {Transaction} This Transaction instance. Used for\n     * chaining method calls.\n     *\n     * @example\n     * firestore.runTransaction(transaction => {\n     *   let documentRef = firestore.doc('col/doc');\n     *   transaction.set(documentRef, { foo: 'bar' });\n     *   return Promise.resolve();\n     * });\n     */\n    set(documentRef, data, options) {\n        this._writeBatch.set(documentRef, data, options);\n        return this;\n    }\n    /**\n     * Updates fields in the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. The update will\n     * fail if applied to a document that does not exist.\n     *\n     * The update() method accepts either an object with field paths encoded as\n     * keys and field values encoded as values, or a variable number of arguments\n     * that alternate between field paths and field values. Nested fields can be\n     * updated by providing dot-separated field path strings or by providing\n     * FieldPath objects.\n     *\n     * A Precondition restricting this update can be specified as the last\n     * argument.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * updated.\n     * @param {UpdateData|string|FieldPath} dataOrField An object\n     * containing the fields and values with which to update the document\n     * or the path of the first field to update.\n     * @param {\n     * ...(Precondition|*|string|FieldPath)} preconditionOrValues -\n     * An alternating list of field paths and values to update or a Precondition\n     * to to enforce on this update.\n     * @returns {Transaction} This Transaction instance. Used for\n     * chaining method calls.\n     *\n     * @example\n     * firestore.runTransaction(transaction => {\n     *   let documentRef = firestore.doc('col/doc');\n     *   return transaction.get(documentRef).then(doc => {\n     *     if (doc.exists) {\n     *       transaction.update(documentRef, { count: doc.get('count') + 1 });\n     *     } else {\n     *       transaction.create(documentRef, { count: 1 });\n     *     }\n     *   });\n     * });\n     */\n    update(documentRef, dataOrField, ...preconditionOrValues) {\n        validate_1.validateMinNumberOfArguments('Transaction.update', arguments, 2);\n        this._writeBatch.update.apply(this._writeBatch, [\n            documentRef,\n            dataOrField,\n            ...preconditionOrValues,\n        ]);\n        return this;\n    }\n    /**\n     * Deletes the document referred to by the provided [DocumentReference]\n     * {@link DocumentReference}.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * deleted.\n     * @param {Precondition=} precondition A precondition to enforce for this\n     * delete.\n     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n     * document was last updated at lastUpdateTime. Fails the transaction if the\n     * document doesn't exist or was last updated at a different time.\n     * @returns {Transaction} This Transaction instance. Used for\n     * chaining method calls.\n     *\n     * @example\n     * firestore.runTransaction(transaction => {\n     *   let documentRef = firestore.doc('col/doc');\n     *   transaction.delete(documentRef);\n     *   return Promise.resolve();\n     * });\n     */\n    delete(documentRef, precondition) {\n        this._writeBatch.delete(documentRef, precondition);\n        return this;\n    }\n    /**\n     * Starts a transaction and obtains the transaction id from the server.\n     *\n     * @private\n     */\n    begin() {\n        const request = {\n            database: this._firestore.formattedName,\n        };\n        if (this._transactionId) {\n            request.options = {\n                readWrite: {\n                    retryTransaction: this._transactionId,\n                },\n            };\n        }\n        return this._firestore\n            .request('beginTransaction', request, this._requestTag, ALLOW_RETRIES)\n            .then(resp => {\n            this._transactionId = resp.transaction;\n        });\n    }\n    /**\n     * Commits all queued-up changes in this transaction and releases all locks.\n     *\n     * @private\n     */\n    commit() {\n        return this._writeBatch\n            .commit_({\n            transactionId: this._transactionId,\n            requestTag: this._requestTag,\n        })\n            .then(() => { });\n    }\n    /**\n     * Releases all locks and rolls back this transaction.\n     *\n     * @private\n     */\n    rollback() {\n        const request = {\n            database: this._firestore.formattedName,\n            transaction: this._transactionId,\n        };\n        return this._firestore.request('rollback', request, this._requestTag, \n        /* allowRetries= */ false);\n    }\n    /**\n     * Returns the tag to use with with all request for this Transaction.\n     * @private\n     * @return A unique client-generated identifier for this transaction.\n     */\n    get requestTag() {\n        return this._requestTag;\n    }\n}\nexports.Transaction = Transaction;\n/**\n * Parses the arguments for the `getAll()` call supported by both the Firestore\n * and Transaction class.\n *\n * @private\n * @param documentRefsOrReadOptions An array of document references followed by\n * an optional ReadOptions object.\n */\nfunction parseGetAllArguments(documentRefsOrReadOptions) {\n    let documents;\n    let readOptions = undefined;\n    if (Array.isArray(documentRefsOrReadOptions[0])) {\n        throw new Error('getAll() no longer accepts an array as its first argument. ' +\n            'Please unpack your array and call getAll() with individual arguments.');\n    }\n    if (documentRefsOrReadOptions.length > 0 &&\n        serializer_1.isPlainObject(documentRefsOrReadOptions[documentRefsOrReadOptions.length - 1])) {\n        readOptions = documentRefsOrReadOptions.pop();\n        documents = documentRefsOrReadOptions;\n    }\n    else {\n        documents = documentRefsOrReadOptions;\n    }\n    for (let i = 0; i < documents.length; ++i) {\n        reference_1.validateDocumentReference(i, documents[i]);\n    }\n    validateReadOptions('options', readOptions, { optional: true });\n    const fieldMask = readOptions && readOptions.fieldMask\n        ? readOptions.fieldMask.map(fieldPath => path_1.FieldPath.fromArgument(fieldPath))\n        : null;\n    return { fieldMask, documents };\n}\nexports.parseGetAllArguments = parseGetAllArguments;\n/**\n * Validates the use of 'options' as ReadOptions and enforces that 'fieldMask'\n * is an array of strings or field paths.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the ReadOptions can be omitted.\n */\nfunction validateReadOptions(arg, value, options) {\n    if (!validate_1.validateOptional(value, options)) {\n        if (!util_1.isObject(value)) {\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, 'read option')} Input is not an object.'`);\n        }\n        const options = value;\n        if (options.fieldMask !== undefined) {\n            if (!Array.isArray(options.fieldMask)) {\n                throw new Error(`${validate_1.invalidArgumentMessage(arg, 'read option')} \"fieldMask\" is not an array.`);\n            }\n            for (let i = 0; i < options.fieldMask.length; ++i) {\n                try {\n                    path_1.validateFieldPath(i, options.fieldMask[i]);\n                }\n                catch (err) {\n                    throw new Error(`${validate_1.invalidArgumentMessage(arg, 'read option')} \"fieldMask\" is not valid: ${err.message}`);\n                }\n            }\n        }\n    }\n}\n//# sourceMappingURL=transaction.js.map"]},"metadata":{},"sourceType":"script"}